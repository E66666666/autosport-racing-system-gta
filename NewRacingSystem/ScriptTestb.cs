using GTA;
using GTA.Math;
using GTA.Native;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows.Forms;
using System.Xml;

/// <summary>
/// TO DO
/// 
/// </summary>
namespace NewRacingSystem
{

    public enum CurveStatus
    {
        Straight, Curve, FCurve
    }

    public enum RacerAbilities
    {
        TCSAmateur, TCSAdvanced, ABSAmateur, ABSAdvanced,CountersteerAmateur,CountersteerAdvanced
    }
    public enum RaceState
    {
            NotInitiated, Countdown, RaceInProgress, RaceFinished
    }

    public enum Options
    {
        Brakepower, Restart, Start, CleanEverything, ClearRacers, Freecam, LoadTrack, VisualDebug,Save
    }

    
    public enum DebugMode
    {
        None, Inputs, Trails, Cornering, Interactions
    }
    public class ScriptTest : Script
    {


        public static List<int> PreJumpNodes = new List<int>();

        public static string MusicEventTranquil = "";
        public static string MusicEventConflict = "";
        public static string MusicEventSecured = "";

        public static float ForcedBrakepower = 2f;
        public static List<Prop> CustomProps = new List<Prop>();
        public static List<Prop> AutoGeneratedProps = new List<Prop>();

        public static int OptionHovered = 0;
        public static List<Options> OptionsList = new List<Options>();


        int DistanceBetweenFlares=200;
        public static List<Racer> LeaderboardFinish = new List<Racer>();

        public static Camera FreeCam = null;
        bool IsDroneMode = true;
        public static Prop FreecCamRide = null;
        public static List<Model> RacerModels = new List<Model> {"a_m_y_motox_01", "a_m_y_motox_02" };
        public static RaceState RaceStatus = RaceState.NotInitiated;

        string ScriptName = "NewRacingSystem";
        string ScriptVer = "0.1.9.0 - 30/09/2018";
        string LatestChanges = "~g~- Added menus ~n~- Added Reverse/Handbrake/Reset for AI~n~- Improved track load";
        public static bool debugInfo = true;

        public static Camera CustomCamStart = null;
        public static Camera CustomCamEnd = null;

        static public ulong steeroffset = 0x0;

        public static ulong strangleoffset = 0x0;
        static public ulong throttleOffset = 0x0;
        static public ulong brakeOffset = 0x0;
        public static List<int> Other = new List<int> { 555004797, -399872228, -1447280105, 722686013 };
        public static List<int> Road = new List<int> { 1187676648, 282940568, -108464011, 1187676648, -1084640111, };       //-1286696947<grass
        public static List<int> Dirt = new List<int> { 1144315879, 510490462, -1907520769, -1885547121, -700658213, 2128369009,
            -1595148316,-765206029,509508168,1333033863,951832588,-840216541,-1907520769,510490462,-1942898710}; //-461750719
        public static List<int> Sand = new List<int> { 1288448767 ,};

        
        public enum TerrainTypes
        {
            Sand= 1288448767,
            RockySand = -1595148316,
            Gravel= -1885547121,
            GravelGrass= 2128369009,
            LooseGravel= 510490462,
            Rock = -840216541,
            MoreTarmac= 1187676648, //Concrete
            Tarmac = 282940568,
            WetTarmac =999829011,
            Grass= 1286696947,
            FullGrass=-461750719,
            ShortGrass = 1333033863,
        }
        public ScriptTest()
        {

            Tick += OnTick;
            KeyDown += OnKeyDown;
            KeyUp += OnKeyUp;
            
            UI.Notify("~b~"+ScriptName+"~y~ "+ScriptVer);
            // UI.Notify("Latest changes:~n~" + LatestChanges);

            FreeCam = World.CreateCamera(Vector3.Zero, Vector3.Zero, GameplayCamera.FieldOfView);// Function.Call<Camera>(Hash.CREATE_CAMERA, 26379945, true); 
            CustomCamStart = World.CreateCamera(Vector3.Zero, Vector3.Zero, GameplayCamera.FieldOfView);
            CustomCamEnd = World.CreateCamera(Vector3.Zero, Vector3.Zero, GameplayCamera.FieldOfView);

            //Function.Call(Hash.SET_USE_HI_DOF);
            Function.Call(Hash.SET_CAM_NEAR_CLIP, FreeCam, 0.01f);


            //Vector3 c = FreeCam.Position;
            //Function.Call(Hash.SET_CAM_PARAMS, FreeCam, c.X, c.Y, c.Z, -5.0851f, 0f, -80.687f, 50f, 0, 0, 0, 0);

            Function.Call(Hash._0x7DD234D6F3914C5B, FreeCam, 1f);//lens

            Function.Call(Hash._0xC3654A441402562D, FreeCam, 0f); //_SET_CAM_DOF_MAX_NEAR_IN_FOCUS_DISTANCE
            Function.Call(Hash._0x2C654B4943BDDF7C, FreeCam, 0f); //blend
                                                                  // Function.Call(Hash.SET_CAM_DOF_STRENGTH, FreeCam, 1f);

            //Function.Call(Hash.SET_CAM_USE_SHALLOW_DOF_MODE, FreeCam, 1);
            //    Function.Call(Hash.SET_CAM_DOF_PLANES, FreeCam, 5f, 5.1f, 7f, 7.1f);

            //Function.Call(Hash._0xC669EEA5D031B7DE, FreeCam, 4f); //distance bias
            //CAM::SET_CAM_PARAMS(iLocal_157, 825.9243f, -3236.654f, -97.4617f, -5.0851f, 0f, -80.687f, 50f, 0, 1, 1, 2);



            //apa_prop_yacht_glass_03 //prop_jewel_glass
            //xm_prop_facility_glass_01o



        }



        public static int MaxLaps = 1;

        //Loaded from config
        public static float MaxIdealSpeed = 200f;

        public static  float SpeedToInput = 10f;
        public static float max_angle = 3f;
        public static float max_speed = 40f;
        public static float min_speed = 10f;
        public static int TuningLevel = 0;
        public static int TCSLevel = -1;
        public static int AIRacerAutofix = 1;
        public static bool SpawnTracksideProps = true;
        public static List<Prop> TrackLimits = new List<Prop>();
        public static List<Vector3> Path = new List<Vector3>();
        public static Dictionary<int, float> Angles = new Dictionary<int, float>();
        public static Dictionary<int, Vector3> Directions = new Dictionary<int, Vector3>();
        public static Vector3 MiniMap = Vector3.Zero;


        public static XmlDocument CurrentFile = null;
        List<Vector3> Test = new List<Vector3>
        {

        };

        public static Dictionary<int, float> WideDict = new Dictionary<int, float>();
        public static Dictionary<int, float> EditWideDict = new Dictionary<int, float>();

        public static Dictionary<VehicleHash, float> StoppingPower = new Dictionary<VehicleHash, float>();

        Vector3 target = Vector3.Zero;
        Vector3 oldrecord = Vector3.Zero;
        bool record = false;

        float recordH = 0;

        public static int DebugLevel = 0;
        public static bool IsShiftOn = false;
        public static float Confidence = 1f;
        public static float BrakeDist = 1f; //100 for Realistic Driving, 10 for vanilla
        public static float Distance = 10f; //10, distance to follow the nodes ahead
        public static float MaxOffset = 5f; //Sideways offset
        public static float gamma = 1f; //Angle to speed relationship
        public static float steerGamma = 1f; //Angle to steer angle relationship
        int GametimerefLong = 0;

        float TimeScale = 1f;
        float IdealTimeScale = 1f;
        int GameTimeRef = 0;
        public static List<Racer> Racers = new List<Racer>();

        public static float Clamp(float val, float min, float max)
        {
            if (val.CompareTo(min) < 0) return min;
            else if (val.CompareTo(max) > 0) return max;
            else return val;
        }
        public static Vector2 GetClosestPointOnLineSegment(Vector2 A, Vector2 B, Vector2 P)
        {
            Vector2 AP = P - A;       //Vector from A to P   
            Vector2 AB = B - A;       //Vector from A to B  

            float magnitudeAB = AB.LengthSquared();     //Magnitude of AB vector (it's length squared)     
            float ABAPproduct = Vector2.Dot(AP, AB);    //The DOT product of a_to_p and a_to_b     
            float distance = ABAPproduct / magnitudeAB; //The normalized "distance" from a to your closest point  

            if (distance < 0)     //Check if P projection is over vectorAB     
            {
                return A;
            }
            else if (distance > 1)
            {
                return B;
            }
            else
            {
                return A + AB * distance;
            }
        }

        public static Vector3 GetClosestPointOnLineSegment(Vector3 A, Vector3 B, Vector3 P)
        {
            Vector3 AP = P - A;       //Vector from A to P   
            Vector3 AB = B - A;       //Vector from A to B  

            float magnitudeAB = AB.LengthSquared();     //Magnitude of AB vector (it's length squared)     
            float ABAPproduct = Vector3.Dot(AP, AB);    //The DOT product of a_to_p and a_to_b     
            float distance = ABAPproduct / magnitudeAB; //The normalized "distance" from a to your closest point  

            if (distance < 0)     //Check if P projection is over vectorAB     
            {
                return A;
            }
            else if (distance > 1)
            {
                return B;
            }
            else
            {
                return A + AB * distance;
            }
        }
        public static float LeftOrRight(Vector3 pos, Vector3 refr, Vector3 dir)
        {
            Vector3 right = Vector3.Cross(dir, Vector3.WorldUp);
            Vector3 rPos = pos - refr;

            return Vector3.Dot(right, rPos);

        }
        public static Vector3 GetOffset(Entity reference, Entity ent)
        {

            Vector3 pos = ent.Position;
            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, reference, pos.X, pos.Y, pos.Z);

        }
        public static Vector3 GetOffset(Entity reference, Vector3 pos)
        {

            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, reference, pos.X, pos.Y, pos.Z);

        }
        public static Vector3 ConvertToLocalOffset(Entity reference, Vector3 pos)
        {

            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS, reference, pos.X, pos.Y, pos.Z);

        }

        public static float map(float x, float in_min, float in_max, float out_min, float out_max)
        {
            return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
        }
        /*
          IntPtr addr = (IntPtr)FindPattern("\x40\x53\x48\x83\xEC\x20\x80\x3D\x00\x00\x00\x00\x00\x8B\xDA\x75\x29",
                            "xxxxxxxx????xxxxx");
            if (addr != IntPtr.Zero)
            {
                byte* g_bIsDecorRegisterLockedPtr = (byte*)(addr + *(int*)(addr + 8) + 13);
                *g_bIsDecorRegisterLockedPtr = 1;
            }
            */



        public unsafe static byte* FindPattern(string pattern, string mask)
        {
            ProcessModule module = Process.GetCurrentProcess().MainModule;

            ulong address = (ulong)module.BaseAddress.ToInt64();
            ulong endAddress = address + (ulong)module.ModuleMemorySize;

            for (; address < endAddress; address++)
            {
                for (int i = 0; i < pattern.Length; i++)
                {
                    if (mask[i] != '?' && ((byte*)address)[i] != pattern[i])
                    {
                        break;
                    }
                    else if (i + 1 == pattern.Length)
                    {
                        return (byte*)address;
                    }
                }
            }

            return null;
        }


        

        static public unsafe float GetTrueSteer(Vehicle handle)
        {

            if (!CanWeUse(handle)) return 0f;
            /*
            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;
            ulong offset = 0x944;
            //  //UI.ShowSubtitle((*((float*)(address + offset))).ToString());
            return *((float*)(address + offset));*/


            if (steeroffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {

                    //    UI.Notify(throttleOffset.ToString());

                    steeroffset = *(uint*)(addr + 6) + 8;
                    //UI.Notify(throttleOffset.ToString());
                    // UI.Notify((0x94C).ToString());
                }
            }
            else if (1 == 1)
            {
                var address = (ulong)handle.MemoryAddress;
                //   ulong offset = 0x94C; address +offset

             return   *((float*)(address + steeroffset)) ;
            }

            return 0;
        }

        static public unsafe void SetTrueSteer(Vehicle handle, float value)
        {

            /*
            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;
            ulong offset = 0x944;
            //  //UI.ShowSubtitle((*((float*)(address + offset))).ToString());
            *((float*)(address + offset)) = value;

            */

            if (steeroffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {

                    //    UI.Notify(throttleOffset.ToString());

                    steeroffset = *(uint*)(addr + 6) + 8;
                    //UI.Notify(throttleOffset.ToString());
                    // UI.Notify((0x94C).ToString());
                }
            }
            else if (1 == 1)
            {
                var address = (ulong)handle.MemoryAddress;
                //   ulong offset = 0x94C; address +offset

                *((float*)(address + steeroffset)) = value;
            }

        }
        static public unsafe void SetTrueSteerAngle(Vehicle handle, float value)
        {

            /*
            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;
            ulong offset = 0x944;
            //  //UI.ShowSubtitle((*((float*)(address + offset))).ToString());
            *((float*)(address + offset)) = value;

            */

            if (strangleoffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {
             //       UI.ShowSubtitle("finding offset", 1000);
                    //    UI.Notify(throttleOffset.ToString());

                    strangleoffset = *(uint*)(addr + 6);
                    //UI.Notify(throttleOffset.ToString());
                    // UI.Notify((0x94C).ToString());
                }
            }
            else
            {
               // UI.ShowSubtitle("applying offset", 1000);

                var address = (ulong)handle.MemoryAddress;
                //   ulong offset = 0x94C; address +offset

                *((float*)(address + strangleoffset)) = value;
            }

        }
        static public unsafe void SetThrottle(Vehicle handle, float value)
        {
            if (throttleOffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {


                    throttleOffset =  *(uint*)(addr + 6) + 0x10;

                }
            }
            else if(1==1)
            {
                var address = (ulong)handle.MemoryAddress;

                *((float*)(address + throttleOffset)) = value;
            }
            

        }
        static public unsafe void SetBrakes(Vehicle handle, float value)
        {

            if (brakeOffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {

                    brakeOffset = *(uint*)(addr + 6) + 0x14;
                }
            }
            else if (1 ==1)
            {
                var address = (ulong)handle.MemoryAddress;

                *((float*)(address + brakeOffset)) = value;
            }

        }
        public static float rad2deg(float rad)
        {
            return (rad * (180.0f / 3.14159265358979323846264338327950288f));
        }

        static public float CalculateDesiredHeading(Vehicle vehicle, float steeringAngle, float steeringMax, float desiredHeading, float reduction)
        {
            float correction = desiredHeading * reduction;

            float ySpeed =Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, vehicle, true).Y;

            if (Math.Abs(ySpeed) > 3.0f)
            {
                Vector3 velocityWorld = Function.Call<Vector3>(Hash.GET_ENTITY_VELOCITY,vehicle);
                Vector3 positionWorld = Function.Call<Vector3>(Hash.GET_ENTITY_COORDS,vehicle, true);
                Vector3 travelWorld = velocityWorld + positionWorld;

                float steeringAngleRelX = (float)(Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, vehicle, true).Y * -Math.Sin(steeringAngle));
                float steeringAngleRelY = (float)(Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, vehicle, true).Y * Math.Cos(steeringAngle));
                Vector3 steeringWorld = Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS, vehicle, steeringAngleRelX, steeringAngleRelY, 0.0f);

                Vector3 travelNorm =(travelWorld - positionWorld).Normalized;
                Vector3 steerNorm = (steeringWorld - positionWorld).Normalized;
                float travelDir = (float)(Math.Atan2(travelNorm.Y, travelNorm.X) + desiredHeading * reduction);
                float steerDir = (float)(Math.Atan2(steerNorm.Y, steerNorm.X));

                correction = (float)(2.0f * Math.Atan2(Math.Sin(travelDir - steerDir), Math.Cos(travelDir - steerDir)));
            }
            if (correction > steeringMax)
                correction = steeringMax;
            if (correction < -steeringMax)
                correction = -steeringMax;


            return correction;
        }

        static float getSpeedSteeringRatio(float degrees, float gamma)//, float minSpeed, float minAngle, float maxSpeed, float maxAngle)
        {

            degrees /= 45f; // scale to 1.0;
                            // if (degrees > 1) degrees = 1;
            degrees = (float)Math.Pow(degrees, gamma);
            float maxSpeed = 20;
            float minSpeed = 0f;

            float minAngle = 0.0f;
            float maxAngle = 1.0f;

            // Depending on your map function you might wanna add clamping.
            // My map function doesn't clamp.
            float speed = map(degrees, maxAngle, minAngle, maxSpeed, minSpeed);

            // clamp
            // speed = fmaxf(speed, maxSpeed);
            //speed = fminf(speed, minSpeed);
            //if (speed < 20) speed = 20;

            return speed;
        }
        public static Dictionary<int, float> MultiplierInTerrain = new Dictionary<int, float>();
        public static float GetSpeedForAngle(float degrees, float confidence)
        {
              degrees /= confidence;
            if (degrees > max_angle) degrees = max_angle;
            degrees /= max_angle; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, 0.3f); //original 0.4f

            float maxSpeed = max_speed;//60f;
            float minSpeed = min_speed;//20f;

            float minAngle = 0f;
            float maxAngle = 1.0f;
 
            float speed = map(degrees, minAngle, maxAngle, maxSpeed, minSpeed);

            if (speed < minSpeed) speed = minSpeed;
            if (speed > maxSpeed) speed = maxSpeed;
            return speed;
        }



        
        public static float GetMaxTRCurveOvershoot(float cornerAngle)//, float minSpeed, float minAngle, float maxSpeed, float maxAngle)
        {
            
            if (cornerAngle > 2f) cornerAngle = 2f;
            cornerAngle /= 2f; // scale to 1.0;
            cornerAngle = (float)Math.Pow(cornerAngle, 1);
            float maxSpeed = 5f;//90f;
            float minSpeed = 1f;//20f;

            float minAngle = 0f;
            float maxAngle = 1.0f;

            float maxOvershoot = map(cornerAngle, minAngle, maxAngle, maxSpeed, minSpeed);
            if (maxOvershoot < minSpeed) maxOvershoot = minSpeed;
            if (maxOvershoot > maxSpeed) maxOvershoot = maxSpeed;
           // DisplayHelpTextTimed(cornerAngle.ToString() > maxOvershoot.ToString(), 1000);

            return maxOvershoot;
        }
        /* for 5m
        public static float GetSpeedForAngle(float degrees, float gamma)//, float minSpeed, float minAngle, float maxSpeed, float maxAngle)
        {
            if (degrees > 4f) degrees = 4f;
            degrees /= 4f; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, gamma);
            float maxSpeed = 126f;//90f;
            float minSpeed = 28f;//20f;

            float minAngle = 0f;
            float maxAngle = 1.0f;
            // Depending on your map function you might wanna add clamping.
            // My map function doesn't clamp.
            float speed = map(degrees, minAngle, maxAngle, maxSpeed, minSpeed);
            if (speed < minSpeed) speed = minSpeed;
            if (speed > maxSpeed) speed = maxSpeed;
            //if (speed > 40f) speed = 40f;
            // clamp
            // speed = fmaxf(speed, maxSpeed);
            //speed = fminf(speed, minSpeed);

            return speed;
        }*/

        public static float GetRatioForAngle(float degrees, float gamma)//, float minSpeed, float minAngle, float maxSpeed, float maxAngle)
        {
            if (degrees > 40) degrees = 40;
            degrees /= 40; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, gamma);
            float maxSpeed = 0f;
            float minSpeed = 1f;

            float minAngle = 0f;
            float maxAngle = 1.0f;
            // Depending on your map function you might wanna add clamping.
            // My map function doesn't clamp.
            float speed = map(degrees, minAngle, maxAngle, maxSpeed, minSpeed);

            if (speed > 1f) speed = 1f;
            // clamp
            // speed = fmaxf(speed, maxSpeed);
            //speed = fminf(speed, minSpeed);

            return speed;
        }

        public static float getAngleToSteerRatio(float degrees, float gamma)//, float minSpeed, float minAngle, float maxSpeed, float maxAngle)
        {
            degrees /= 40; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, gamma);
            float maxSteer = 40f;
            float minSteer = 0f;

            float minAngle = 0.0f;
            float maxAngle = 1.0f;
            // Depending on your map function you might wanna add clamping.
            // My map function doesn't clamp.
            float speed = map(degrees, minAngle, maxAngle, minSteer, maxSteer);

            // clamp
            // speed = fmaxf(speed, maxSpeed);
            //speed = fminf(speed, minSpeed);

            return speed;
        }

        public static float GetMaxSteeringForSpeed(float degrees, float gamma)//, float minSpeed, float minAngle, float maxSpeed, float maxAngle)
        {
            degrees /= 40; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, gamma);
            float maxSteer = 40f;
            float minSteer = 0f;

            float minAngle = 0.0f;
            float maxAngle = 1.0f;

            // Depending on your map function you might wanna add clamping.
            // My map function doesn't clamp.
            float speed = map(degrees, minAngle, maxAngle, minSteer, maxSteer);

            // clamp
            // speed = fmaxf(speed, maxSpeed);
            //speed = fminf(speed, minSpeed);

            return speed;
        }

        List<Vector3> temp = new List<Vector3>();


        List<dynamic> infoPlayerNode = new List<dynamic>();
        //Prop UndersteerPlayerProp = World.CreateProp("prop_candy_pqs", Game.Player.Character.Position.Around(2), true, true);
        Vector3 rBezier = Vector3.Zero;
        float scale = 1.5f;
        int wide = 5;

        int PathDisplayFidelity = 1;

        int GameTimeLoadConfig = 0;


        int GametimeCountDown =0;
        int MaxCountDown = 7;

        int CountDown = 7;

        Vector3 FreeCamMovement = Vector3.Zero;
        Vector3 FreeCamRotation = Vector3.Zero;
        Entity FreeCamFollow = null;
        public static  Scaleform scaleform = new Scaleform("instructional_buttons");
        public static Scaleform racertext = null;// new Scaleform("mp_car_stats_01");
        public static Scaleform debugFrontend = new Scaleform("instructional_buttons");
        public static Scaleform floatingtext = new Scaleform("HUD_FLOATING_HELP_TEXT");

        public static Scaleform Countdown = null;//  new Scaleform("MP_BIG_MESSAGE_FREEMODE");


        string ParsedEnum(string t)
        {
            return string.Concat(t.Select(x => Char.IsUpper(x) ? " " + x : x.ToString())).TrimStart(' ');
        }
        void HandleMenu()
        {
            if (OptionsList.Count == 0) return;
            Game.DisableControlThisFrame(2, GTA.Control.Phone);

            string Menu = "-- Options --";
            if (OptionHovered > OptionsList.Count - 1) OptionHovered= OptionsList.Count - 1;
            if (OptionHovered < 0) OptionHovered = OptionsList.Count - 1;

            foreach (Options o in OptionsList)
            {
                Menu += "~n~";
                if (o == OptionsList[OptionHovered]) Menu += "~b~ " + ParsedEnum(o.ToString()) + "~w~";
                else Menu += ParsedEnum (o.ToString());

                if (o == Options.Brakepower) Menu += " [" + Math.Round(ForcedBrakepower, 2) + "]";
                if (o == Options.VisualDebug) Menu += " [" + DebugLevel.ToString() + "]";

            }
            DrawText(new Vector2(0.02f, 0.4f), Menu, Color.White, DrawTextFont.Default, DrawTextAlign.Left, 0.5f);

            //UI.ShowSubtitle(Menu,1000);
            Options oSelected = OptionsList[OptionHovered];





            if (Game.IsControlJustPressed(2, GTA.Control.FrontendDown)) OptionHovered++;
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendUp)) OptionHovered--;

            if (OptionHovered < 0) OptionHovered = OptionsList.Count - 1;
            if (OptionHovered > OptionsList.Count - 1) OptionHovered = 0;

            if (Game.IsControlJustPressed(2, GTA.Control.FrontendLeft))
            {
                if (oSelected == Options.Brakepower)
                {
                    ForcedBrakepower -= 0.2f;
                }
                if (oSelected == Options.VisualDebug)
                {
                    DebugLevel--;
                    if (DebugLevel < 0) DebugLevel = 0;
                }
            }
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendRight))
            {

                if (oSelected == Options.Brakepower)
                {
                    ForcedBrakepower += 0.2f;
                }
                if (oSelected == Options.VisualDebug)
                {
                    DebugLevel++;
                }
            }
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendAccept))
            {
                
                if (oSelected == Options.ClearRacers)
                {
                    StartStopRace();
                    
                }
                if (oSelected == Options.CleanEverything)
                {
                    
                    foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();

                    StartStopRace();



                    WideDict.Clear();
                    EditWideDict.Clear();
                    Path.Clear();
 
                    foreach (int fx in FlareFX) Function.Call(Hash.STOP_PARTICLE_FX_LOOPED, fx);
                    FlareFX.Clear();
                    LeaderboardFinish.Clear();
                    record = false;


                    foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
                    foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
                    foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
                    Directions.Clear();
                    Angles.Clear();
                    Path.Clear();
                    WideDict.Clear();
                }
                if (oSelected == Options.LoadTrack)
                {
                    LoadTrack();
                }
                if (oSelected == Options.Start)
                {
                    StartStopRace();
                }
                if (oSelected == Options.Freecam)
                {
                    ToggleFreeCam();
                }
                if (oSelected == Options.Restart)
                {
                    if (Racers.Count > 0)
                    {
                        GametimeCountDown = 0;
                        SetupRace(true, false);
                    }
                }
                if (oSelected == Options.Brakepower)
                {
                    foreach (Racer r in Racers) r.mphStopInTenMeters = ForcedBrakepower;

                    UI.Notify("Forced " + ForcedBrakepower + " expected brakepower on all racers.");
                }


                OptionsList.Clear();
            }
        }


        void HandlePlayerDebugStuff()
        {
            Vehicle v = Game.Player.Character.CurrentVehicle;

            if (CanWeUse(v))
            {
                float wheelspin = GetWheelsMaxWheelspin(v);
                if (Math.Abs(wheelspin) > 1f)
                {
                    
                   
                    GameplayCamera.Shake(CameraShake.Jolt,Math.Abs(wheelspin * 0.005f));
                    //Function.Call(Hash._0xF4C8CF9E353AFECA, "JOLT_SHAKE", Math.Abs(wheelspin * 0.005f));
                    Function.Call(Hash.SHAKE_CINEMATIC_CAM, "JOLT_SHAKE", Math.Abs(wheelspin * 0.005f));
                    

                }
            }
        }


        void DrawBlackBars(float intensity)
        {
            Function.Call(Hash.DRAW_RECT, 0.5f, 0f, 1f, intensity, 0f, 0f, 0f, 255, 0f);
            Function.Call(Hash.DRAW_RECT, 0.5f, 1f, 1f, intensity, 0f, 0f, 0f, 255, 0f);
        }
        int playerdebuggametime = 0;
        int flarefx = -1;

        int Interp = -1;

        int shard = 0;


        List<Vector3> MiniaturizedPath = new List<Vector3>();
        void DrawMiniaturizedPath(Vector3 pos)
        {
            if (!Game.Player.Character.IsInRangeOf(pos, 20f)) return;
            if (Path.Count > 0)
            {
                if (MiniaturizedPath.Count == 0)
                {
                    Vector3 middle = Vector3.Zero;
                    foreach (Vector3 posp in Path) middle += posp;

                    middle /= Path.Count;


                    int c = (int)(Path.Count * 0.1f);// 14

                    Vector3 newpos = (Path[4]) - middle;

                    foreach (Vector3 modded in Path)
                    {
                        c++;
                        if (c >= 15)
                        {
                            c = 0;

                            Vector3 lerped = Vector3.Lerp(middle, modded, 0.005f);
                           // lerped += newpos;// (Game.Player.Character.Position - lerped)*0.95f;
                                             //  mini.Add(LerpByDistance(middle, modded, 20f)+new Vector3(0,0,4));
                            MiniaturizedPath.Add(lerped);// + new Vector3(0, 0, 20));

                        }
                    }
                }
                else
                {
                    Vector3 modified =  (pos-MiniaturizedPath[0]);
                    Vector3 last = MiniaturizedPath[MiniaturizedPath.Count - 1];
                    foreach (Vector3 vm in MiniaturizedPath)
                    {
                        
                        if (vm == MiniaturizedPath[0])
                        {
                            World.DrawMarker(MarkerType.CheckeredFlagRect, vm + modified, (last - vm).Normalized, new Vector3(0, 0, 0), new Vector3(0.1f, 0.1f, 0.1f), Color.White);// DrawLine(vm,last, Color.Black);
                        }
                        else
                        {
                            DrawLine(vm+ modified, last+modified, Color.SkyBlue);

                            //World.DrawMarker(MarkerType.ChevronUpx1, vm + modified, (last - vm).Normalized, new Vector3(-90, 0, 0), new Vector3(0.1f, 0.1f, 0.1f), Color.SkyBlue);// DrawLine(vm,last, Color.Black);
                        }

                        last = vm;
                    }

                }



         //     DrawLine(MiniaturizedPath[0], Game.Player.Character.Position+new Vector3(0,0,3), Color.Red);
              //  DrawPath(MiniaturizedPath, null, 1);
                //foreach(Vector3 final in mini) DrawLine(final, Game.Player.Character.Position, Color.Red);
            }
        }
        int GameTimeShort = Game.GameTime;
        void OnTick(object sender, EventArgs e)
        {

            //SetTrueSteerAngle(Game.Player.Character.LastVehicle, 20f);
            if (GameTimeShort < Game.GameTime)
            {
                GameTimeShort = Game.GameTime+200;


                /*
                if (TimeScale < 1.0f)
                {
                    Function.Call(Hash.HIDE_HUD_AND_RADAR_THIS_FRAME, true);
                    float t = map(TimeScale, 1f, 0.2f, 0f, 0.25f);
                    DrawBlackBars(t);


                }

                */
                if (TimeScale > IdealTimeScale)
                {
                    UI.ShowSubtitle("Timescale down", 500);
                    TimeScale -= 0.1f;
                    if (TimeScale < IdealTimeScale) TimeScale = IdealTimeScale;
                    TimeScale = (float)Math.Round(TimeScale, 12);
                    Game.TimeScale = TimeScale;
                }
                if (TimeScale < IdealTimeScale)
                {
                    UI.ShowSubtitle("Timescale up", 500);
                    TimeScale += 0.1f;
                    if (TimeScale > IdealTimeScale) TimeScale = IdealTimeScale;
                    TimeScale = (float)Math.Round(TimeScale, 2);
                    Game.TimeScale = TimeScale;
                }

            }



            if (Path.Count > 20 && MiniMap!= Vector3.Zero) DrawMiniaturizedPath(MiniMap);
            //DrawStats("Car", "Desc", "1", "2", "3", "4", (int)Game.Player.Character.Velocity.Length(),0, 0, 0, Game.Player.Character.Position+new Vector3(0,0,6));

            if (Countdown == null || !Countdown.IsLoaded)
            {
                Countdown = new Scaleform("MP_BIG_MESSAGE_FREEMODE");
            }
            Vehicle pveh = Game.Player.Character.CurrentVehicle;

            if (Game.IsControlJustPressed(2, GTA.Control.Context))
            {
                

                //   UI.Notify("d");

                //   pveh.SetMod(VehicleMod.AirFilter, 1, false);


                //  Function.Call((Hash)0x645D663DC4B987AF, pveh, -1532864817);
                //  Function.Call((Hash)0xC8E9B6B71B8E660D, pveh, 1);

                //foreach (Racer r in Racers)// Function.Call(Hash.81E1552E35DC3839, r.Car, true);

                //r.HandbrakeTime = Game.GameTime + 1000;
                //GetTRCurveMax(Game.Player.Character.LastVehicle);
                //     Function.Call(Hash._TRANSITION_FROM_BLURRED,500f);                Function.Call(Hash._TRANSITION_TO_BLURRED, 500f);

                //Function.Call(Hash.SET_WARNING_MESSAGE, "ddd", (int)GTA.Control.FrontendAccept, "adDDDDDDDer", false, -1, 0, 0, true);
                //   Any ADD_PETROL_DECAL(float x, float y, float z, float groundLvl, float width, float transparency) // 0x4F5212C7AD880DF8 0x1259DF42 b323
                //               Vector3 pos= Game.Player.Character.Position-new Vector3(0,0,Game.Player.Character.HeightAboveGround);
                //   Function.Call(Hash.ADD_PETROL_DECAL, pos.X, pos.Y, pos.Z, 5f, 10f, 1f);
            }
            if (Game.IsControlJustPressed(2, GTA.Control.VehicleLookBehind))
            {
                //Function.Call((Hash)0x9849DE24FCF23CCC, pveh,  1);
                //UI.Notify(Function.Call<bool>((Hash)0x13C7B79AB4308104, pveh, 0).ToString());
             //   Function.Call((Hash)0x6411EB7E837170B5, pveh, 0f);

                //Game.Player.Character.Alpha = 255;
                //Function.Call(Hash.NETWORK_FADE_IN_ENTITY, Game.Player.Character, true, true);
                //    Function.Call(Hash.SET_GAMEPLAY_ENTITY_HINT, FreecCamRide, 0.0f, 0.0f, -0.0f, true, 2000, 2000, 1500, 1844968929); //duration, in, out, flags
                {
                    //                    MissionPassed.CallFunction("SHOW_SHARD_CENTERED_MP_MESSAGE", "LOADING", ShardText, (int)12, (int)2);

                    //scaleform.Call(sf, "FADE_MP", "1", 255, 35, 35)
                    //Countdown.CallFunction("FADE_MP", "3", 255, 35, 35);

                    //function SHOW_SHARD_WASTED_MP_MESSAGE(bigTxt, msgTxt, colId, someUnusedBoolean, darkenBackground)

                    //      Countdown.CallFunction("SET_MESSAGE", "Ur a fag LOL", 0, 0,0);
                    //    Countdown.CallFunction("SET_COLOUR", 12);

                    //Countdown.CallFunction("SHOW_SHARD_CENTERED_MP_MESSAGE", "Countdown", "", (int)12, (int)2);
                    //Countdown.CallFunction("SET_MESSAGE", "GO!", 35, 122, 221, 0);

                    //Countdown.CallFunction("SHOW");
                    //   Countdown.CallFunction("SET_TEXT", "Vanillaworks Releases Despacito 5", "December 2025");
                    //  Countdown.CallFunction("SHOW_STATIC",3);
                    //Countdown.CallFunction("DISPLAY_SCROLL_TEXT", "Vanillaworks ", -1, "Releases Despacito 5");
                    //   Countdown.CallFunction("SET_CLUBHOUSE_NAME","Name", 12, 3);
                    //  Countdown.CallFunctionSET_STAGE_TEXTREADY",1);
                    //  Countdown.CallFunction("SET_STUNT_JUMP_TITLE_AND_DESCRIPTION", "dd", "ddd",0.3f);

                    //Countdown.CallFunction("SHOW_SHARD_STUNT_JUMP", "dd","ddd");

                    /*
                    Countdown.CallFunction("SET_TITLE","");
                    Countdown.CallFunction("SET_SUBTITLE", "Racers");
                    Countdown.CallFunction("SET_SLOT", 1, 2,"Juan");
                    Countdown.CallFunction("SET_SLOT", 2, 2, "John");
                    Countdown.CallFunction("SET_SLOT", 3, 2, "Eddlm");
                    Countdown.CallFunction("SET_SLOT", 4, 2, "XxXKillerXxX");
                    */
                }





            }
            if (Game.IsControlJustReleased(2, GTA.Control.Context))
            {
       //   if(Countdown!=null&& Countdown.IsLoaded)      Countdown.CallFunction("TRANSITION_OUT", 0.4f);

            }

            if (Countdown != null && Countdown.IsLoaded)
            {
                //  Countdown.Render3D( Game.Player.Character.Position+new Vector3(0,0,1),Game.Player.Character.ForwardVector,new Vector3(1,1,1));
             //   UI.ShowSubtitle("Rendering", 500);
                Countdown.Render2D();
            }
            //_0xE6B0E8CFC3633BF0 int, can be 2
            //_0xE43701C36CAFF1A4 bool, planes only
            //8533CAFDE1F0F336 bool
            /*
            Vehicle pcar = Game.Player.Character.CurrentVehicle;
            float accdiff = Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, pcar) - Function.Call<float>(Hash.GET_VEHICLE_MODEL_ACCELERATION, pcar.Model.Hash);
            int power =(int)(Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, pcar) * 100f);
            int price = (int)(Function.Call<int>((Hash)0x5873C14A52D74236, pcar.Model.Hash) );
            int traction =  (int) map( Function.Call<float>(Hash.GET_VEHICLE_MAX_TRACTION, pcar), 1f,2f, 0, 100);
            int topspd = (int)(Function.Call<float>(Hash._GET_VEHICLE_MAX_SPEED, pcar.Model.Hash) * (1f*(1f+(accdiff*2f) )));
            DrawStats(pcar.FriendlyName, pcar.ClassType.ToString()+ " - $"+ price*0.01f+"k", "Engine", "Top Speed", "Base Traction", "Offroad Ability", //+ (int)(topspd * 2.236936f) +"mph"
               power, topspd, traction, (int)25, pcar.Position+new Vector3(0,0, pcar.Model.GetDimensions().Z + 4.5f));
            // (price * 0.001f)
            // string grip = "Current: " +Function.Call<bool>((Hash)0xE33FFA906CE74880, pcar).ToString();
            // grip+= "~n~Original: " +  Function.Call<float>(Hash.0x8533CAFDE1F0F336, pcar.Model.Hash).ToString();

            //    string down = GetSurfaceHash(Game.Player.Character.Position, Game.Player.Character.Position + Vector3.WorldDown).ToString();
            // down += "~n~" + Function.Call<int>(Hash.GET_HASH_KEY, "SAND_LOOSE");
            DisplayHelpTextThisFrame(accdiff.ToString());
            */
            HandleFreecam();
            switch (Interp)
            {
                case 0:
                    {

                        Function.Call(Hash.SET_GAMEPLAY_CAM_RELATIVE_HEADING, 0f);
                        
                        UI.ShowSubtitle("Start interp", 500);
                        World.RenderingCamera = CustomCamStart;
                        CustomCamStart.InterpTo(CustomCamEnd, (int)((CustomCamStart.Position.DistanceTo(CustomCamEnd.Position) /10f) * 1000), true, true);
                        Interp++;
                        break;
                    }
                case 1:
                    {
                        Function.Call(Hash.SET_GAMEPLAY_CAM_RELATIVE_HEADING, 0f);

                        if (!CustomCamEnd.IsInterpolating)
                        {
                            World.RenderingCamera = null;
                            UI.ShowSubtitle("End Interp", 500);
                            Interp = -1;
                        }
                        break;
                    }
                case 2:
                    {
                        break;
                    }
 
            }




            //Vehicle pCar = Game.Player.Character.CurrentVehicle;
            /*
            if (CanWeUse(FreecCamRide))
            {
                if (FreecCamRide.IsAttached() && FreecCamRide.HeightAboveGround>2f) IdealTimeScale = 0.5f; else IdealTimeScale = 1f;
            }*/
            if (Path.Count > 0||record)
            {

                Function.Call(Hash.SET_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME, 0.0f);
                Function.Call(Hash.SET_RANDOM_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME, 0.0f);
                Function.Call(Hash.SET_PARKED_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
              if(Racers.Count()>1)  Function.Call(Hash._0x90B6DA738A9A25DA, 0f);

                Function.Call(Hash.SET_PED_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
                Function.Call(Hash.SET_SCENARIO_PED_DENSITY_MULTIPLIER_THIS_FRAME, 0.0f);

            }

            if (playerdebuggametime < Game.GameTime)
            {
                playerdebuggametime = Game.GameTime + 100;
                HandlePlayerDebugStuff();
            }
            
            if (Path.Count == 0 || Racers.Count == 0) RaceStatus = RaceState.NotInitiated;
            if (Game.Player.Character.Velocity.Length() > 1f&&1==2)
            {
                if (flarefx == -1)
                {
                    if (Function.Call<bool>(Hash.HAS_NAMED_PTFX_ASSET_LOADED, "scr_oddjobtraffickingair"))
                    {
                        Function.Call(Hash._SET_PTFX_ASSET_NEXT_CALL, "scr_oddjobtraffickingair");

                        flarefx = Function.Call<int>(Hash.START_PARTICLE_FX_LOOPED_ON_ENTITY, "scr_crate_drop_flare", Game.Player.Character, 0f, 0f, 0f, 0f, 0f, 0f, 1f, true, true, true);
                        Function.Call(Hash.SET_PARTICLE_FX_LOOPED_COLOUR, flarefx,0.1f, 0.1f, 255f, true); //scr_lowrider scr_lowrider_flare

                        UI.ShowSubtitle("started", 1000);
                    }
                    else
                    {
                        UI.ShowSubtitle("requested", 1000);

                        Function.Call(Hash.REQUEST_NAMED_PTFX_ASSET, "scr_oddjobtraffickingair");
                    }
                }

            }
            else
            {
                if (flarefx != -1)
                {
                    Function.Call(Hash.STOP_PARTICLE_FX_LOOPED, flarefx);
                    flarefx = -1;
                    UI.ShowSubtitle("Stopped", 1000);

                }


            }



            if (OptionsList.Count == 0)
            {
                if (Game.IsControlPressed(2, GTA.Control.Sprint) && Game.IsControlPressed(2, GTA.Control.Context))
                {
                    if (record)
                    {
                        OptionsList.Add(Options.CleanEverything);
                        OptionsList.Add(Options.Save);

                    }
                    else
                    {
                        if (Path.Count == 0)
                        {
                            OptionsList.Add(Options.LoadTrack);

                        }
                        else
                        {
                            if (RaceStatus == RaceState.NotInitiated)
                            {
                                OptionsList.Add(Options.Start);
                            }
                            else
                            {
                                OptionsList.Add(Options.VisualDebug);

                                OptionsList.Add(Options.Brakepower);
                                OptionsList.Add(Options.Restart);

                              //  OptionsList.Add(Options.CleanEverything);
                                OptionsList.Add(Options.ClearRacers);


                            }
                        }
                    }

   
                    OptionsList.Add(Options.Freecam);

                }
            }
            else
            {
                
                if (Game.IsControlJustPressed(2, GTA.Control.FrontendCancel))
                {
                    OptionsList.Clear();

                }
                else
                {
                    HandleMenu();
                    if (Game.IsControlJustPressed(2, GTA.Control.FrontendAccept)) OptionsList.Clear();
                }



            }



            if (Game.Player.Character.IsOnFoot && Game.IsControlJustPressed(2, GTA.Control.Attack) && Racers.Count > 0 && 1 == 2)
            {
                List<Racer> ddd = Racers.OrderBy(vs => vs.Car.Position.DistanceTo(World.RenderingCamera.Position)).ToList();

                Game.Player.Character.SetIntoVehicle(ddd[0].Car, VehicleSeat.Passenger);
            }

            if(!floatingtext.IsLoaded) floatingtext = new Scaleform("HUD_FLOATING_HELP_TEXT");

       
            floatingtext.CallFunction("SET_HELP_TEXT","lol", 1);
            floatingtext.CallFunction("SET_BACKGROUND_SIZE");
           // floatingtext.CallFunction("FADE_IN");

            floatingtext.Render3D(Game.Player.Character.Position, GameplayCamera.Rotation, new Vector3(1,1,1));

            if (Path.Count > 0 && TrackLimits.Count>0)
            {

                if (CountDown < 5)
                {
                    Prop p = TrackLimits[0] ;
                    Vector3 pbase = p.Position + (p.UpVector * (p.Model.GetDimensions().Z-1f) + (p.ForwardVector * ((p.Model.GetDimensions().Y*0.5f) +0.2f)));
                    Vector3 leftmost = Vector3.Zero;
                    Vector3 left = Vector3.Zero;
                    Vector3 right = Vector3.Zero;
                    Vector3 rightmost= Vector3.Zero;
                    Color c = Color.Red;
                switch (CountDown)
                {
                    default:
                        {
                            c = Color.Red;
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);

                                rightmost = pbase + (p.RightVector * -0.45f);
                                break;
                            }
                        case 5:
                            {
                                break;
                            }
                        case 4:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);
                                break;
                            }
                        case 3:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);
                                break;
                            }
                        case 2:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);
                                break;
                            }
                        case 1:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);

                                rightmost = pbase + (p.RightVector * -0.45f);
                                break;
                            }
                        case 0:
                        {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);

                                rightmost = pbase + (p.RightVector * -0.45f);
                                leftmost.Z -= 0.3f;
                                left.Z -= 0.3f;
                                right.Z -= 0.3f;
                                rightmost.Z -= 0.3f;
                                c = Color.Green;
                            break;
                        }
                }

                    if (leftmost != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, leftmost, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(leftmost, c, 0.4f, 1f);
                    }


                    if (left != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, left, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(left, c, 0.4f, 1f);
                    }
                    if (right != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, right, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(right, c, 0.4f, 1f);
                    }
                    if (rightmost != Vector3.Zero)
                    {                    
                        World.DrawMarker(MarkerType.DebugSphere, rightmost, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(rightmost, c, 0.4f, 1f);
                    }
                }

            }
            if (RaceStatus != RaceState.Countdown && GametimeCountDown-Game.GameTime>5000) CountDown = 5;

            if (CountDown < MaxCountDown)
            {

                           //          Countdown.CallFunction("SHOW_SHARD_CENTERED_MP_MESSAGE", "Countdown", "", (int)12, (int)2);

                if(CountDown>3)
                {
                    if (1 == 2)
                    {
                        float z = 0;
                        float scale = 0.5f;

                        float height = scale * 0.06f;
                        float width = 0f;
                        Vector2 point = new Vector2(0.5f, 0.45f);


                        DrawText(point, Game.Player.Name + " presents", Color.LightGray, DrawTextFont.Default, DrawTextAlign.Center, scale);
                        z = scale * 0.06f;
                        point.Y += z;

                        scale = 1f;
                        string name = World.GetStreetName(Path[0]) + " TRACK";
                        string news = "";
                        foreach (char s in name) news += s + " ";
                        DrawText(point, news, Color.LightGray, DrawTextFont.Default, DrawTextAlign.Center, scale);
                        z = scale * 0.06f;
                        point.Y += z;

                        scale = 1.6f;
                        DrawBlackBars(0.25f);
                    }

                }
                else 
                {
                 //   DrawText(new Vector2(0.5f, 0.15f), CountDown.ToString(), Color.White, DrawTextFont.Default, DrawTextAlign.Center, 1.5f);


                }
            }
            if (GametimeCountDown < Game.GameTime)
            {
                GametimeCountDown = Game.GameTime + 1000;
                //for (int i=16; i<24; i++)  Function.Call(Hash.TOGGLE_VEHICLE_MOD, Game.Player.Character.CurrentVehicle, i, false);
                if (RaceStatus == RaceState.Countdown)
                {
                   // UI.ShowSubtitle("~b~"+CountDown, 2000);
                    foreach (Racer r in Racers) r.BaseBehavior = RacerBaseBehavior.GridWait;
                    CountDown--;
                    if (CountDown <= 3)
                    {

                        Game.PlaySound("3_2_1", "HUD_MINI_GAME_SOUNDSET");
                        Countdown.CallFunction("SHOW_SHARD_CENTERED_TOP_MP_MESSAGE", CountDown, "", (int)12, (int)2);
                        if (CountDown == 0)
                        {
                            Function.Call(Hash.TRIGGER_MUSIC_EVENT, MusicEventConflict);
                            Function.Call(Hash.PREPARE_MUSIC_EVENT, MusicEventSecured);

                            Countdown.CallFunction("TRANSITION_OUT", 0.6f);
                        }
                    }

                    //PlaySoundFrontend(-1, "3_2_1", "HUD_MINI_GAME_SOUNDSET", 1);

                    if (CountDown <= 0)
                    {
                        foreach (Racer r in Racers)
                        {
                            r.BaseBehavior = RacerBaseBehavior.Race;
                            r.StartTime = Game.GameTime;
                            //  r.Ghosted = true;
                            r.CurrentHandBrake = false;
                            if (r.Ghosted)
                            {
                                foreach (Racer sr in Racers)
                                {
                                  if (sr.Car != r.Car)
                                    {
                                        Function.Call(GTA.Native.Hash.SET_ENTITY_NO_COLLISION_ENTITY, r.Car, sr.Car, 0);
                                        
                                    }


                                }
                            }
     


                            //  r.Car.Heading += 180f;
                        }

                        CountDown = MaxCountDown;
                        RaceStatus = RaceState.RaceInProgress;
                    }
                }
            }
            
 


            if (GameTimeLoadConfig < Game.GameTime)
            {
                GameTimeLoadConfig = Game.GameTime + 5000;
                float old_max_angle = max_angle;
                float old_max_speed = max_speed;

                float old_speed_to_input = SpeedToInput;

                float old_min_speed = min_speed;
                LoadSettings();
                if (max_angle != old_max_angle || old_max_speed != max_speed  || old_speed_to_input != SpeedToInput || old_min_speed != min_speed)
                {
                    UI.Notify("Got new values from ini");
                }
            }



            IsShiftOn = false;
            if (Game.IsControlPressed(2, GTA.Control.Sprint))
            {
                IsShiftOn = true;
            }




            HandleTrackCreator();








            if (DebugLevel > 3 || record)
            {

                DrawPath(Path, WideDict, PathDisplayFidelity);



            }



            if (record || Racers.Count > 0 || Path.Count > 0)
            {
                Game.DisableControlThisFrame(2, GTA.Control.SelectNextWeapon);
                Game.DisableControlThisFrame(2, GTA.Control.SelectPrevWeapon);
                Game.DisableControlThisFrame(2, GTA.Control.VehicleNextRadio);
                Game.DisableControlThisFrame(2, GTA.Control.VehiclePrevRadio);
                Game.DisableControlThisFrame(2, GTA.Control.VehicleSelectNextWeapon);
                Game.DisableControlThisFrame(2, GTA.Control.VehicleSelectPrevWeapon);

            }

            
          

            if (!record)
            {                
                if (Path.Count > 0)
                {
                    if (Game.IsControlPressed(2, GTA.Control.Context))
                    {
        
                        if (Game.IsControlJustPressed(2, GTA.Control.PrevWeapon))
                        {
                            DebugLevel++;
                            DisplayHelpTextTimed("Debug Visual Level: ~g~" + DebugLevel.ToString(), 1000);
                        }
                        if (Game.IsControlJustPressed(2, GTA.Control.NextWeapon))
                        {
                            DebugLevel--;
                            if (DebugLevel < 0) DebugLevel = 0;
                            DisplayHelpTextTimed("Debug Visual Level: ~g~" + DebugLevel.ToString(), 1000);
                        }
                    }      
                }              
            }




            

            Cheats();

            /*
            if (WasCheatStringJustEntered("wide"))
            {

                int id = GetClosestNodeInfo(v, Path, 0, -1)[0];
                int wide = int.Parse(Game.GetUserInput(20));
                if (WideDict.ContainsKey(id))
                {
                    WideDict[id] = wide;
                    //UI.Notify("Node #" + id + " wideness changed to " + wide + "m~n~(Will be extended to future nodes without wideness set)");

                }
                else
                {
                    WideDict.Add(id, wide);
                    //UI.Notify("Node #" + id + " wideness changed to " + wide + "m~n~(Will be extended to future nodes without wideness set)");

                }
            }*/

            if (DebugLevel > 0)
            {

                if (Path.Count > 0)
                {
                    if (1 == 1)
                    {
                        if (record)
                        {
                           // UI.ShowSubtitle("~b~Cheats: ~w~~n~Shift+(Mouse Wheel): Adjust current section wide~n~(Mouse wheel) adjust current section lenght~n~record - Finish recording");
                        }
                        else  // if(DebugLevel>0)
                        {
                            if (Racers.Count > 0)
                            {
                                if (IsShiftOn)
                                {
                               //     UI.ShowSubtitle("~b~Cheats:~n~ ~w~race - stop the race~n~Next/Prev weapon to edit the Grip Confidence Multiplier");
                                }
                                else
                                {
                                //    UI.ShowSubtitle("~b~Cheats:~n~ ~w~race - stop the race~n~Next/Prev weapon to edit the Visual Debug Level");
                                }

                            }
                            else
                            {
                             //   UI.ShowSubtitle("~b~Cheats: ~w~~n~race - Get nearby cars and make them race the route~n~clean - clear the current route");
                            }
                        }
                    }

                }
                else
                {
                   // UI.ShowSubtitle("~b~Cheats: ~w~~n~load - load the default path~n~record - record your own path");

                }

            }
            foreach (Racer racer in Racers)
            {
              //  if (GameTimeRef < Game.GameTime) racer.ProcessAI();
                racer.ProcessTick();



                if ((racer.FinishedPointToPoint || racer.Lap > MaxLaps) && !LeaderboardFinish.Contains(racer))
                {
                    LeaderboardFinish.Add(racer);
                    racer.BaseBehavior = RacerBaseBehavior.FinishedRace;
                    if (IsPointToPoint) racer.BaseBehavior = RacerBaseBehavior.FinishedStandStill;

                }
            }



            if (GameTimeRef < Game.GameTime)
            {
                GameTimeRef = Game.GameTime + 500;

                List<Racer> LapPos = new List<Racer>();
                List<Racer> RPositions = Racers;
                if (Racers.Count > 0)
                {
                    RPositions = RPositions.OrderBy(d => d.Lap).Reverse().ToList();
                    int L = RPositions[0].Lap;

                    int pos = 1;

                    while (pos < Racers.Count - 1)
                    {
                        LapPos = RPositions.Where(vl => vl.Lap == L).ToList();
                        LapPos = LapPos.OrderBy(vl => vl.CurrentNode).Reverse().ToList();

                        foreach (Racer r in LapPos)
                        {
                            r.Pos = pos;
                            pos++;
                        }
                        L--;

                    }
                }
                Racers = Racers.OrderBy(vl => vl.Pos).ToList();

            }
            
            //string positions = "";
            List<string> positions = new List<string>();
            if (LeaderboardFinish.Count > 0)
            {
                foreach (Racer r in LeaderboardFinish)
                {

                    int totaltime = 0;
                    int count = 0;

                    if (r.LapTimes.Count > 0)
                    {
                        foreach (int i in r.LapTimes)
                        {
                            int time = 0;
                            if (count == 0) time = i - r.StartTime; else time = i - r.LapTimes[count-1];
                            totaltime += time;
                            count++;
                        }
                    }
                    else
                    {
                        if (r.StartTime != 0)
                        {
                            totaltime = Game.GameTime - r.StartTime;
                        }
                    }
                    TimeSpan ttt = new TimeSpan();
                    ttt = TimeSpan.FromMilliseconds(totaltime);
                    string fTime = ttt.ToString("m':'ss'.'f"); //"mm':'ss'.'fff"
                    if (r.Driver.IsPlayer) positions.Add ("~g~" + r.Pos + "º~w~ " + r.Name + " T" + fTime + "~n~");
                    else positions.Add( "~y~" + r.Pos + "º~w~ " + r.Name + " T" + fTime + "~n~");
                }
            }
            else
            {
                if(Game.IsControlPressed(2, GTA.Control.Sprint))
                {
                    foreach (Racer r in Racers)
                    {

                        int totaltime = 0;
                        int count = 0;

                        if (r.LapTimes.Count > 0)
                        {
                            totaltime = Game.GameTime -r.LapTimes.Last();
                            /*
                            foreach (int i in r.LapTimes)
                            {
                                int time = 0;
                                if (count == 0) time = i - r.StartTime; else time = i - r.LapTimes[count - 1];
                                totaltime += time;
                                count++;
                            }*/
                        }
                        else
                        {
                            if (r.StartTime != 0)
                            {
                                totaltime = Game.GameTime - r.StartTime;
                            }
                        }
                        TimeSpan ttt = new TimeSpan();
                        ttt = TimeSpan.FromMilliseconds(totaltime);
                        string fTime = ttt.ToString("m':'ss'.'f"); //"mm':'ss'.'fff"
                        if (r.Driver.IsPlayer) positions.Add( "~g~" + r.Pos + "º~g~ " + r.Name + " T" + fTime + "~n~");
                        else positions.Add("~b~" + r.Pos + "º~w~ " + r.Name + " T" + fTime + "~n~");
                    }
                }
                else
                {
                    foreach (Racer r in Racers)
                    {

                        if (r.Driver.IsPlayer) positions.Add("~g~" + r.Pos + "º~g~ " + r.Name + " ~w~L" + r.Lap + "~n~~w~");
                        else positions.Add("~b~" + r.Pos + "º~w~ " + r.Name + "~n~~w~");

                    }
                }



            }


            //Leaderboard positions
         if(positions.Count>0)

            {
                float z = 0;
                float scale = 0.3f;

                float height = scale * 0.06f;
                float width = 0f;
                Vector2 point= new Vector2 (0.016f, 0.008f);                
                foreach (string st in positions)
                {
                    float w = DrawText(point + new Vector2(0f, z), "~u~"+st, Color.White, DrawTextFont.Default, DrawTextAlign.Left, scale);
                    if (w > width) width = w;

                    //Function.Call(Hash.DRAW_RECT, 0.016f + (width * 0.15f), 0.016f + 0.008f +z, (width * 0.5f)- 0.008f, (scale * 0.06f) + 0.008, 0f, 0f, 0f, 255f, 0f);
                    z += scale * 0.06f;
                }
                Function.Call(Hash.DRAW_RECT, point.X + (width * 0.25f)-0.016f, point.Y + (point.Y * 0.5f) +(z*0.5f), ((width)*0.5f), z + 0.008f, 0f, 0f, 0f, 100, 0f);
            }
            if (WasCheatStringJustEntered("restart"))
            {
                if (Racers.Count > 0)
                {
                    SetupRace(true, false);
                }
            }
            if (WasCheatStringJustEntered("race"))
            {
                StartStopRace();
            }

            if (GametimerefLong < Game.GameTime)
            {
                GametimerefLong = Game.GameTime + 5000;
            }

            

            if (WasCheatStringJustEntered("save"))
            {
                foreach (Vector3 p in Path)
                {
                    //File.AppendAllText(@"scripts\\NRS.txt", "\n new Vector3(" + Math.Round(p.X,2) + " ," + Math.Round(p.Y,2) + "," + Math.Round(p.Z,2) + "),");
                    //UI.Notify("Route saved to NRS.txt.");
                }
                //UI.Notify("Name");

                SaveRoute(Game.GetUserInput(30));

            }
            if (WasCheatStringJustEntered("load"))
            {
                LoadTrack();

            }
            World.DrawMarker(MarkerType.DebugSphere, target, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.3f, 0.3f, 0.3f), Color.Orange);

        }
        void HandleTrackCreator()
        {

            //Visuals
            int Cool = -1; //If cool, the track is closed, no need to render more

            if (Path.Count > 50)
            {
                if (temp.Count > 0)
                {
                    Vector3 last = temp[temp.Count - 1];

                    if (Path[Path.Count - 1].DistanceTo(Path[0]) < 20f)
                    {
                        if (Path[0].DistanceTo(Path[Path.Count - 1]) < 2f)
                        {
                            Cool = 1;
                            DrawLine(Path[Path.Count - 1], Path[0], Color.Green);
                        }
                        else
                        {
                            Cool = 0;
                            DrawLine(Path[Path.Count - 1], Path[0], Color.Red);

                        }
                    }
                    if (Cool<1 && last.DistanceTo(Path[0]) < 20f)
                    {
                        if (last.DistanceTo(Path[0]) > 2f)
                        {
                            DrawLine(last + new Vector3(0, 0, 0.2f), Path[0], Color.Red);
                        }
                        else
                        {
                            DrawLine(last + new Vector3(0, 0, 0.2f), Path[0], Color.Green);
                        }
                    }


                }
            }
            if (Cool <1) DrawPath(temp, EditWideDict, PathDisplayFidelity);


            //Creating the track
            if (record && World.RenderingCamera == FreeCam)
            {
                if (wide < 1) wide = 1;
                if (scale < 5f) scale = 5f;
                RaycastResult ray = World.Raycast(World.RenderingCamera.Position, World.RenderingCamera.Position + ((World.RenderingCamera.Direction.Normalized) * 100), IntersectOptions.Everything);

                //Already started
                if (Path.Count > 0)
                {

                    if (Cool==-1) DisplayHelpTextThisFrame("Create the rest of the route. Make sure it loops around to the ~y~Start Line.");

                    if (Cool == 0) DisplayHelpTextThisFrame("Close the circuit near the ~y~Start Line.");

                    if (Cool == 1) DisplayHelpTextThisFrame("~g~The circuit is closed.");


                    //Controls

                    
                    if (Game.IsControlJustPressed(2, GTA.Control.NextWeapon))
                    {
                        if (!Game.IsControlPressed(2, GTA.Control.Sprint)) scale -= 5f; else wide--;
                    }
                    if (Game.IsControlJustPressed(2, GTA.Control.PrevWeapon))
                    {
                        if (!Game.IsControlPressed(2, GTA.Control.Sprint)) scale += 5f; else wide++;
                    }
                    if (Game.IsControlJustPressed(2, GTA.Control.Aim))
                    {
                        if (Path.Count > 2) Path.RemoveAt(Path.Count - 1);
                        else
                        {
                            Path.Clear();
                            return;
                        }
                    }

                    //Add section
                    if (Game.IsControlJustPressed(2, GTA.Control.Attack)&&Cool<1)
                    {
                        for (int i = 1; i < temp.Count - 1; i++)
                        {
                            Path.Add(temp[i]);
                        }
                    }
                }
                else //Placing the Start Line
                {
                    DisplayHelpTextThisFrame("Place the ~y~Start Line.");

                    if (Game.IsControlJustPressed(2, GTA.Control.NextWeapon)) wide--;
                    if (Game.IsControlJustPressed(2, GTA.Control.PrevWeapon)) wide++;

                }



                //Section rendering
                if (Path.Count > 1)
                {
                    if (ray.DitHitAnything&& Cool<1)
                    {

                        Vector3 projected = Vector3.Lerp(Path[Path.Count - 2], Path[Path.Count - 1], scale);

                        //Reference marker
                        World.DrawMarker(MarkerType.DebugSphere, ray.HitCoords, Vector3.Zero, -Vector3.WorldDown, new Vector3(0.1f, 0.1f, 0.1f), Color.Blue);

                        float projectedD = projected.DistanceTo(Path[Path.Count - 1]);


                        Vector3 front = (Path[Path.Count - 2] - Path[Path.Count - 1]).Normalized * (projectedD); //( v.Position -Path[Path.Count-1] ).Normalized

                        Vector3 pfront = ((ray.HitCoords) - projected).Normalized * (projectedD);

                        Vector3 control = new Vector3(0f, 0f, 0f);



                        int divided = 100;// (int)(pfront.DistanceTo(front));

                        //      World.DrawMarker(MarkerType.DebugSphere, projected + Bezier2(front, control, pfront, (float)0), Vector3.Zero, -Vector3.WorldDown, new Vector3(0.4f, 0.4f, 0.4f), Color.Black);
                        //    World.DrawMarker(MarkerType.DebugSphere, projected + Bezier2(front, control, pfront, (float)1), Vector3.Zero, -Vector3.WorldDown, new Vector3(0.4f, 0.4f, 0.4f), Color.White);
                        float ddc = 0f;

                        Vector3 oldp = Path[Path.Count - 1];


                        temp.Clear();

                        //First section node
                        //    temp.Add(projected + Bezier2(front, control, pfront, 0));

                        Vector3 oldDir = (Path[Path.Count - 1] - Path[Path.Count - 2]).Normalized;
                        for (int i = 0; i < divided; i++)
                        {
                            if (1 == 1)
                            {
                                float offset = 0;

                                Vector3 b = projected + Bezier2(front, control, pfront, ((float)i + offset) / divided);
                                Vector3 bd = projected + Bezier2(front, control, pfront, ((float)i) / divided);
                                int tries = 0;


                                while (b.DistanceTo(bd) < 0.95f)
                                {
                                    tries++;
                                    if (tries > 1000) break;
                                    offset += 0.05f;

                                    b = projected + Bezier2(front, control, pfront, (((float)i) / divided));
                                    bd = projected + Bezier2(front, control, pfront, ((float)i + offset) / divided);
                                }
                                while (b.DistanceTo(bd) > 1.05f)
                                {
                                    tries++;
                                    if (tries > 1000) break;
                                    offset -= 0.05f;

                                    b = projected + Bezier2(front, control, pfront, (((float)i) / divided));
                                    bd = projected + Bezier2(front, control, pfront, ((float)i + offset) / divided);
                                }

                                float ang = (float)Math.Round(Vector3.SignedAngle(oldDir, (bd - b).Normalized, Vector3.WorldUp), 1);
                                string pref = "~g~";
                                Color col = Color.Green;
                                if (Math.Abs(ang) > 1f)
                                {
                                    col = Color.Yellow;
                                    pref = "~y~";
                                }
                                if (Math.Abs(ang) > 2f)
                                {
                                    col = Color.Orange;
                                    pref = "~o~";
                                }
                                if (Math.Abs(ang) > 4f)
                                {
                                    col = Color.Red;
                                    pref = "~r~";
                                }

                                if (Math.Abs(ang) > 7f)
                                {
                                    col = Color.Black;
                                    pref = "~r~";
                                }
                                string text = pref + ang + "º";// "~w~" + Math.Round((b).DistanceTo(bd), 1).ToString() + "m~n~"+
                                oldDir = (bd - b).Normalized;

                                b += new Vector3(0, 0, 2f);

                                RaycastResult DSAD = World.Raycast(b, b + (Vector3.WorldDown * 30f), IntersectOptions.Map);
                                b.Z = DSAD.HitCoords.Z + 0.5f;

                                World.DrawMarker(MarkerType.DebugSphere, b, Vector3.Zero, -Vector3.WorldDown, new Vector3(0.2f, 0.2f, 0.2f), col);
                                if (oldp != Vector3.Zero) DrawLine(oldp, b, col);
                                ddc = b.DistanceTo(bd);
                                temp.Add(b);
                                oldp = b;
                                i = (int)(i + offset);
                                DrawText(b + Vector3.WorldUp, text, Color.Green, 0.3f); //" + offset
                            }
                        }

                        //Final section node
                        temp.Add(projected + Bezier2(front, control, pfront, 1));


                        EditWideDict.Clear();
                        for (int d = 0; d < temp.Count - 1; d++)
                        {
                            EditWideDict.Add(d, wide);
                        }             
                    }
                }
                else
                {
                    World.DrawMarker(MarkerType.ChevronUpx3, ray.HitCoords, FreecCamRide.ForwardVector, new Vector3(-90, 0, 0), new Vector3(1, 1, 1), Color.Blue);


                    Vector3 right = ray.HitCoords + (FreecCamRide.RightVector * wide);
                    Vector3 left = ray.HitCoords - (FreecCamRide.RightVector * wide);

                    World.DrawMarker(MarkerType.UpsideDownCone, right + new Vector3(0, 0, 1), FreecCamRide.ForwardVector, new Vector3(0, 0, 0), new Vector3(1, 1, 1), Color.Blue);
                    World.DrawMarker(MarkerType.UpsideDownCone, left + new Vector3(0, 0, 1), FreecCamRide.ForwardVector, new Vector3(0, 0, 0), new Vector3(1, 1, 1), Color.Blue);
                    DrawLine(left + new Vector3(0, 0, 0.05f), right + new Vector3(0, 0, 0.05f), Color.Blue);

                    if (Game.IsControlJustPressed(2, GTA.Control.Attack) && ray.DitHitAnything)
                    {
                        Vector3 p = ray.HitCoords + new Vector3(0, 0, 0.5f);
                        Path.Add(p);
                        p = ray.HitCoords - (FreecCamRide.ForwardVector * 1) + new Vector3(0, 0, 0.5f);

                        Path.Add(p);
                        rBezier = (ray.HitCoords - (FreecCamRide.ForwardVector * 6));

                    }
                }

                for (int i = 0; i < Path.Count - 1; i++)
                {
                    if (WideDict.Count - 1 < Path.Count - 1)
                    {
                        if (!WideDict.ContainsKey(i))
                        {
                            WideDict.Add(i, wide);
                     //       UI.Notify("Added wide:" + (Path.Count - 1).ToString() + " - " + wide.ToString());

                        }
                    }
                }

                while (WideDict.Count - 1 > Path.Count - 1)
                {
                    WideDict.Remove(WideDict.Count - 1);
                }

            }
        }

        void SetloadingPromptText(string t)
        {
            Function.Call(Hash._0xABA17D7CE615ADBF, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);
            Function.Call(Hash._0xBD12F8228410D9B4, 5);
        }
        void LoadTrack()
        {

            foreach (int fx in FlareFX) Function.Call(Hash.STOP_PARTICLE_FX_LOOPED, fx);

            if (record) record = false;

            foreach (string f in Directory.GetFiles(@"scripts\NewRacingSystem\Tracks"))
            {
              //  UI.Notify("~b~" + f.Substring(24));
            }

            string inp = Game.GetUserInput(30);

            Function.Call(Hash.DO_SCREEN_FADE_OUT, 200);
            SetloadingPromptText("Loading track...");

            Script.Wait(250);
            LoadRoute(inp);

            //DebugLevel = 0;
            if (Path.Count > 0)
            {
                IsPointToPoint = false;
                if (Path[0].DistanceTo(Path[Path.Count - 1]) > 20) IsPointToPoint = true;
                UI.Notify("Is point to point");
                //    Path.Reverse();
                //  Angles.Reverse();

                FreecCamRide.Position = Path[2] + new Vector3(0, 0, 10);
                if (!ScriptTest.CanWeUse(Game.Player.Character.CurrentVehicle)) Game.Player.Character.Position = Path[2]; else Game.Player.Character.CurrentVehicle.Position = Path[2];
                Script.Wait(1000);

                if (SpawnTracksideProps)
                {
                    SetloadingPromptText("Loading props...");
                    SpawnTrackLimits(Path, WideDict, 1);

                }
                UI.Notify("Done. Spawn your cars, open the menu and select Start.");
            }
            else UI.Notify("~o~" + inp + "~w~ not found.");

            /*
            CustomCamStart.Position = Path[(int)Math.Round( Path.Count * 0.5f)] +new Vector3(0,0,5);
            CustomCamStart.Direction = ( Path[1] - Path[0]).Normalized;
            
            World.RenderingCamera = CustomCamStart;
            CustomCamStart.IsActive = true;

            Script.Wait(50);
            */
            Function.Call(Hash._0x10D373323E5B9C0D);
            Function.Call(Hash.DO_SCREEN_FADE_IN, 500);

            Function.Call(Hash.RENDER_SCRIPT_CAMS, false, true, 3000, 1, 0, 0);
        }


        public void HandleFreecam()
        {


 

            /*
            Function.Call(Hash.SET_CAM_DOF_STRENGTH, World.RenderingCamera, 15f);
            Function.Call(Hash.SET_CAM_NEAR_CLIP, World.RenderingCamera, 0.01f);
            Function.Call(Hash.SET_CAM_FAR_CLIP, World.RenderingCamera, 5f);
            Function.Call(Hash.SET_CAM_NEAR_DOF, World.RenderingCamera, 5f);
            Function.Call(Hash.SET_CAM_FAR_DOF, World.RenderingCamera, 4f);
            */
            if (FreeCam == null || !FreeCam.Exists())
            {
                FreeCam = World.CreateCamera(Vector3.Zero, Vector3.Zero, GameplayCamera.FieldOfView);
                Script.Wait(500);
                if (FreeCam == null || !FreeCam.Exists())
                {
                    UI.ShowSubtitle("Unable to create the FreeCam camera.",1000);
                    return;
                }
            }


            if (!CanWeUse(FreecCamRide))
            {
                FreecCamRide = World.CreateProp("ba_prop_battle_drone_quad_static", Game.Player.Character.Position + new Vector3(0, 0, 10), true, false);//prop_wheel_tyre

                Script.Wait(500);
                if (!CanWeUse(FreecCamRide))
                {
                    UI.ShowSubtitle("Unable to create the FreeCam object.",1000);
                    return;
                }

                FreecCamRide.MaxSpeed = 900f;
                //prop_wheel_tyre
                FreecCamRide.HasGravity = false;
                  FreecCamRide.IsVisible = true;
                FreecCamRide.HasCollision = true;
           //    FreeCam.AttachTo(FreecCamRide, new Vector3(0, 0f, 0f));
                return;
            }
            if (!FreeCam.IsActive && FreeCam.Position.DistanceTo(Game.Player.Character.Position)> 100f) FreeCam.Position = Game.Player.Character.Position + new Vector3(0, 0, 50);
            if (World.RenderingCamera == FreeCam)
            {

    foreach(int node in PreJumpNodes)
                {
                  if(node % 2==0)  World.DrawMarker(MarkerType.UpsideDownCone, Path[node] + new Vector3(0, 0, 1), FreecCamRide.ForwardVector, new Vector3(0, 0, 0), new Vector3(1, 1, 1), Color.Red);

                }

                Game.Player.Character.Position = FreeCam.Position + new Vector3(0, 0, 2);
                Game.Player.Character.Heading = FreeCam.Direction.ToHeading();

                Function.Call(Hash.SET_GAMEPLAY_CAM_RELATIVE_HEADING, 0f);

                foreach (Prop p in CustomProps)
                {
                    World.DrawMarker(MarkerType.ChevronUpx1, p.Position + new Vector3(0, 0, p.Model.GetDimensions().Z), Vector3.Zero, Vector3.Zero, new Vector3(1f, 1f, -1f), Color.LightSkyBlue);
                }
                Function.Call(Hash.HIDE_HUD_AND_RADAR_THIS_FRAME, true);

                // DisplayHelpTextThisFrame(FreecCamRide.Rotation.ToString());

                /*
                if (Math.Abs(FreecCamRide.Rotation.Y) > 1)
                {
                    FreecCamRide.Rotation = new Vector3(FreecCamRide.Rotation.X, 0f, FreecCamRide.Rotation.Z);
                //    FreecCamRide.Velocity = Vector3.Zero;
                }
                if (Game.IsControlJustPressed(2, GTA.Control.Jump))
                {
                    if (FreecCamRide.IsAttached()) FreecCamRide.Detach();
                    else
                    {
                        if (Racers.Count > 0)
                        {
                            Racer r = Racers.OrderBy(vs => vs.Car.Position.DistanceTo(FreecCamRide.Position)).ToList()[0];
                            FreecCamRide.AttachTo(r.Car, 0, new Vector3(0, -8f, (r.Car.Model.GetDimensions().Z + 1.5f)), Vector3.Zero); //0.5f, new Vector3(0, -0.5f, (Racers[0].Car.Model.GetDimensions().Z * 0.5f) - 0.1f)

                        }
                    }
                }
                */

                if (Game.IsControlJustPressed(2, GTA.Control.Attack))
                {
                    RaycastResult ray = World.Raycast(FreeCam.Position + new Vector3(0, 0, -1f), FreeCam.Position + ((FreeCam.Direction.Normalized) * 100), IntersectOptions.Everything);
                    //FreeCamFollow = ray.HitEntity;
                    Entity hit = ray.HitEntity;
                    
                    if (!CanWeUse(hit) && ray.HitCoords != Vector3.Zero)
                    {
                        hit = World.GetAllProps().OrderBy(dis => dis.Position.DistanceTo(ray.HitCoords)).ToList()[0];
                        if (!hit.IsInRangeOf(ray.HitCoords, 20f)) hit = null;
                    }

                    if (CanWeUse(hit) && !TrackLimits.Contains(hit)&& hit != FreecCamRide)
                    {
                        if (hit.IsPersistent && !hit.Model.IsPed && !hit.Model.IsVehicle)
                        {
                            if (CustomProps.Contains(hit))
                            {
                                UI.Notify("Removed " + hit.Handle.ToString());

                                CustomProps.Remove(hit as Prop);
                            }
                            else
                            {
                                UI.Notify("Added " + hit.Handle.ToString());
                                CustomProps.Add(hit as Prop);
                            }
                        }
                    }
                }


                if (CanWeUse(FreeCamFollow) && 1 == 2)
                {
                    Vector3 fPos = FreeCamFollow.Position + (FreeCamFollow.Velocity * 0.5f) + new Vector3(0, 0, 10);
                    if (fPos.DistanceTo(FreeCam.Position) > 10f)
                    {
                        //FreeCamMovement += (fPos - FreeCam.Position) * 0.001f;
                    }

                    float angle = Vector3.SignedAngle(-FreeCam.Direction, -FreeCamFollow.Velocity.Normalized, Vector3.WorldUp);


                    if (Game.IsControlJustPressed(2, GTA.Control.Sprint)) FreeCamFollow = null;
                    if (Game.IsControlPressed(2, GTA.Control.FrontendCancel)) ToggleFreeCam();
                }



                //Instructional buttons
                if (1==1)
                {
                    if (scaleform == null || !scaleform.IsLoaded) scaleform = new Scaleform("INSTRUCTIONAL_BUTTONS");

                    scaleform.CallFunction("CLEAR_ALL", true);

                    scaleform.CallFunction("CREATE_CONTAINER");
                 
                    if (1 == 1)
                    {
                        if (record)
                        {
                            if (Path.Count() > 0)
                            {

                                if (IsShiftOn)
                                {
                                    scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelPrev), "Widen");
                                    scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelNext), "Tighten");
                                }
                                else
                                {

                                    scaleform.CallFunction("SET_DATA_SLOT", 4, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Attack), "Apply Section");
                                    scaleform.CallFunction("SET_DATA_SLOT", 3, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Aim), "Delete last");
                                    scaleform.CallFunction("SET_DATA_SLOT", 2, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelPrev), "Enlong");
                                    scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelNext), "Shorten");
                                    scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Sprint), "More options");

                                }
                            }
                            else
                            {
                                scaleform.CallFunction("SET_DATA_SLOT", 2, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Attack), "Place Start Line");
                                scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelPrev), "Widen");
                                scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelNext), "Tighten");
                            }

                        }
                        else
                        {

                            if (IsDroneMode) scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.NextCamera), "Freecam Mode");
                            else scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.NextCamera), "Drone Mode");
                            scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Jump), "Slow Mo");

                        }
                    }
                    scaleform.CallFunction("DRAW_INSTRUCTIONAL_BUTTONS", -1);

    scaleform.Render2D();

                }



                Function.Call(Hash.DISABLE_ALL_CONTROL_ACTIONS, 0);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.LookLeftRight);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.LookUpDown);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.CursorX);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.CursorY);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.FrontendPauseAlternate);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.WeaponWheelPrev);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.WeaponWheelNext);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.EnterCheatCode);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.Jump);


                //Controls
                if (Game.IsControlJustPressed(2, GTA.Control.Jump))
                {

                    if (TimeScale > 0.9f)
                    {
                        TimeScale = 0.2f;
                        IdealTimeScale = 0.2f;
                        Game.TimeScale = 0.2f;
                        Function.Call(Hash._START_SCREEN_EFFECT, "FocusOut", 500, false);
                    }
                    else
                    {
                        IdealTimeScale = 1.0f;
                        Game.TimeScale = TimeScale;
                    }
                }

                FreeCam.Position += FreeCamMovement;


                FreecCamRide.Position = FreeCam.Position + (FreeCamMovement * 1f) + new Vector3(0, 0, -0.2f); // -(FreeCam.Direction*0.4f);
                FreecCamRide.Rotation = new Vector3(0f, 0f, FreeCam.Rotation.Z+180f);

                bool Reduce = true;
                float mouseX = Function.Call<float>(Hash.GET_CONTROL_NORMAL, 0, (int)GTA.Control.LookLeftRight);
                float mouseY = Function.Call<float>(Hash.GET_CONTROL_NORMAL, 0, (int)GTA.Control.LookUpDown);
                FreeCam.Rotation = FreeCam.Rotation + new Vector3(mouseY * -5, 0, mouseX * -5);


                float spd = 0.02f;
                float heightd =FreecCamRide.HeightAboveGround ;

                string dir = "" + Math.Round(CamIntendedHeight - heightd, 1);
                if (CamIntendedHeight-heightd <=-1f) dir = "v " + Math.Round(CamIntendedHeight - heightd, 0);
                if (CamIntendedHeight - heightd >= 1f) dir = "^ " + Math.Round(CamIntendedHeight - heightd, 0);
               if (!IsDroneMode) DisplayHelpText("~g~Freecam Mode"); else DisplayHelpText("~b~Drone Mode ~n~Height diff "+ dir);


                if (FreeCamMovement.Length()<7f)
                {


                    if (!IsDroneMode) spd = 0.05f;
                    if (Game.IsControlJustPressed(2, GTA.Control.NextCamera)) IsDroneMode = !IsDroneMode;

                    if (Game.IsControlPressed(2, GTA.Control.WeaponWheelPrev)) CamIntendedHeight++;
                    if (Game.IsControlPressed(2, GTA.Control.WeaponWheelNext)) CamIntendedHeight--;

                    if (Game.IsControlPressed(2, GTA.Control.VehicleAccelerate))
                    {
                        Reduce = false;
                        
                        if (!IsDroneMode) FreeCamMovement += FreeCam.Direction * spd; else FreeCamMovement -= FreecCamRide.ForwardVector * spd;
                        //if (heightd != -1f) FreeCamMovement -= FreecCamRide.ForwardVector * spd;   else FreeCamMovement += FreeCam.Direction * spd;
                    }
                    if (Game.IsControlPressed(2, GTA.Control.VehicleBrake))
                    {
                        Reduce = false;
                    //    FreeCamMovement += FreecCamRide.ForwardVector * spd;

                
                        if (!IsDroneMode) FreeCamMovement  -= FreeCam.Direction * spd; else FreeCamMovement += FreecCamRide.ForwardVector * spd;
                     
                    }
                    if (Game.IsControlPressed(2, GTA.Control.MoveLeftOnly))
                    {
                        Reduce = false;
                        FreeCamMovement += FreecCamRide.RightVector * spd;
                    }
                    if (Game.IsControlPressed(2, GTA.Control.MoveRightOnly))
                    {
                        Reduce = false;
                        FreeCamMovement += FreecCamRide.RightVector * -spd;
                    }
                    if (IsDroneMode)
                    {
                        if (CamIntendedHeight < 2f) CamIntendedHeight = 2f;

                        if (heightd > CamIntendedHeight + 1f)
                        {
                            if (FreeCamMovement.Z > -0.3f) FreeCamMovement -= new Vector3(0, 0, 0.01f);
                        }
                        else if (heightd < CamIntendedHeight - 1f)
                        {
                            if (FreeCamMovement.Z < 0.5f) FreeCamMovement += new Vector3(0, 0, 0.04f);
                        }
                        else FreeCamMovement.Z *= 0.9f;

                    }
                   // else if (Reduce) FreeCamMovement.Z *= 1 - (spd * 2f);

                }
                if (Reduce)
                {
                    if (IsDroneMode)
                    {
                        
                        if (Reduce)
                        {

                            if (FreeCamMovement.Length() > 0.2f)
                            {
                                FreeCamMovement.X *= 1 - (spd * 0.5f); // *= new Vector3(1f, 1f, 1f);
                                FreeCamMovement.Y *= 1 - (spd * 0.5f);
                                if (Math.Abs(heightd) < 1f) FreeCamMovement.Z *= 1 - (spd * 2f);

                            }
                            else
                            {
                                FreeCamMovement.X *= 1 - (spd * 2f); // *= new Vector3(1f, 1f, 1f);
                                FreeCamMovement.Y *= 1 - (spd * 2f);
                                if (Math.Abs(heightd) < 1f) FreeCamMovement.Z *= 1 - (spd * 2f);

                            }
                        }
                    }
                    else
                    {
                        if (Reduce)
                        {
                            FreeCamMovement.X *= 1 - (spd * 2f); // *= new Vector3(1f, 1f, 1f);
                            FreeCamMovement.Y *= 1 - (spd * 2f);
                            FreeCamMovement.Z *= 1 - (spd * 2f);
                        }

                    }
                }

                //1-(spd*2f);new Vector3(1f, 1f, 1f);

                if (1==2 && CanWeUse(FreecCamRide) && FreeCam.Exists()) //Function.Call<string>(Hash.GET_ONSCREEN_KEYBOARD_RESULT) != "NULL"
                {


                    Vector3 rotvel = Function.Call<Vector3>(Hash.GET_ENTITY_ROTATION_VELOCITY, FreecCamRide);
                    Vector3 vel = Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, FreecCamRide, true);

                    if (!Game.IsControlPressed(2, GTA.Control.Jump)) FreecCamRide.ApplyForceRelative(new Vector3(vel.X > 0 ? -0.5f : 0.5f, vel.Y > 0 ? -0.5f : 0.5f, vel.Z > 0 ? -0.5f : 0.5f), Vector3.Zero, ForceType.MaxForceRot2);

                    float force = 5;
                    if (Game.IsControlPressed(2, GTA.Control.Sprint)) force = 40;

                    if (Game.IsControlPressed(2, GTA.Control.VehicleAccelerate)) FreecCamRide.ApplyForceRelative(new Vector3(0f, force, 0f), Vector3.Zero, ForceType.MaxForceRot2);
                    if (Game.IsControlPressed(2, GTA.Control.VehicleBrake)) FreecCamRide.ApplyForceRelative(new Vector3(0f, -force, 0f), Vector3.Zero, ForceType.MaxForceRot2);
                    if (Game.IsControlPressed(2, GTA.Control.MoveLeftOnly)) FreecCamRide.ApplyForceRelative(new Vector3(-force, 0f, 0f), Vector3.Zero, ForceType.MaxForceRot2);
                    if (Game.IsControlPressed(2, GTA.Control.MoveRightOnly)) FreecCamRide.ApplyForceRelative(new Vector3(force, 0f, 0f), Vector3.Zero, ForceType.MaxForceRot2);

                    if (FreecCamRide.IsAttached())
                    {
                        FreeCam.Rotation = FreecCamRide.Rotation;
                    }
                    else
                    {


                        FreeCam.Rotation = FreeCam.Rotation + new Vector3(mouseY * -5, 0, mouseX * -5);

                        if ((FreeCam.Rotation - FreecCamRide.Rotation).Length() > 3f)
                        {
                            FreecCamRide.Rotation = FreeCam.Rotation;

                        }

                    }

                    if (FreeCam.Rotation.X < -90) FreeCam.Rotation = FreeCam.Rotation + new Vector3(1, 0, 0);
                    if (FreeCam.Rotation.X > 90) FreeCam.Rotation = FreeCam.Rotation + new Vector3(-1, 0, 0);
                }
            }
            else //Freecam is not rendering
            {
                FreeCamMovement = Vector3.Zero;
            }


        }

        
        public void StartStopRace()
        {

            if (Path.Count > 0)
            {
                if (Racers.Count > 0)
                {
                    foreach (Racer r in Racers)
                    {
                        r.Delete();
                    }
                    Racers.Clear();
                    LeaderboardFinish.Clear();
                    UI.Notify("Racers removed.");
                    RaceStatus = RaceState.NotInitiated;
                    Function.Call(Hash.TRIGGER_MUSIC_EVENT, MusicEventSecured);

                    //Function.Call(Hash.CANCEL_MUSIC_EVENT, MusicEventTranquil);
                }
                else
                {
                   UI.Notify("Looking for nearby empty vehicles (30m)");
                    /*
                    int p = 0;
                    foreach (Vehicle veh in World.GetNearbyVehicles(Game.Player.Character, 30))
                    {
                        if (veh.IsSeatFree(VehicleSeat.Driver))
                        {
                            p++;
                            veh.IsPersistent = true;
                            Ped racer = World.CreatePed(RacerModels[GetRandomInt(0, RacerModels.Count - 1)], veh.Position + new Vector3(0, 0, 2f), veh.Heading);
                            racer.SetIntoVehicle(veh, VehicleSeat.Driver);
                            Racer r = new Racer(veh, racer);
                            r.SteerControlTime = Game.GameTime + (p*2);
                            r.SpeedControlTimer = Game.GameTime + (p * 2);
                            Racers.Add(r);


                        }
                    }
                    */


                    LoadGrid(Game.GetUserInput(32).ToLowerInvariant(), 200);
                    /*
                    List<dynamic> info = new List<dynamic>();
                    info= LoadVehicle(Game.GetUserInput(32) ,Path[0]);

                    Ped racer = World.CreatePed(RacerModels[GetRandomInt(0, RacerModels.Count - 1)], info[0].Position + new Vector3(0, 0, 2f), info[0].Heading);
                    racer.SetIntoVehicle(info[0], VehicleSeat.Driver);
                    Racers.Add(new Racer(info[0], racer));


                    info = LoadVehicle(Game.GetUserInput(32), Path[0]);
                    racer = World.CreatePed(RacerModels[GetRandomInt(0, RacerModels.Count - 1)], info[0].Position + new Vector3(0, 0, 2f), info[0].Heading);
                    racer.SetIntoVehicle(info[0], VehicleSeat.Driver);
                    Racers.Add(new Racer(info[0], racer));
                    */

                    
                    Vehicle cv = Game.Player.Character.CurrentVehicle;
                    if (CanWeUse(cv)) Racers.Add(new Racer(cv, Game.Player.Character));
                    if (Racers.Count == 0)
                    {
                        UI.Notify("~r~No vehicles found.");

                        return;
                    }
                    Function.Call(Hash.PREPARE_MUSIC_EVENT, MusicEventTranquil);

                    SetupRace(true, true);
                    Function.Call(Hash.TRIGGER_MUSIC_EVENT, MusicEventTranquil);
                    Function.Call(Hash.PREPARE_MUSIC_EVENT, MusicEventConflict);

                    if (CustomCamStart != null)
                    {
                        Function.Call(Hash.SET_GAMEPLAY_CAM_RELATIVE_HEADING, 0f);
                        CustomCamStart.Position = new Vector3(Path[10].X, Path[10].Y, GameplayCamera.Position.Z);
                        //CustomCamStart.Position.Z += ;
                        CustomCamEnd.Position = GameplayCamera.Position;
                        CustomCamEnd.Direction = GameplayCamera.Direction;
                        CustomCamStart.Direction = (Path[1] - Path[0]).Normalized;
                        Interp = -1; //Camera pan
                    }

                    //Game.SetControlNormal(2, GTA.Control.VehicleLookBehind, 255f);
                }
            }
            else
            {
                UI.Notify("~r~Load or create a path route first.");
            }
        }
        void LoadRacers()
        {
            //read disciplines wanted

            //Load all car files that have that discipline

            //Scramble, Limit to the grid max

            //Spawn, assign driver, create new racer with both
        }

        float CamIntendedHeight = 4f;
        public void SetupRace(bool placecars, bool tunecars)
        {
            LeaderboardFinish.Clear();
            float maxacc = 0f;

            /*
            foreach (Racer r in Racers)

            {
                r.Initialize();
                if (maxacc < Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car)) maxacc = Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car);

            }
            */
            /*
            foreach (Racer r in Racers)
            {
                float mul = 10f;
                while (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car) < maxacc)
                {
                    mul += 10;
                    r.Car.EnginePowerMultiplier = mul;
                    Script.Wait(0);
                }
            }
            */
            if (placecars)
            {
                Vector3 start = Path[Path.Count - 2];//Path.Count - 2
                if(IsPointToPoint) start = Path[0];
                float back = 3f;
                float left = 3f;
                foreach (Racer r in Racers)
                {
                    r.Car.Heading = (Path[1] - Path[0]).Normalized.ToHeading();

         
                    if (back == 0f)
                    {
                        r.Car.Position = start + (r.Car.ForwardVector * -back) + (r.Car.RightVector * left);
                    }
                    else
                    {
                        r.Car.Position = start + (r.Car.ForwardVector * -back) + (r.Car.RightVector * left);
                    }

                    if (Racers.Count == 2)
                    {

                    }
                    else
                    {
                        back += r.Car.Model.GetDimensions().Y * 1f;

                    }
                    left = -left;
                    //  ScriptTest.Wait(500);
                    /*
                     string name = Function.Call<string>(Hash._GET_LABEL_TEXT, r.Car.GetModName(VehicleMod.Livery, r.Car.GetMod(VehicleMod.Livery)));
                     if(name=="NULL") name= Function.Call<string>(Hash._GET_LABEL_TEXT, Function.Call<string>(Hash.GET_LIVERY_NAME , r.Car, r.Car.GetMod(VehicleMod.Livery)));
                     if (name == "NULL") name = Function.Call<string>(Hash._GET_LABEL_TEXT, Function.Call<string>(Hash.GET_LIVERY_NAME, r.Car, r.Car.Livery));
                     r.Name ="["+name +"]~n~"+r.Car.FriendlyName;
                     */
                   
                   UI.Notify(r.Car.FriendlyName+" Acc: "+ Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car).ToString());

                }
            }

            foreach (Racer r in Racers)
            {

            }
            if (tunecars)
            {
                foreach (Racer r in Racers)
                {
                    if (!Game.Player.Character.IsInVehicle(r.Car) && r.Car.GetMod(VehicleMod.Engine) == -1) 
                    {
                        switch (TuningLevel)
                        {
                            case 0: continue;
                            case 1: ScriptTest.RandomTuning(r.Car, true, true, true, false, false); break;
                            case 2: ScriptTest.RandomTuning(r.Car, true, true, true, true, false); break;
                            case 3: ScriptTest.RandomTuning(r.Car, true, true, true, true, false); r.Car.EnginePowerMultiplier = GetRandomInt(1, 5) * 10; break;
                        }
                    }
                }
            }
            RaceStatus = RaceState.Countdown;
            GametimeCountDown = Game.GameTime;
            CountDown = MaxCountDown;

            
        }
        
        public static int GetSurfaceHash(Vector3 start, Vector3 end)
        {
            Vector3 pos = start;// v.Position + (v.UpVector * 2f);
            Vector3 endpos = end;// v.Position + (v.UpVector * -5f);

            int shape = Function.Call<int>(Hash._0x28579D1B8F8AAC80, pos.X, pos.Y, pos.Z, endpos.X, endpos.Y, endpos.Z, 0.3f,(int) IntersectOptions.Map, Game.Player.Character, 7);

            OutputArgument didhit = new OutputArgument();
            OutputArgument hitpos = new OutputArgument();
            OutputArgument snormal = new OutputArgument();
            OutputArgument materialhash = new OutputArgument();

            OutputArgument entity = new OutputArgument();

            Function.Call(Hash._0x65287525D951F6BE, shape, didhit, hitpos, snormal, materialhash, entity);


            return materialhash.GetResult<int>();
        }
        List<int> FlareFX = new List<int>();
       static public bool IsPointToPoint=false;
        public void SpawnTrackLimits(List<Vector3> nodes, Dictionary<int, float> widedict, int fidelity)
        {

            string ModelOne = "prop_wheel_tyre"; //xm_prop_base_fence_01//prop_offroad_tyres01
            string ModelTwo = "prop_mp_cone_03";// "prop_offroad_tyres02"; //prop_ind_light_03c
            //if (nodes.Count < 5) return;
            Vector3 oldpos = Vector3.Zero;
            int dd = 0;
            Vector3 pos = Vector3.Zero;
            Vector3 rCol = nodes.OrderBy(v => v.DistanceTo(Game.Player.Character.Position)).Reverse().ToList()[0];
            Function.Call(Hash.REQUEST_COLLISION_AT_COORD, rCol.X, rCol.Y, rCol.Z);
            Prop gate = World.CreateProp("prop_start_gate_01b", nodes[0],new Vector3(0,0, (nodes[1] - nodes[0]).Normalized.ToHeading()), true, true); //prop_tri_start_banner
            gate.Position += new Vector3(0f, 0f, -0.5f);
            gate.FreezePosition = true;
            gate.HasCollision = false;
            TrackLimits.Add(gate);

            if (IsPointToPoint)
            {
                gate = World.CreateProp("prop_start_gate_01b", nodes[nodes.Count - 1], new Vector3(0, 0, (nodes[nodes.Count-1] - nodes[nodes.Count - 2]).Normalized.ToHeading()), true, true); //prop_tri_start_banner

                if (!CanWeUse(gate))
                {
                    for (int i = 0; i < 5; i++)
                    {
                        Script.Wait(200*i);
                        gate = World.CreateProp("prop_start_gate_01b", nodes[nodes.Count - 1], new Vector3(0, 0, (nodes[nodes.Count - 1] - nodes[nodes.Count - 2]).Normalized.ToHeading()), true, true); //prop_tri_start_banner

                    }
                }
                if (CanWeUse(gate))
                {
                    gate.Position += new Vector3(0f, 0f, -0.5f);
                    gate.FreezePosition = true;
                    gate.HasCollision = false;
                    TrackLimits.Add(gate);
                }

            }

            int frecuency = 6;

            if (CurrentFile != null)
            {
                XmlNode f = CurrentFile.SelectSingleNode("Data/Route/Trackside/Frecuency");
          if(f!=null)      int.TryParse(f.InnerText, out frecuency);

                f = CurrentFile.SelectSingleNode("Data/Route/Trackside/Model");
                if (f != null) ModelOne = f.InnerText;
            }
            else UI.Notify("current file is null");
            int barriers = 0;
            int lights = 0;
            int terrain = 0;
            List<int> Terrains = new List<int>();

            // RaycastResult terrainRaycast = World.Raycast(Path[0], Path[0] + new Vector3(0, 0, -5), IntersectOptions.Map);

            //int _GET_SHAPE_TEST_RESULT_EX(int rayHandle, bool* hit, Vector3* endCoords, Vector3* surfaceNormal, Hash* materialHash, Entity* entityHit) // 0x65287525D951F6BE 0x4301E10C b323
            int hash = GetSurfaceHash(Path[0], Path[0] + new Vector3(0, 0, -5));
            if (hash > 0) Terrains.Add(hash);
            for (int ph = 0; ph < nodes.Count; ph++)
            {

                int percent = (  100* ph) / (nodes.Count - 1);
                SetloadingPromptText("Loading Objects - " +percent+"%");
                //DisplayHelpTextTimed(ph + "/" +( nodes.Count-1)+" nodes loaded", 1000);
                pos = nodes[ph];
                float w = 0f;
                float oldw = 0f;
                if (widedict.ContainsKey(dd)) w = widedict[dd];
                if (widedict.ContainsKey(dd - 1)) oldw = widedict[dd - 1]; else oldw = w;
                if (oldpos != Vector3.Zero)
                {
                    lights++;
                    barriers++;
                    terrain++;

                    Vector3 oldrWidepos = oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * oldw);
                        Vector3 oldlWidepos = oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * oldw);

                        Vector3 rWidepos = Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * w);
                        Vector3 lWidepos = Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * w);
                    //Function.Call(Hash.REQUEST_COLLISION_AT_COORD, pos.X, pos.Y, pos.Z);
                    if(TrackLimits.Count>0)
                    {
                        Function.Call(GTA.Native.Hash.SET_FOCUS_ENTITY, TrackLimits.Last());

                    }


                    if (terrain >= 10)
                    {
                        terrain = 0;

                         hash = GetSurfaceHash(Path[ph], Path[ph] + new Vector3(0, 0, -5));
                        if (hash > 0) Terrains.Add(hash);
                    }
                    if (lights == DistanceBetweenFlares && ((Model)ModelTwo).IsValid && DistanceBetweenFlares>0)
                    {
                        lights = 0;


                        Prop light = null;

                        for (int i = 0; i < 5; i++)
                        {
                            if (!CanWeUse(light))
                            {
                                light = World.CreateProp(ModelTwo, oldlWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading()), true, false);//
                                light.Position += new Vector3(0, 0, 2f);

                                if (i > 2) Script.Wait(10);
                            }
                            else
                            {
                                int patience = Game.GameTime;
                                while (!Function.Call<bool>(Hash.HAS_COLLISION_LOADED_AROUND_ENTITY, light)&& Game.GameTime - patience<1000)
                                {
                                    patience--;
                                    Script.Wait(1);
                                    UI.ShowSubtitle("Waiting for col ("+( Game.GameTime - patience )+ ")", 1000);
                                }
                                light.Position += new Vector3(0, 0, -light.HeightAboveGround);

                                light.FreezePosition = true;
                                light.HasCollision = false;
                                TrackLimits.Add(light);
                                Function.Call(Hash.SET_ENTITY_COLLISION, light, false, false);

                                break;
                            }
                        }

                        Prop slight = null;

                        for (int i = 0; i < 5; i++)
                        {
                            if (!CanWeUse(slight))
                            {
                                slight = World.CreateProp(ModelTwo, oldrWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading()), true, false);
                                slight.Position += new Vector3(0, 0, 2f);
                                if (i > 2) Script.Wait(10);
                            }
                            else
                            {
                                int patience = 500;
                                while (!Function.Call<bool>(Hash.HAS_COLLISION_LOADED_AROUND_ENTITY, slight) && patience > 0)
                                {
                                    patience--;
                                    Script.Wait(1);
                                    UI.ShowSubtitle("Waiting for col (" + patience + ")ms", 1000);
                                }
                                slight.Position += new Vector3(0, 0, -slight.HeightAboveGround);

                                slight.FreezePosition = true;
                                slight.HasCollision = false;
                                TrackLimits.Add(slight);
                                Function.Call(Hash.SET_ENTITY_COLLISION, slight, false, false);
             
                                break;
                            }
                        }


                        if (FlareFX.Count < 1000)
                        {

                            int d = 0;
                            while (!Function.Call<bool>(Hash.HAS_NAMED_PTFX_ASSET_LOADED, "scr_apartment_mp") && d < 2000) //scr_oddjobtraffickingair
                            {
                                Function.Call(Hash.REQUEST_NAMED_PTFX_ASSET, "scr_apartment_mp");
                                d++;
                                Script.Wait(0);
                            }

                            if (Function.Call<bool>(Hash.HAS_NAMED_PTFX_ASSET_LOADED, "scr_apartment_mp"))
                            {
                                Function.Call(Hash._SET_PTFX_ASSET_NEXT_CALL, "scr_apartment_mp");
                                if (CanWeUse(slight))
                                {
                                    int fx = Function.Call<int>(Hash.START_PARTICLE_FX_LOOPED_ON_ENTITY, "scr_finders_package_flare", slight, 0f, 0f, light.Model.GetDimensions().Z * 1f, 0f, 0f, 0f, 2f, true, true, true);
                                    Function.Call(Hash.SET_PARTICLE_FX_LOOPED_ALPHA, fx, 0.5f);
                                    Function.Call(Hash.SET_PARTICLE_FX_LOOPED_COLOUR, fx, 0.2f, 0.2f, 1f, true); //scr_lowrider scr_lowrider_flare

                                    // Function.Call(Hash.SET_PARTICLE_FX_LOOPED_COLOUR, fx, 1f, 0.5f, 0f, true); //scr_lowrider scr_lowrider_flare //scr_crate_drop_flare
                                    FlareFX.Add(fx);

                                }
                                if (CanWeUse(light))
                                {

                                    //Script.Wait(100);
                                    Function.Call(Hash._SET_PTFX_ASSET_NEXT_CALL, "scr_apartment_mp");

                                    int nfx = Function.Call<int>(Hash.START_PARTICLE_FX_LOOPED_ON_ENTITY, "scr_finders_package_flare", light, 0f, 0f, light.Model.GetDimensions().Z * 1f, 0f, 0f, 0f, 2f, true, true, true);
                                    Function.Call(Hash.SET_PARTICLE_FX_LOOPED_ALPHA, nfx, 0.5f);
                                    Function.Call(Hash.SET_PARTICLE_FX_LOOPED_COLOUR, nfx, 0.2f, 0.2f, 1f, true); //scr_lowrider scr_lowrider_flare
                                                                                                                    //scr_lowrider scr_lowrider_flare

                                    FlareFX.Add(nfx);
                                }


                                //    light.IsVisible = false;
                                //  slight.IsVisible = false;
                         //       UI.ShowSubtitle("Applied " + FlareFX.Count, 3000);
                            }
                        }
                        Script.Wait(0);
                    }

                    if (barriers == frecuency && ((Model)ModelOne).IsValid)
                    {
                        barriers = 0;
                        Prop cone = null;
                        for (int i = 0; i < 5; i++)
                        {
                            if (!CanWeUse(cone))
                            {
                                cone = World.CreateProp(ModelOne, pos - lWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading() + 90f), true, false); //prop_mp_cone_03
                                cone.Position += new Vector3(0, 0, 2f);
                                if (i > 2) Script.Wait(10);
                                //       Script.Wait(10);
                            }
                            else
                            {
                                int patience = 500;
                                while (!Function.Call<bool>(Hash.HAS_COLLISION_LOADED_AROUND_ENTITY, cone) && patience > 0)
                                {
                                    patience--;
                                    Script.Wait(1);
                                    UI.ShowSubtitle("Waiting for col (" + patience + ")ms", 1000);
                                }
                                cone.Position += new Vector3(0, 0, -cone.HeightAboveGround);
                                cone.FreezePosition = true;
                                cone.HasCollision = false;
                                Function.Call(Hash.SET_ENTITY_COLLISION, cone, false, false);

                                TrackLimits.Add(cone);
                                break;
                            }
                        }

               //         if (!CanWeUse(cone)) UI.Notify("~r~Left Barrier failed to spawn");
                        cone = null;// World.CreateProp("xm_prop_base_fence_01", pos - rWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading() + 90f), true, true);
                        for (int i = 0; i < 5; i++)
                        {
                            if (!CanWeUse(cone))
                            {
                                cone = World.CreateProp(ModelOne, pos - rWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading() + 90f), true, false);
                                cone.Position += new Vector3(0, 0, 2f);
                                if(i>2)       Script.Wait(10);
                            }
                            else
                            {
                                int patience = 500;
                                while (!Function.Call<bool>(Hash.HAS_COLLISION_LOADED_AROUND_ENTITY, cone) && patience > 0)
                                {
                                    patience--;
                                    Script.Wait(1);
                                    UI.ShowSubtitle("Waiting for col (" + patience + ")ms", 1000);
                                }
                                cone.Position += new Vector3(0, 0, -cone.HeightAboveGround);

                                cone.FreezePosition = true;
                                cone.HasCollision = false;
                                Function.Call(Hash.SET_ENTITY_COLLISION, cone, false, false);

                                TrackLimits.Add(cone);



                                break;
                            }

                        }

                        //        if (!CanWeUse(cone)) UI.Notify("~r~Right Barrier failed to spawn");
                        Script.Wait(0);
                    }

                }

                oldpos = pos;
             
                dd++;
            }

            Function.Call(GTA.Native.Hash.CLEAR_FOCUS);

            foreach (int fx in FlareFX)
            {
               // Function.Call(Hash.SET_PARTICLE_FX_LOOPED_ALPHA, fx, 100f);
               // Script.Wait(100);
            }
            float length = (float)Math.Round(Path.Count() * 0.001f, 1);
            float miles = (float)Math.Round(length * 0.62123, 1);
            int road = 0;
            int dirtp = 0;
            int otherp = 0;

            foreach (int d in Terrains)
            {
                
                foreach(TerrainTypes type in Enum.GetValues(typeof(TerrainTypes)))
                {

                    if ((int)type ==d)
                    {

                        //      UI.Notify(type.ToString());
                        if (type.ToString().ToLowerInvariant().Contains("tarmac"))
                        {

                            road++;
                        }
                        else if (type.ToString().ToLowerInvariant().Contains("dirt") || type.ToString().ToLowerInvariant().Contains("grass") || type.ToString().ToLowerInvariant().Contains("gravel")) dirtp++;
                        else otherp++;

                    }
                }

            //    if (Road.Contains(d)) road++;
            }

            foreach (int d in Terrains)
            {
           //     if (Dirt.Contains(d)) dirtp++;
            }

            foreach (int d in Terrains)
            {
       //         if (Other.Contains(d)) otherp++;
            }
            DisplayHelpTextTimed("~g~Done: all nodes loaded.", 4000);
          int  total = dirtp + road + otherp;

            float PercentRoad =(float)Math.Round( (road * 100f )/ total, 2);
            float PercentDirt = (float)Math.Round((dirtp * 100f) / total, 2);
            float PercentOther = (float)Math.Round((otherp * 100f) / total, 2);
            UI.Notify("Track stats:~n~~b~Track Length: ~w~" + length + " Km ~n~(" + miles + " Miles).~n~Road: " + PercentRoad+ "%~n~Dirt: " + PercentDirt + "% ~n~Other: " + PercentOther +  "% ");
        }

        public  bool PlayerOrCameraNearPos(Vector3 pos, float dist)
        {
            if (World.RenderingCamera != FreeCam) return Game.Player.Character.Position.DistanceTo(pos)<dist;
            else return World.RenderingCamera.Position.DistanceTo(pos) < dist;

            
        }
        public void DrawPath(List<Vector3> nodes , Dictionary<int, float> widedict , int fidelity)
        {

            //if (nodes.Count < 5) return;
            Vector3 oldpos = Vector3.Zero;
            int countmax = 1;
            int count = 0;
            int dd = 0;
            Vector3 pos = Vector3.Zero;
            for (int ph = 0; ph < nodes.Count ; ph += fidelity)
            {
                count++;

                /*
                if (GameplayCamera.Position.DistanceTo(pos)>  50f && World.RenderingCamera.Position.DistanceTo(pos) > 50f)
                {
                    if (GameplayCamera.Position.DistanceTo(pos) > 100f && World.RenderingCamera.Position.DistanceTo(pos) > 100f) countmax = 20; else countmax = 10;
                }
                else countmax = 5;
                */
                //countmax = 20;
                if (count >= countmax)
                {
                    bool IsClose = false;
                    if (record)
                    {
                        if (PlayerOrCameraNearPos(pos, 50f))
                        {
                            countmax = 1;
                            
                        }
                        else countmax = 5;
                    }
                    else
                    {
                        if (PlayerOrCameraNearPos(pos, 50f))
                        {
                            countmax = 1;
                            IsClose = true;
                        }
                        else countmax = 10;
                    }
                    //if (GameplayCamera.Position.DistanceTo(pos) > 50f && World.RenderingCamera.Position.DistanceTo(pos) > 50f) countmax = 20; else countmax = 5;
                    //if (record) countmax = 1;

                    count = 0;

                    pos = nodes[ph];
                    float w = 0f;
                    float oldw = 0f;
                    if (widedict != null)
                    {
                        if (widedict.ContainsKey(dd)) w = widedict[dd];
                        if (widedict.ContainsKey(dd - 1)) oldw = widedict[dd - 1]; else oldw = w;
                    }
            
                    if (oldpos == Vector3.Zero) oldpos = nodes[nodes.Count - 1];


                    if (oldpos != Vector3.Zero)
                    {

                        if (1==1)//Game.Player.Character.IsInRangeOf(pos, 30000f)
                        {

                            Vector3 rWidepos = GetPerpendicular(pos, oldpos, w, true); //Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * w);
                            Vector3 lWidepos = GetPerpendicular(pos, oldpos, w, false); //Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * w);

                            Vector3 oldrWidepos = GetPerpendicular(pos, oldpos, oldw, true) - (pos - oldpos); // oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * oldw);
                            Vector3 oldlWidepos = GetPerpendicular(pos, oldpos, oldw, false) - (pos - oldpos);// oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * oldw);


                            //  DrawText(pos, pos.DistanceTo(oldpos).ToString(), Color.Black, 0.4f);

                            //Center


                            Color col = Color.Green;

                            if (Angles.ContainsKey(ph))

                            {

                                float ang = Angles[ph];
                                if (Math.Abs(ang) > 1f)
                                {
                                    col = Color.Yellow;
                                    //pref = "~y~";
                                }
                                if (Math.Abs(ang) > 2f)
                                {
                                    col = Color.Orange;
                                    //pref = "~o~";
                                }
                                if (Math.Abs(ang) > 4f)
                                {
                                    col = Color.Red;
                                   // pref = "~r~";
                                }

                                if (Math.Abs(ang) > 7f)
                                {
                                    col = Color.Black;
                                 //   pref = "~r~";
                                }
                             if(IsClose)   DrawText(pos+new Vector3(0,0,-0.2f),Math.Round(ang,1).ToString(), col, 0.3f);

                            }
                            //  World.DrawMarker(MarkerType.DebugSphere, pos, Vector3.Zero, -Vector3.WorldDown, new Vector3(0.2f, 0.2f, 0.2f), Color.Blue);

                            if (w != 0f)
                            {
                                if (Path.Count > 0 && Path[0] != nodes[0])
                                {
                                    //     DrawLine(oldpos, pos, Color.White);
                                    if (pos != nodes[0])
                                    {
                                        DrawLine(oldrWidepos, rWidepos, Color.White);
                                        DrawLine(oldlWidepos, lWidepos, Color.White);
                                    }
                                    else
                                    {

                                    }
                                }
                                else
                                {
                                    //       DrawLine(oldpos, pos, Color.Yellow);
                                    if (pos != nodes[0])
                                    {
                                        DrawLine(oldrWidepos, rWidepos, Color.Yellow);
                                        DrawLine(oldlWidepos, lWidepos, Color.Yellow);
                                    }
                                }
                            }
                               

                            

                        }
                    }
                }
        
                oldpos = pos;

                dd++;
            }
        }
        Vector3 GetPerpendicular(Vector3 a, Vector3 b, float length, bool clockwise)
        {
            Vector3 ab = (b - a).Normalized;
            Vector3 abCw = Vector3.Zero;
            if (clockwise)
            {
                abCw.X = -ab.Y;
                abCw.Y = ab.X;
            }
            else
            {
                abCw.X = ab.Y;
                abCw.Y = -ab.X;
            }
            return a + abCw * length;
        }
        public void Notify(string text, float timeMult)
        {

            GTA.Native.Function.Call(GTA.Native.Hash._SET_NOTIFICATION_TEXT_ENTRY, "STRING");
            GTA.Native.Function.Call(GTA.Native.Hash._ADD_TEXT_COMPONENT_STRING, text);
            //GTA.Native.Function.Call(GTA.Native.Hash._SET_NOTIFICATION_MESSAGE, "CHAR_DEFAULT", "CHAR_DEFAULT", true, 2, "~g~Leader", "~c~" + SquadName);
            GTA.Native.Function.Call(Hash._0x1E6611149DB3DB6B, "CHAR_DEFAULT", "CHAR_DEFAULT", false, 2, "", "", timeMult);

            //int _SET_NOTIFICATION_MESSAGE_CLAN_TAG(const char* picName1, const char* picName2, bool flash, int iconType, const char* sender, const char* subject, float duration, const char* clanTag)
        }

        void ToggleFreeCam()
        {

            /*

                           if (Game.IsControlJustPressed(2, GTA.Control.Jump))
            {

              //  Function.Call(Hash.SET_GAMEPLAY_ENTITY_HINT, FreecCamRide, 0.0f, 0.0f, 0.0f, true, 2000, 2000, 1500, 1844968929); //duration, in, out, flags
                if(World.RenderingCamera!=FreeCam)
                {
                    FreeCam.IsActive = true;

                    Function.Call(Hash.RENDER_SCRIPT_CAMS, true, true, 1000, 1, 0, 0);

                }
                else
                {
                    Function.Call(Hash.RENDER_SCRIPT_CAMS, false, true, 3000, 1, 0, 0);

                }

            }
            */
            if (World.RenderingCamera == FreeCam)
            {
                Game.Player.Character.Heading = FreecCamRide.Heading+180f;
                //    GTA.Native.Function.Call(GTA.Native.Hash.CLEAR_FOCUS);
                Function.Call(Hash.RENDER_SCRIPT_CAMS, false, true, 1000, 1, 0, 0);

                FreeCam.IsActive = false;
             //   Game.FadeScreenOut(0);
           //     Game.FadeScreenIn(500);
                Game.Player.Character.IsVisible = true;
                Game.Player.Character.Position = FreecCamRide.Position - new Vector3(0, 0, FreecCamRide.HeightAboveGround);
                Function.Call(Hash.SET_GAMEPLAY_CAM_RELATIVE_HEADING, 0f);
                Function.Call(Hash.SET_GAMEPLAY_CAM_RELATIVE_PITCH, 0f);

            }
            else
            {
                FreeCam.IsActive = true;

                World.RenderingCamera = FreeCam;
                //    GTA.Native.Function.Call(GTA.Native.Hash.SET_FOCUS_ENTITY, FreeCam);
                //   Game.Player.Character.AttachTo(FreeCam, 0, new Vector3(0, 0, -40), Vector3.Zero);
              //  Function.Call(Hash.RENDER_SCRIPT_CAMS, true, true, 500, 1, 0, 0);
               FreeCam.Position = GameplayCamera.Position;
              //  FreeCam.Rotation = GameplayCamera.Rotation;
                Game.Player.Character.IsVisible = false;
               Game.FadeScreenOut(0);
               Game.FadeScreenIn(500);
                //    FreeCamMovement = new Vector3(0, 0, 2);
                
            }

        }
        public void Cheats()
        {

            if (WasCheatStringJustEntered("lv")) LoadVehicle(Game.GetUserInput(32) , Game.Player.Character.Position.Around(5));
            if (WasCheatStringJustEntered("cd")) CreateDriver(Game.GetUserInput(32), Game.Player.Character);
            if (WasCheatStringJustEntered("cv")) CreateVehicle(Game.GetUserInput(32), Game.Player.Character.CurrentVehicle);

            if (WasCheatStringJustEntered("dof"))
            {
                float dof = float.Parse( Game.GetUserInput(5));



                Function.Call(Hash.SET_CAM_DOF_STRENGTH, FreeCam, dof);




            }
            if (WasCheatStringJustEntered("fdof"))
            {
                float dof = float.Parse(Game.GetUserInput(5));

                FreeCam.FarDepthOfField = dof;
            }
            if (WasCheatStringJustEntered("ndof"))
            {
                float dof = float.Parse(Game.GetUserInput(5));

                FreeCam.NearDepthOfField = dof;
            }
            if (WasCheatStringJustEntered("lens"))
            {
                float dof = float.Parse(Game.GetUserInput(5));

                Function.Call(Hash._0x7DD234D6F3914C5B, FreeCam, dof);
            }
            if (WasCheatStringJustEntered("freecam"))
            {
                ToggleFreeCam();
            }
            if (WasCheatStringJustEntered("debuglevel"))
            {
                //UI.Notify("Debug Level: ~b~" + DebugLevel.ToString());

                int lvl = 0;

                int.TryParse(Game.GetUserInput(20), out DebugLevel);

                //UI.Notify("New Level: ~b~" + DebugLevel.ToString());
            }

            if (WasCheatStringJustEntered("gripbonus"))
            {
                int number = (int)Confidence;
                int.TryParse(Game.GetUserInput("", 3), out number);
                Confidence = number;
                //UI.Notify("Global Speed bonus changed to ~b~x" + Confidence + "~w~.");
            }
            if (WasCheatStringJustEntered("brakedist"))
            {

                float number = BrakeDist;
                float.TryParse(Game.GetUserInput("", 3), out number);
                BrakeDist = (float)Math.Round((number / 100), 1);
                //UI.Notify("Global brake distance changed to ~b~x" + BrakeDist + "%~w~.");
            }


            if (WasCheatStringJustEntered("deviation")) MaxOffset = int.Parse(Game.GetUserInput(4));

            if (WasCheatStringJustEntered("clean"))
            {
                foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
                if (Racers.Count > 0)
                {
                    foreach (Racer r in Racers)
                    {
                        r.Delete();
                    }
                    Racers.Clear();
                }

                Path.Clear();
                WideDict.Clear();
                EditWideDict.Clear();

            }
            if (WasCheatStringJustEntered("record"))
            {
                record = !record;

                if (record)
                {
                   if(World.RenderingCamera!=FreeCam) ToggleFreeCam();
                    IsDroneMode = false;



                    //UI.Notify("Record enabled. You'll need a freecam script, enable it now.");
                }
                else
                {
                    //FreeCam.IsActive = false;
                    //World.RenderingCamera = null;
                    if (1 == 1)
                    {
                        int t = 0;
                        /*
                        while (Path[Path.Count - 1].DistanceTo(Path[0]) > 1f)
                        {
                            t++;
                            Vector3 d = LerpByDistance(Path[Path.Count - 1], Path[0], 1f);
                            Path.Add(d);
                        }

                        UI.Notify(t + " nodes were added automatically to close the circuit.");
                        */
                    }
                }
            }
        }
        public static bool IntHasFlag(int number, int flag)
        {

            if ((number & (int)flag) != 0) return true;
            return false;
        }



        public static void SaveRoute(string filename)
        {

            XmlDocument document = new XmlDocument();

            XmlElement element = document.CreateElement("Data");
            document.AppendChild(element);
            //element = document.CreateElement("Route");
            XmlElement route = document.CreateElement("Route");

            XmlElement objects = document.CreateElement("Objects");

            XmlElement p = null;
            XmlElement info = null;
            int i = 0;
            int W = 5;

            foreach (Vector3 v in Path)
            {
                p = document.CreateElement("Point");
                //document.SelectSingleNode("Data/Route").AppendChild(element);

                info = document.CreateElement("X");
                info.InnerText = Math.Round(v.X, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Y");
                info.InnerText = Math.Round(v.Y, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Z");
                info.InnerText = Math.Round(v.Z, 2).ToString();
                info.InnerText= info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Wide");
                if (WideDict.ContainsKey(i)) W = int.Parse(WideDict[i].ToString());
                info.InnerText = W.ToString();

                p.AppendChild(info);

                route.AppendChild(p);
                i++;
            }

            foreach(Prop prop in CustomProps)
            {
                p = document.CreateElement("Prop");
                info = document.CreateElement("Model");
                info.InnerText = prop.Model.Hash.ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("X");
                info.InnerText = Math.Round(prop.Position.X, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Y");
                info.InnerText = Math.Round(prop.Position.Y, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Z");
                info.InnerText = Math.Round(prop.Position.Z, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("RotX");
                info.InnerText = Math.Round(prop.Rotation.X, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("RotY");
                info.InnerText = Math.Round(prop.Rotation.Y, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("RotZ");
                info.InnerText = Math.Round(prop.Rotation.Z, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("IsDynamic");
                info.InnerText =( !prop.FreezePosition).ToString(); // (!Function.Call<bool>(Hash.IS_ENTITY_STATIC, prop)).ToString();


                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                objects.AppendChild(p);

              //  document.SelectSingleNode("Data").AppendChild(info);
            }
            document.SelectSingleNode("Data").AppendChild(route);
            document.SelectSingleNode("Data").AppendChild(objects);

            XmlElement trackside = document.CreateElement("Trackside");
            XmlElement t = document.CreateElement("Model");
            t.InnerText = "prop_wheel_tyre";
            trackside.AppendChild(t);

            t = document.CreateElement("Frecuency");
            t.InnerText = "6";
            trackside.AppendChild(t);
            element.AppendChild(trackside);

            //document.SelectSingleNode("//Route").AppendChild(trackside);
            //XmlNode f = CurrentFile.SelectSingleNode("Data/Route").AppendChild(trackside);
            
            document.Save(@"scripts\NewRacingSystem\Tracks\" + filename + ".xml");
        }

        
        public static bool NodeExists(XmlNode node,  string name)
        {
            return node.SelectSingleNode(name)!= null;
        }

        public static void LoadRoute(string filename)
        {
            PreJumpNodes.Clear();

            Vector3 cDir = Vector3.Zero;
            Vector3 fDir = Vector3.Zero;
            foreach (string f in Directory.GetFiles(@"scripts\NewRacingSystem\Tracks"))
            {
                if (f.Contains(filename))
                {
                    //XML
                    string ConfigFile = f;
                    XmlDocument document = new XmlDocument();
                    document.Load(ConfigFile);
                    int pat = 0;
                    Script.Wait(20);
                    while (document == null && pat < 5)
                    {
                        pat++;
                        document.Load(ConfigFile);
                        Script.Wait(20);
                    }
                    if (document == null)
                    {
                        return;
                    }
                    else
                    {
                        CurrentFile = document;
                        foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
                        foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
                        foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
                        Directions.Clear();
                        Angles.Clear();
                        Path.Clear();
                        WideDict.Clear();
                        XmlNode r = document.SelectSingleNode("Data");
                 
                        Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");

                        foreach (XmlElement prop in r.SelectNodes("Objects/Prop"))
                        {
                            string x ="0";
                            string y = "0";
                            string z = "0";
                            if (NodeExists(prop,"X" ) && NodeExists(prop,"Y" ) && NodeExists(prop, "Z") )
                            {
                                 x = prop.SelectSingleNode("X").InnerText;
                                 y = prop.SelectSingleNode("Y").InnerText;
                                 z = prop.SelectSingleNode("Z").InnerText;
                            }
                
                            bool isDynamic = false;

                           if(NodeExists(prop, "IsDynamic")) bool.TryParse(prop.SelectSingleNode("IsDynamic").InnerText, out isDynamic);

                            float fx = 0f;
                            float.TryParse(x, out fx);
                            float fy = 0f;
                            float.TryParse(y, out fy);
                            float fz = 0f;
                            float.TryParse(z, out fz);
                            Vector3 pos = new Vector3(fx, fy, fz);
                            if (NodeExists(prop, "RotX") && NodeExists(prop, "RotY") && NodeExists(prop, "RotZ"))
                            {
                                x = prop.SelectSingleNode("RotX").InnerText;
                                y = prop.SelectSingleNode("RotY").InnerText;
                                z = prop.SelectSingleNode("RotZ").InnerText;
                            }
                             fx = 0f;
                            float.TryParse(x, out fx);
                             fy = 0f;
                            float.TryParse(y, out fy);
                             fz = 0f;
                            float.TryParse(z, out fz);
                            Vector3 rot = new Vector3(fx, fy, fz);

                            if(NodeExists(prop, "Model"))
                            {
                                int hash = 0;
                                int.TryParse(prop.SelectSingleNode("Model").InnerText, out hash);
                                if (hash != 0)
                                {

                                    
                                    Prop myprop = World.CreateProp(hash, pos, rot, false, false);
                                    myprop.Position = pos;
                                    Function.Call(Hash.SET_ENTITY_DYNAMIC, myprop, isDynamic);
                                    Function.Call(Hash.FREEZE_ENTITY_POSITION, myprop, !isDynamic);
                                    Function.Call(Hash.SET_OBJECT_PHYSICS_PARAMS, myprop, 200f*myprop.Model.GetDimensions().Length(),1f);

                                    //   myprop.HasCollision = false;
                                    CustomProps.Add(myprop);


                                    if(hash==Game.GenerateHash("prop_mp_repair_01"))
                                    {
                                        myprop.Alpha = 50;

                            
                                        if (CanWeUse(Game.Player.Character.LastVehicle))
                                        {
                                            Game.Player.Character.LastVehicle.Position = myprop.Position+new Vector3(0,0,0);
                                            Game.Player.Character.LastVehicle.Heading = myprop.Heading;
                                            Game.Player.Character.LastVehicle.PlaceOnGround();
                                        }

                                        Prop autog = World.CreateProp("prop_gazebo_03", myprop.Position, myprop.Rotation, false, true);

                                        AutoGeneratedProps.Add(autog);

                                        Function.Call(Hash.FREEZE_ENTITY_POSITION, autog, true);
                                        Function.Call(Hash.SET_ENTITY_DYNAMIC, autog, false);

                                        autog = World.CreateProp("prop_table_04", myprop.Position -= (myprop.ForwardVector * 3), myprop.Rotation, false, true);
                                        AutoGeneratedProps.Add(autog);

                                        Function.Call(Hash.FREEZE_ENTITY_POSITION, autog, true);
                                        Function.Call(Hash.SET_ENTITY_DYNAMIC, autog, false);


                                        MiniMap = autog.Position + new Vector3(0, 0, (autog.Model.GetDimensions().Z / 2));

                                    }
                                }
                            }


                        }

                        int i = 0;
                        float W = 5;
                        foreach (XmlElement e in r.SelectNodes("Route/Point"))
                        {
                            

                            string x =  e.SelectSingleNode("X").InnerText;
                            string y = e.SelectSingleNode("Y").InnerText;
                            string z = e.SelectSingleNode("Z").InnerText;

                            float fx = 0f;
                            float.TryParse(x, out fx);
                            float fy = 0f;
                            float.TryParse(y, out fy);
                            float fz = 0f;
                            float.TryParse(z, out fz);
                            Vector3 pos = new Vector3(fx, fy, fz);//;, float.Parse(e.SelectSingleNode("Y").InnerText, NumberStyles.AllowDecimalPoint), float.Parse(e.SelectSingleNode("Z").InnerText, NumberStyles.AllowDecimalPoint));

                            // UI.Notify(pos.ToString());

                            float sensibleW = W;
                            float.TryParse(e.SelectSingleNode("Wide").InnerText, out W);

                            if (Math.Abs(sensibleW) > Math.Abs(W) + 1) W = sensibleW - 1;
                            if (Math.Abs(sensibleW) < Math.Abs(W) - 1) W = sensibleW + 1;
                            /*
                            if (sensibleW < 0)
                            {
                                if (sensibleW > W  1) W = W - 1;
                                else if (sensibleW > W + 1) W = W + 1;
                            }
                            else
                            {
                                if (sensibleW < W - 1) W = W - 1;
                                else if (sensibleW > W + 1) W = W + 1;
                            }*/


                            Path.Add(pos);
                            WideDict.Add(i, W);

                            i++;
                        }
            //            UI.Notify("Loaded route");
                        //


                     // Path.Reverse();
                        i = 0;
                        Vector3 olddir = Vector3.Zero;
                        foreach(Vector3 pos in Path)
                        {

                            if (i > 3)
                            {
                                cDir = (Path[i - 2] - Path[i - 1]).Normalized;
                                fDir = (Path[i - 1] - Path[i]).Normalized;

                                if (olddir != Vector3.Zero)
                                {
                             //       PreJumpNodes.Add(i);
                                    if (fDir.Z - cDir.Z > 0.175f) //
                                    {
                                        
                                        for (int p = i-25; p < i+5; p++)
                                        {
                                            if (p > 5) if(!PreJumpNodes.Contains(p)) PreJumpNodes.Add(p);
                                        }

                                    }
                                }
                                

                                olddir = cDir;

                                Directions.Add(i - 1, Path[i] - Path[i - 1]);
                                cDir.Z = 0f; //0.3
                                fDir.Z = 0f;

                                float angle = (float)Math.Round(Vector3.SignedAngle(cDir, fDir, Vector3.WorldUp), 2);
                                Angles.Add(i - 1, angle);
                            }

                            i++;
                        }
                        UI.Notify("Added " + PreJumpNodes.Count + " jump nodes");
                //        UI.Notify("Loaded angles");
                    }
                }
            }
        }
        static public unsafe ulong GetWheelsPtr(Vehicle handle)
        {
            
            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;

            if (wheelsptr == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x3B\xB7\x48\x0B\x00\x00\x7D\x0D", "xx????xx");

                if (addr != null)
                {
                    wheelsptr = *(uint*)(addr + 2) - 8;
                }
            }

            //  //UI.ShowSubtitle((*((ulong*)(address + offset))).ToString());
            return *((ulong*)(address + wheelsptr));
        }

        public static ulong wheelsptr = 0x0;
        public static ulong numwheelsoffset = 0x0;


        static public unsafe int GetNumWheels(Vehicle handle)
        {

            if (numwheelsoffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x3B\xB7\x48\x0B\x00\x00\x7D\x0D", "xx????xx");

                if (addr != null)
                {
                    numwheelsoffset = *(uint*)(addr + 2) ;
                }
            }
            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;
         //   ulong offset = 0xB60; // GetWheelsPtr(handle);// (ulong)(gameVersion >= GameVersion.VER_1_0_372_2_STEAM ? 0xAA0 : 0xA80);

           // offset += 8;


            // UI.ShowSubtitle((*((int*)(address + offset))).ToString());
            return *((int*)(address + numwheelsoffset));
        }

        static public unsafe List<ulong> GetWheelPtrs(Vehicle handle)
        {
            //if (wheelsptr == 0x0) GetWheelsPtr();
            var wheelPtr = GetWheelsPtr(handle);  // pointer to wheel pointers
            var numWheels = GetNumWheels(handle);
            List<ulong> wheelPtrs = new List<ulong>();
            for (int i = 0; i < numWheels; i++)
            {
                var wheelAddr = *((ulong*)(wheelPtr + 0x008 * (ulong)i));
                wheelPtrs.Add(wheelAddr);
            }
            return wheelPtrs;
        }


        static public unsafe List<float> GetWheelsGrip(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x198;


            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);

                angle.Add(pos);
            }
            return angle;
        }
        static public unsafe List<float> GetWheelsWetgrip(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x19C;


            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);

                angle.Add(pos);
            }
            return angle;
        }

        static public unsafe float GetWheelsMaxWheelspin(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x174;

            float w = 0f;
            //List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);
                if (Math.Abs(pos) > Math.Abs(w)) w = pos;
              //  angle.Add(pos);
            }
            return w;
        }

        static public unsafe List<float> GetWheelSkidmark(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x1B8;
            if (Game.Version <= GameVersion.VER_1_0_1290_1_STEAM) offset = 0x1B8;
            //ulong offRadius = 0x110; // offWheelSzX
            //ulong offRadius = 0x110; // offWheelSzX

            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = *((float*)(wheel + offset));

                angle.Add(pos);
            }
            return angle;
        }

        static public unsafe float GetGear(Vehicle handle)
        {
            var address = (ulong)handle.MemoryAddress;
            ulong offset = 0x888; // GetWheelsPtr(handle);// (ulong)(gameVersion >= GameVersion.VER_1_0_372_2_STEAM ? 0xAA0 : 0xA80);

            return *((int*)(address + offset));
        }


        static public unsafe List<float> GetWheelsSteering(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x1BC;
            //ulong offRadius = 0x110; // offWheelSzX

            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = *((float*)(wheel + offset));

                angle.Add(pos);
            }
            return angle;
        }

        static public void DrawStats(Racer r)
        {
            float diff = (r.Car.Velocity.Length() - r.IdealSpeed)*10;
            float acc = (r.CurrentThrottle *100f);

            string percent = "";

            for (int i = 0; i < 100-acc; i++) percent += " ";
            for (int i = 0; i < acc; i++) percent += "<";
     //       percent += "~w~";
            if (diff < 0f) diff = 0f;
            //
            //    racertext.Unload();
            //  
            debugFrontend.CallFunction("CLEAR_ALL", true);
            debugFrontend.CallFunction("CREATE_CONTAINER");

            
            debugFrontend.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Attack), percent + "%");
            
        debugFrontend.CallFunction("DRAW_INSTRUCTIONAL_BUTTONS", -1);

            debugFrontend.Render2D();

            return;
            if (racertext == null || !racertext.IsLoaded)
            {
                racertext = new Scaleform("mp_car_stats_01");

            }
            else
            {


                float enginePoer = 0f;
                float traction = 0f;
                float topSpeed = 0f;
                racertext.CallFunction("SET_VEHICLE_INFOR_AND_STATS", r.Car.FriendlyName, r.Car.ClassType.ToString(), "MPCarHUD", "Dinka", "Acceleration", "Brake", "Slide", "IdealSpeedDiff", (int)acc, (int)r.CurrentBrake * 100f, (int)r.SideSlide * 100f, (int)diff);

                racertext.CallFunction("setBars", 1, r.Car.Speed);
                racertext.Render3D(r.Car.Position + new Vector3(0.0f, 0.0f, r.Car.Model.GetDimensions().Z + (1f + 3f)), GameplayCamera.Rotation, new Vector3(6f * 3f, 3f * 3f, 1f * 3f));
                  if (GetRandomInt(0, 100) < 2)
                {
                    racertext.Unload();
                    racertext = new Scaleform("mp_car_stats_01");
                }

                //  
            }


        }

        static public void DrawStats(string entity_name, string entity_desc, string first_name, string second_name, string third_name, string fourth_name, int first_value, int second_value, int third_value, int fourth_value, Vector3 position)
        {

            if (racertext == null || !racertext.IsLoaded)
            {
                racertext = new Scaleform("mp_car_stats_01");
                

            }
            else
            {
                racertext.CallFunction("SET_VEHICLE_INFOR_AND_STATS", entity_name, entity_desc, "MPCarHUD", "Obey", first_name, second_name, third_name, fourth_name, first_value, second_value, third_value, fourth_value);


                racertext.CallFunction("setBars", 1, (float)Math.Round((float)(first_value * 2),1));

                racertext.Render3D(position, GameplayCamera.Rotation, new Vector3(6f * 3f, 3f * 3f, 1f * 3f));
            }
        }
        static public unsafe List<float> GetWheelSlippage(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x1A8;
            //ulong offRadius = 0x110; // offWheelSzX
            //ulong offRadius = 0x110; // offWheelSzX

            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = *((float*)(wheel + offset));

                angle.Add(pos);
            }
            return angle;
        }
        

        public static float GetRoadHeading(Entity E, float ahead)
        {
            if (CanWeUse(E))
            {
                OutputArgument outArgA = new OutputArgument();
                OutputArgument outArgB = new OutputArgument();
                Vector3 p = E.Position + (E.ForwardVector * ahead);

                if (Function.Call<bool>(Hash.GET_CLOSEST_VEHICLE_NODE_WITH_HEADING, p.X, p.Y, p.Z, outArgA, outArgB, 0, 1077936128, 0))
                {
                    Vector3 pos = outArgA.GetResult<Vector3>();

                    return outArgB.GetResult<float>();
                }
            }
            return 0;
        }

        public static float GetRoadOutOfBoundsX(Entity E, float ahead)
        {
            if (CanWeUse(E))
            {
                OutputArgument outArgA = new OutputArgument();
                OutputArgument outArgB = new OutputArgument();
                Vector3 p = E.Position + (E.ForwardVector * ahead);

                if (Function.Call<bool>(Hash.GET_CLOSEST_VEHICLE_NODE_WITH_HEADING, p.X, p.Y, p.Z, outArgA, outArgB, 0, 1077936128, 0))
                {
                    Vector3 pos = outArgA.GetResult<Vector3>();

                    return GetOffset(E, pos).X;
                    //return outArgB.GetResult<float>();
                }
            }
            return 0;
        }

        public static Vector3 GetRoadPos(Entity E, float ahead)
        {
            if (CanWeUse(E))
            {
                OutputArgument outArgA = new OutputArgument();
                OutputArgument outArgB = new OutputArgument();
                Vector3 p = E.Position + (E.ForwardVector * ahead);

                if (Function.Call<bool>(Hash.GET_CLOSEST_VEHICLE_NODE_WITH_HEADING, p.X, p.Y, p.Z, outArgA, outArgB, 0, 1077936128, 0))
                {
                    Vector3 pos = outArgA.GetResult<Vector3>();

                    return pos;
                    //return outArgB.GetResult<float>();
                }
            }
            return Vector3.Zero;
        }



        public static Vector3 Bezier2(Vector3 Start, Vector3 Control, Vector3 End, float t)
        {
            return (((1 - t) * (1 - t)) * Start) + (2 * t * (1 - t) * Control) + ((t * t) * End);
        }


        //0 = id, 1 = pos, 2 = heading, 3= xOffset, 4=current corner, 5=future corner angle, 6 =old pos
        public static List<dynamic> GetClosestNodeInfo(Entity E, List<Vector3> PathRoute, float ahead, int refNode)
        {
            List<dynamic> result = new List<dynamic>();
            if (CanWeUse(E))
            {
                float NodeCornerAngle = 0f;
                int node = 0;
                float distToVehicle = 0;
                int count = 0;
                Vector3 nodePos = Vector3.Zero;

                if (refNode > 0 && refNode < PathRoute.Count - 1 && 1 == 2)
                {
                    node = refNode - 1;
                    nodePos = Path[node];
                }

                else
                {
                    //Get closest node


                    foreach (Vector3 position in PathRoute)
                    {
                        if (distToVehicle == 0 || position.DistanceTo(E.Position) < distToVehicle)
                        {
                            distToVehicle = position.DistanceTo(E.Position);
                            node = count;
                            nodePos = position;
                        }
                        count++;
                    }
                }

                //Relative X offset (deviation) to that node
                float xOffset = GetOffset(E, nodePos).X;

                //Advance nodes from the closest one you got
                if (ahead > 0f)
                {
                    for (int i = 0; i < 20; i++)
                    {
                        node++;
                        if (node >= PathRoute.Count - 1) node = 0;

                        float yOffset = GetOffset(E, PathRoute[node]).Y; //PathRoute[node].DistanceTo(E.Position+(E.ForwardVector*(E.Model.GetDimensions().Y/2))) 
                        if (yOffset > ahead)
                        {
                            nodePos = PathRoute[node];
                            break;
                        }
                    }
                }
                Vector3 oldnode = nodePos;
                if (node > 2) oldnode = PathRoute[node - 3]; else oldnode = PathRoute[PathRoute.Count - 3];

                result.Add(node); // 0, node id
                result.Add(nodePos); //1 nodepos

                //Current node angle
                int fNode = node + 1;
                if (fNode >= PathRoute.Count - 1) fNode = 0;
                Vector3 heading = PathRoute[fNode] - PathRoute[node];
                float nodeHeading = Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, heading.X, heading.Y);

                //Future node angle
                int ffNode = fNode + 1;
                if (ffNode >= PathRoute.Count - 1) ffNode = 0;
                Vector3 fheading = PathRoute[ffNode] - PathRoute[fNode];
                float fCornerAngle = fheading.ToHeading() - heading.ToHeading(); //  Function.Call<float>(Hash.GET_ANGLE_BETWEEN_2D_VECTORS, fheading.X, fheading.Y, heading.X, heading.Y);


                int pastnode = node - 1;
                if (pastnode < 0) pastnode = PathRoute.Count - 1;
                Vector3 pastHeading = PathRoute[node] - PathRoute[pastnode];

                NodeCornerAngle = (nodeHeading - Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, pastHeading.X, pastHeading.Y));

                result.Add(nodeHeading);//2, corner heading

                result.Add(xOffset);//3, xoffset (deviation

                int reference = node;
                int fReference = node + 1;

                float fHeading = nodeHeading;
                if (NodeCornerAngle > 270) NodeCornerAngle -= 360;
                if (NodeCornerAngle < -270) NodeCornerAngle += 360;
                result.Add(NodeCornerAngle); //4,  corner angle


                heading.Normalize();
                pastHeading.Normalize();


                if (fCornerAngle > 270) fCornerAngle -= 360;
                if (fCornerAngle < -270) fCornerAngle += 360;

                result.Add(fCornerAngle);//5, future corner angle

                result.Add(oldnode); //6, old node for deviation
                                     /*
                                       //Worst corner angle (100m)
                                       float fCurveAngle = (heading.ToHeading() - pastHeading.ToHeading());
                                       if (fCurveAngle > 270) fCurveAngle -= 360;
                                       if (fCurveAngle < -270) fCurveAngle += 360;

                                       result.Add(fCurveAngle);
                                       */
            }

            return result;

        }

        public static void WorstCornerAhead(Racer r ,List<Vector3> route, int cNode, float currentCorner, int maxdist)
        {
            // r.WorstConers.Clear();
            float current =  r.Car.Velocity.Length()*1.2f; //max_speed

            List<dynamic> worstInfo = new List<dynamic>();
            // int bNode = cNode;
            //   r.WorstConers.Clear();


            if (r.WorstConers.Count > 0) maxdist = r.WorstConers[0][3]-cNode+40;
            Vector3 cDir = Vector3.Zero;
            Vector3 fDir = Vector3.Zero;
            float angle = 0f;


            string dd = "";
            int count = cNode ;
            while (count < cNode + maxdist)
            {
                count++;

            
                if (Angles.ContainsKey(count))
                {

                    angle =(float) Math.Round( Angles[count],1);// Vector3.SignedAngle(cDir, fDir, Vector3.WorldUp);

                    if (Math.Abs(angle) > 1f)
                    {
                        // if (r.WorstConers.Count > 0 && Math.Abs(angle) < r.WorstConers[r.WorstConers.Count - 1][0]) return;
                        float SurfaceGrip = 1f;
                        if (ScriptTest.MultiplierInTerrain.ContainsKey(count))
                        {
                            SurfaceGrip = MultiplierInTerrain[count];

                        }

                        float worstcspeed = (float)Math.Round((ScriptTest.GetSpeedForAngle(Math.Abs(angle), r.Confidence* SurfaceGrip)), 1);
                        worstcspeed = ScriptTest.Clamp(worstcspeed, ScriptTest.min_speed, ScriptTest.max_speed);

                        if ( worstcspeed < current-2f)//-10f
                        {



                            //  if(!r.WorstConers.Contains(worstInfo))  
                            if (r.WorstConers.Where(v => v[3] == count).Count() == 0)
                            {
                                dd += count + " ";
                                worstInfo= new List<dynamic>();

                                worstInfo.Add(angle);
                                worstInfo.Add(route[count]);
                                worstInfo.Add(fDir);
                                worstInfo.Add(count);
                                r.WorstConers.Add(worstInfo);
                                
                            }
                        }

                    }
                }
            }
            //     if (count < 2 || count > route.Count - 2) return;




         //   ScriptTest.DisplayHelpText(dd);

         // 
            //  return worstInfo;
        }
        public static List<dynamic> GetFutureWorstCorner(Vehicle v, List<Vector3> PathRoute, int node, float currentDiff, float maxDist)
        {
            List<dynamic> info = new List<dynamic>();

            float fHeading = 0f;
            //  if (fHeading >= 180) fHeading -= 180;

            int reference = node;
            if (reference < 0) reference = 0;
            int fReference = reference + 1;


            float WorstAngle = 0;
            Vector3 WorstAnglePos = Vector3.Zero;
            Vector3 WorstAngleDir = Vector3.Zero;
            for (int i = 0; i < 50; i++)
            {
                reference++;
                if (reference >= PathRoute.Count - 1) reference = 0;
                fReference = reference + 1;
                if (fReference >= PathRoute.Count - 1) fReference = 0;

                if (PathRoute[reference].DistanceTo(v.Position) < maxDist)
                {
                    Vector3 newH = PathRoute[fReference] - PathRoute[reference];
                    float dd = (float)Math.Round(Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, newH.X, newH.Y), 1);
                    //  if (dd >= 180) dd -= 180;
                    if (fHeading == 0)
                    {
                        fHeading = dd;
                        continue;
                    }



                    //   if (dd > 180 && fHeading < 90) dd = -(360 - dd);
                    //  if (fHeading > 180 && dd < 90) fHeading = -(360 - fHeading);

                    //if (dd - fHeading >= 90) dd -= 180;


                    //         if (dd >= 180) dd -= 180;
                    //           if (dd - fHeading >= 90) dd -= 180;

                    float futureDiff = (dd - fHeading);
                    if (futureDiff < -270) futureDiff += 360;
                    if (futureDiff > 270) futureDiff -= 360;

                    //       if (diff >=90 ) diff -= 180;
                    //     if (diff <= -90) diff += 180;
                    if (1 == 1 || Math.Abs(futureDiff) > Math.Abs(currentDiff))
                    {
                        if (Math.Abs(futureDiff) > 270)
                        {

                            info.Add(WorstAngle);
                            info.Add(WorstAnglePos);
                            //   //UI.Notify("~r~Heading Error");
                            return info;// Math.Abs(currentDiff);

                            fHeading = 0;
                            break;
                        }
                        else
                        {
                            if (Math.Abs(futureDiff) > Math.Abs(WorstAngle))
                            {
                                WorstAngle = futureDiff;
                                WorstAnglePos = PathRoute[reference];
                                WorstAngleDir = (WorstAnglePos - PathRoute[reference + 1]).Normalized;
                            }
                            //fHeading = dd; // Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, newH.X, newH.Y);
                            // break;
                        }
                    }
                    fHeading = dd;
                }
            }

            info.Add(WorstAngle);
            info.Add(WorstAnglePos);
            info.Add(WorstAngleDir);
            return info;

        }
        public static Vector3 LerpByDistance(Vector3 A, Vector3 B, float x)
        {
            Vector3 P = x * Vector3.Normalize(B - A) + A;
            return P;
        }
        static Vector3 GetXfromPosInDirection(Vector3 mypos, Vector3 dir, Vector3 pos)
        {

            Vector3 newDir = mypos - pos;
            Vector3 offset = Vector3.Cross(dir, newDir);


            return offset;
        }
        public static bool IsRoadBusy(Vector3 pos, int carNum)
        {
            OutputArgument outArgA = new OutputArgument();
            OutputArgument outArgB = new OutputArgument();
            if (Function.Call<bool>(Hash.GET_VEHICLE_NODE_PROPERTIES, pos.X, pos.Y, pos.Z, outArgA, outArgB))
            {
                int busy = outArgA.GetResult<int>();
                int flags = outArgB.GetResult<int>();

                //DisplayHelpTextThisFrame("Busy:" + busy + "~n~Flags:" + flags);
                if (busy >= carNum) return true;

                //BOOL GET_VEHICLE_NODE_PROPERTIES(float x, float y, float z, int *density, int* flags) // 0x0568566ACBB5DEDC 0xCC90110B
            }
            return false;
        }
        static Vector3 OffsetByAngle(Vehicle v, Vector3 refDir, Vector3 goal, float angle)
        {
            Vector3 outVec = Vector3.Zero;


            float speed = v.Position.DistanceTo(goal);
            Vector3 Position = v.Position;

            Vector3 Goaltemp = goal; //Position + (v.ForwardVector * speed);
            Vector3 Direction = (Goaltemp - Position).Normalized;
            Vector3 Goal = Position + Direction * speed;

            float Angle = angle;// Vector3.Angle(v.Velocity.Normalized, Direction);
            if (Vector3.SignedAngle(Direction, refDir, Vector3.WorldUp) < 0) Angle = -Angle;

            Vector3 offsetDirection = Quaternion.RotationAxis(Vector3.WorldUp, (float)(System.Math.PI / 180f) * Angle) * Direction; // Quaternion.RotationAxis takes radian angles

            Vector3 physGoal = Position + offsetDirection * speed;

            outVec = Vector3.Cross(Direction, (new Vector3(0, 0, (Goal.DistanceTo(physGoal)))));
            if (Vector3.SignedAngle(Direction, offsetDirection, Vector3.WorldUp) > 0) outVec = -outVec;



            DrawLine(Position, goal, Color.White);
            DrawLine(Position, goal + outVec, Color.White);
            return outVec;
        }

        public static bool IsStable(Vehicle v, float maxSlide, float maxSpin)
        {
            if (maxSpin > 0f && Math.Abs(rad2deg(Function.Call<Vector3>(Hash.GET_ENTITY_ROTATION_VELOCITY, v, true).Z)) >= maxSpin) return false;
            if (maxSlide > 0f && Math.Abs(Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, v, true).Normalized.X) >= maxSlide) return false;
            return true;
        }

        public static bool IsSliding(Vehicle v, float maxSlide)
        {
            if (Math.Abs(Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, v, true).Normalized.X) * 100 >= maxSlide) return true;
            return false;
        }
        static float SpeedBonusTraction(float traction)
        {
            if (traction > 2f) return traction;
            else return Math.Abs(traction - 2) * 3;
        }
        static float SpeedCurve(float angle, Vehicle v)
        {
            float mult = 1f;

            if (angle > 10) mult = 1.4f;

            if (angle > 40) mult = 1.6f;

            float value = (100 - (angle * mult)); //1.5f
            if (value < 10) value = 10;
            return value;
        }
        public static int GetRandomInt(int min, int max)
        {
            Random rnd = new Random();
            return rnd.Next(min, max);
        }

        static float SpeedBonusBraking(float braking)
        {
            if (braking > 1f) return (braking + 1) * 2;
            else return Math.Abs(2 - braking) * -3;
        }


        void OnKeyDown(object sender, KeyEventArgs e)
        {


        }
        void OnKeyUp(object sender, KeyEventArgs e)
        {
            //  if (e.KeyCode == Keys.Oemplus) gamma += 0.02f;
            // if (e.KeyCode == Keys.OemMinus) gamma -= 0.02f;
        }

        public static void DrawLine(Vector3 from, Vector3 to, Color color)
        {
            Function.Call(Hash.DRAW_LINE, from.X, from.Y, from.Z, to.X, to.Y, to.Z, color.R, color.G, color.B, color.A);
        }

        protected override void Dispose(bool dispose)
        {
            Function.Call(Hash._STOP_ALL_SCREEN_EFFECTS);
            if (World.RenderingCamera == FreeCam)
            {
                ToggleFreeCam();

            }
            Function.Call(Hash.DO_SCREEN_FADE_IN, 500);


            foreach (int fx in FlareFX) Function.Call(Hash.STOP_PARTICLE_FX_LOOPED, fx);

            //if(racertext!= null)   racertext.Unload();

           if(FreeCam!=null) FreeCam.Destroy();
            if (CustomCamEnd != null) CustomCamEnd.Destroy();
            if (CustomCamStart != null) CustomCamStart.Destroy();
            if (CanWeUse(FreecCamRide)) FreecCamRide.Delete();

            foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
            foreach (Racer racer in Racers)
            {
                racer.Delete();
            }

            Racers.Clear();
            if(racertext!=null && racertext.IsLoaded)  racertext.Unload();
            if (Countdown != null)
            {
                Countdown.Dispose();
                
            }

            //   if(CanWeUse(UndersteerPlayerProp))  UndersteerPlayerProp.Delete();
            base.Dispose(dispose);
        }

        public bool IsAhead(Vehicle v, Vector3 pos)
        {
            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, v, pos.X, pos.Y, pos.Z).Y < 0;
        }

        public bool HasArrived(Vehicle v, Vector3 pos, float range)
        {
            return v.IsInRangeOf(pos, range) || (Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, v, pos.X, pos.Y, pos.Z).Y < range && v.IsInRangeOf(pos, range * 2));
        }
        public static bool WasCheatStringJustEntered(string cheat)
        {
            return Function.Call<bool>(Hash._0x557E43C447E700A8, Game.GenerateHash(cheat));
        }
        
        /// TOOLS ///
        void LoadSettings()
        {
            if (File.Exists(@"scripts\\NewRacingSystem.ini"))
            {

                ScriptSettings config = ScriptSettings.Load(@"scripts\NewRacingSystem.ini");
                MaxIdealSpeed = config.GetValue<float>("GENERAL_SETTINGS", "MaxIdealSpeed", 200f);

                SpeedToInput = config.GetValue<float>("GENERAL_SETTINGS", "speed_to_input", 10f);

                max_angle = config.GetValue<float>("GENERAL_SETTINGS", "max_angle", 3f);

                max_speed = config.GetValue<float>("GENERAL_SETTINGS", "max_speed", 40f);
                min_speed = config.GetValue<float>("GENERAL_SETTINGS", "min_speed", 10f);
                TuningLevel = config.GetValue<int>("GENERAL_SETTINGS", "AITuningLevel", 3);
                TCSLevel = config.GetValue<int>("GENERAL_SETTINGS", "TCSLevel", 0);
                MaxLaps = config.GetValue<int>("GENERAL_SETTINGS", "MaxLaps", 2);
                DistanceBetweenFlares = config.GetValue<int>("GENERAL_SETTINGS", "DistanceBetweenFlares", 2);

                SpawnTracksideProps = config.GetValue<bool>("GENERAL_SETTINGS", "SpawnTracksideProps", true);
                AIRacerAutofix = config.GetValue<int>("GENERAL_SETTINGS", "AIRacerAutofix", 1);

            }
            else
            {
            //    WarnPlayer(ScriptName + " " + ScriptVer, "SCRIPT RESET", "~g~Towing Service has been cleaned and reset succesfully.");
            }
        }

        void WarnPlayer(string script_name, string title, string message)
        {
            Function.Call(Hash._SET_NOTIFICATION_TEXT_ENTRY, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, message);
            Function.Call(Hash._SET_NOTIFICATION_MESSAGE, "CHAR_SOCIAL_CLUB", "CHAR_SOCIAL_CLUB", true, 0, title, "~b~" + script_name);
        }

        public static bool CanWeUse(Entity entity)
        {
            return entity != null && entity.Exists();
        }

        void DisplayHelpTextThisFrame(string text)
        {
            Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, text);
            Function.Call(Hash._DISPLAY_HELP_TEXT_FROM_STRING_LABEL, 0, false, false, -1);
        }


        static Vector2 World3DToScreen2d(Vector3 pos)
        {
            var x2dp = new OutputArgument();
            var y2dp = new OutputArgument();

            Function.Call<bool>(Hash._WORLD3D_TO_SCREEN2D, pos.X, pos.Y, pos.Z, x2dp, y2dp);
            return new Vector2(x2dp.GetResult<float>(), y2dp.GetResult<float>());
        }
        public enum DrawTextAlign { Center, Left, Right }

        public enum DrawTextFont { Default, Italics, Squared}
        public static void DrawText(Vector3 pos, string t, Color c ,  float scale)
        {
            Vector2 screeninfo = World3DToScreen2d(pos);
            Function.Call(Hash._SET_TEXT_ENTRY, "STRING");
            Function.Call(Hash.SET_TEXT_CENTRE, true);
            Function.Call(Hash.SET_TEXT_COLOUR, c.R, c.G, c.B, c.A);
            Function.Call(Hash.SET_TEXT_SCALE, 1f, scale);
            Function.Call(Hash.SET_TEXT_DROP_SHADOW, true);
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);
            Function.Call(Hash._DRAW_TEXT, screeninfo.X, screeninfo.Y);
        }


        public static float DrawText(Vector2 pos, string t, Color c,DrawTextFont font , DrawTextAlign align , float scale)
        {
            Function.Call(Hash._SET_TEXT_ENTRY, "STRING");

            Function.Call(Hash.SET_TEXT_COLOUR, c.R, c.G, c.B, c.A);
            Function.Call(Hash.SET_TEXT_SCALE, 1f, scale);
            Function.Call(Hash.SET_TEXT_RIGHT_JUSTIFY, true);

            Function.Call(Hash.SET_TEXT_DROP_SHADOW, true);
            Function.Call(Hash.SET_TEXT_JUSTIFICATION, (int)align);
            Function.Call(Hash.SET_TEXT_FONT, (int)font);

            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);

            Function.Call(Hash._DRAW_TEXT, pos.X, pos.Y);

             Function.Call(Hash._0x54CE8AC98E120CAB, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);




            float d = Function.Call<float>(Hash._0x85F061DA64ED2F67, 1);

            return d;
        }
        unsafe private float GetGearRatio(Vehicle v, uint gear)
        {
            if (gear > 7) return 1.2f;

            // if (!v.Exists()) return 0.0f;
            //  *((int*)(address + offset));
            return *(v.MemoryAddress + 0x838 + gear * sizeof(float));
        }

        /*
                
                static public unsafe List<float> GetWheelsGrip(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x198;


            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos =(float) Math.Round( *((float*)(wheel + offset)), 2);

                angle.Add(pos);
            }
            return angle;
        }
        */
        /*
                  GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;
            ulong offset = 0xB60; // GetWheelsPtr(handle);// (ulong)(gameVersion >= GameVersion.VER_1_0_372_2_STEAM ? 0xAA0 : 0xA80);

            offset += 8;


            // UI.ShowSubtitle((*((int*)(address + offset))).ToString());
            return *((int*)(address + offset));
        }
        */


        public static unsafe ulong GetHandlingPtr(Vehicle v)
        {
            if (!CanWeUse(v))  return (ulong)0;

            var address = (ulong)v.MemoryAddress;
            ulong offset = 0x918;
            return *((ulong*)(address + offset));
        }

        public static unsafe float GetTRCurveMax(Vehicle v)
        {
            
            if (!CanWeUse(v)) return 0f;
            ulong handlingAddress = GetHandlingPtr(v);
            
            ulong tractionCurveMaxOffset = 0x088;
        //        UI.Notify(handlingAddress.ToString());
            if (handlingAddress < 1) return 0f;
            float result= *(float*)(handlingAddress + tractionCurveMaxOffset);
            return result;
            //return 0f;
        }
        public static unsafe void SetDefMultiplier(Vehicle v, float mult)
        {
            if (!CanWeUse(v)) return;

            ulong handlingAddress = GetHandlingPtr(v);
            ulong tractionCurveMaxOffset = 0x00D0;
             *(float*)(handlingAddress + tractionCurveMaxOffset)=mult;
        }
        unsafe private void SetGearRatio(Vehicle v, uint gear, float ratio)
        {
            if (!CanWeUse(v)) return;

            if (gear > 7) return;

            if (!v.Exists()) return;

            *(float*)(v.MemoryAddress + 0x838 + gear * sizeof(float)) = ratio;
        }



        static T RandomEnumValue<T>()
        {
            var v = Enum.GetValues(typeof(T));
            return (T)v.GetValue(new Random().Next(v.Length));
        }

        public static void RandomTuning(Vehicle veh, bool color, bool livery, bool parts, bool performance, bool horn)
        {
              veh.InstallModKit();

            Script.Wait(100);
            if (livery && veh.LiveryCount > 0) veh.Livery = GetRandomInt(0, veh.LiveryCount);
            if(veh.GetModCount(VehicleMod.Livery)>0) veh.SetMod(VehicleMod.Livery, GetRandomInt(0, veh.GetModCount(VehicleMod.Livery)), false);


            if (color)
            {
                int c = GetRandomInt(1, Function.Call<int>(Hash.GET_NUMBER_OF_VEHICLE_COLOURS, veh));
                Function.Call(Hash.SET_VEHICLE_COLOUR_COMBINATION, veh, c);
                //UI.Notify(color.ToString() + "/" + Function.Call<int>(Hash.GET_NUMBER_OF_VEHICLE_COLOURS, veh));
            }


            //Change tuning parts
            foreach (int mod in Enum.GetValues(typeof(VehicleMod)).Cast<VehicleMod>())
            {
                if (mod == (int)VehicleMod.Horns) continue;
                if (veh.GetModCount((VehicleMod)mod) > 0)
                {

                    if (new List<VehicleMod> { VehicleMod.Engine, VehicleMod.Transmission, VehicleMod.Brakes, VehicleMod.Suspension }.Contains((VehicleMod)mod))
                    {
                        if (!performance) continue;
                    }
                    else if (!parts) continue;
                    if (mod == (int)VehicleMod.FrontWheels) continue;
                    if (mod == (int)VehicleMod.Suspension) continue;
                    if (mod == (int)VehicleMod.Livery && !livery) continue;
                    if (mod == (int)VehicleMod.Horns && !horn) continue;
                    int d = veh.GetModCount((VehicleMod)mod);

                    if (d > 0)
                    {
                        Script.Wait(30);
                        veh.SetMod((VehicleMod)mod, GetRandomInt(0, d), false);

                    }
                }
            }

            //Change neons if at night
            if (World.CurrentDayTime.Hours > 20 || World.CurrentDayTime.Hours < 7)
            {

                //Color neoncolor = Color.FromArgb(0, Util.GetRandomInt(0, 255), Util.GetRandomInt(0, 255), Util.GetRandomInt(0, 255));
                Script.Wait(30);
                Color neoncolor = Color.Red;// veh.CustomPrimaryColor;// Color.FromKnownColor((KnownColor)GetRandomInt(0, Enum.GetValues(typeof(KnownColor)).Cast<KnownColor>().Count()));
                veh.NeonLightsColor = neoncolor;
                /*
                veh.SetNeonLightsOn(VehicleNeonLight.Front, true);
                veh.SetNeonLightsOn(VehicleNeonLight.Back, true);
                veh.SetNeonLightsOn(VehicleNeonLight.Left, true);
                veh.SetNeonLightsOn(VehicleNeonLight.Right, true);
                */
            }


   



        }


        static public void DisplayHelpTextTimed(string text, int time)
        {
            Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, text);
            Function.Call(Hash._DISPLAY_HELP_TEXT_FROM_STRING_LABEL, 0, false, false, time);
        }

        static public void DisplayHelpText(string text)
        {
            Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, text);
            Function.Call(Hash._DISPLAY_HELP_TEXT_FROM_STRING_LABEL, 0, false, false, -1f);
        }

        

        public static string CreateDriver(string name, Ped ped)
        {
            string filePath = @"Scripts\NewRacingSystem\Drivers\" + name + ".xml";

            File.AppendAllText(filePath, "");

           // File.Create(filePath);
            //            if (File.Exists(@"scripts\\NewRacingSystem.ini"))

            Script.Wait(200);

            XmlDocument XMLFile = new XmlDocument();
        //    XMLFile.Load(filePath);

            if(XMLFile==null)
            {
                UI.Notify("~r~cannot find file");
            }

            XmlNode Data = XMLFile.CreateNode(XmlNodeType.Element, "Data", null);
            XMLFile.AppendChild(Data);

            XmlNode Driver = XMLFile.CreateNode(XmlNodeType.Element, "Driver", null);

            //Name and model
            XmlNode temp = XMLFile.CreateElement("Name");
            temp.InnerText = name;
            Driver.AppendChild(temp);

            temp = XMLFile.CreateElement("Model");
            temp.InnerText =  ped.Model.Hash.ToString();
            Driver.AppendChild(temp);
            temp = XMLFile.CreateElement("Clothes");
            for (int i= 0; i < 90; i++)
            {

                XmlElement cloth = XMLFile.CreateElement(i.ToString());
                XmlAttribute id = XMLFile.CreateAttribute(Function.Call<int>(Hash.GET_PED_DRAWABLE_VARIATION, ped, i).ToString());         
                id.InnerText = Function.Call<int>(Hash.GET_PED_TEXTURE_VARIATION, ped, i).ToString();

                cloth.Attributes.Append(id);
                // id = XMLFile.CreateAttribute(i.ToString());
                temp.AppendChild(cloth);
                //Function.Call<bool>(Hash.IS_VEHICLE_EXTRA_TURNED_ON, veh, i)
            }

            Driver.AppendChild(temp);

            //Skills
            XmlNode DriverSkills = XMLFile.CreateElement("Skills");


            XmlNode Skill = XMLFile.CreateElement("Skill");
            Skill.InnerText ="ExampleSkill";
            XmlAttribute att = XMLFile.CreateAttribute("value");
            att.InnerText = "25";
            Skill.Attributes.Append(att);
            DriverSkills.AppendChild(Skill);

            Skill = XMLFile.CreateElement("Skill");
            Skill.InnerText = "ExampleSkill2";
            att = XMLFile.CreateAttribute("value2");
            att.InnerText = "50";
            Skill.Attributes.Append(att);
            DriverSkills.AppendChild(Skill);



            Driver.AppendChild(DriverSkills);
            

            Data.AppendChild(Driver);

            XMLFile.AppendChild(Data);
                        
            XMLFile.Save(@"scripts\\NewRacingSystem\Drivers\"+name+".xml");
            UI.Notify("Saved");
            return "Finished";
            /*
            if (1==1)
            {

                XmlElement Wheeltype = originalXml.CreateElement("WheelType");
                Wheeltype.InnerText = ((int)veh.WheelType).ToString();
                Data.AppendChild(Wheeltype);


                XmlElement TrimColor = originalXml.CreateElement("TrimColor");
                TrimColor.InnerText = ((int)veh.TrimColor).ToString();
                Data.AppendChild(TrimColor);

                XmlElement DashColor = originalXml.CreateElement("DashColor");
                DashColor.InnerText = ((int)veh.DashboardColor).ToString();
                Data.AppendChild(DashColor);

                XmlElement PrimaryColor = originalXml.CreateElement("PrimaryColor");
                PrimaryColor.InnerText = ((int)veh.PrimaryColor).ToString();
                Data.AppendChild(PrimaryColor);

                XmlElement SecondaryColor = originalXml.CreateElement("SecondaryColor");
                SecondaryColor.InnerText = ((int)veh.SecondaryColor).ToString();
                Data.AppendChild(SecondaryColor);

                XmlElement PearlescentColor = originalXml.CreateElement("PearlescentColor");
                PearlescentColor.InnerText = ((int)veh.PearlescentColor).ToString();
                Data.AppendChild(PearlescentColor);


                XmlElement RimColor = originalXml.CreateElement("RimColor");
                RimColor.InnerText = ((int)veh.RimColor).ToString();
                Data.AppendChild(RimColor);


                XmlElement LicensePlate = originalXml.CreateElement("LicensePlate");
                LicensePlate.InnerText = ((int)veh.NumberPlateType).ToString();
                Data.AppendChild(LicensePlate);

                XmlElement LicensePlateText = originalXml.CreateElement("LicensePlateText");
                LicensePlateText.InnerText = veh.NumberPlate;
                Data.AppendChild(LicensePlateText);


                XmlElement WindowsTint = originalXml.CreateElement("WindowsTint");
                WindowsTint.InnerText = ((int)veh.WindowTint).ToString();
                Data.AppendChild(WindowsTint);

                XmlElement Livery = originalXml.CreateElement("Livery");
                Livery.InnerText = veh.Livery.ToString();
                Data.AppendChild(Livery);


                XmlElement Components = originalXml.CreateElement("Components");

                for (int i = 0; i <= 25; i++)
                {
                    XmlElement Component = originalXml.CreateElement("Component");

                    XmlAttribute Attribute = originalXml.CreateAttribute("ComponentIndex");
                    Attribute.InnerText = i.ToString();
                    Component.Attributes.Append(Attribute);

                    if (Function.Call<bool>(Hash.IS_VEHICLE_EXTRA_TURNED_ON, veh, i))
                    {
                        Component.InnerText = "1";
                    }
                    else
                    {
                        Component.InnerText = "0";
                    }
                    Components.AppendChild(Component);
                }
                Data.AppendChild(Components);

                //SMOKE COLOR GOES HERE

                //CUSTOM TYRES GO HERE
                XmlElement CustomTires = originalXml.CreateElement("CustomTires");

                CustomTires.InnerText = Function.Call<bool>(Hash.GET_VEHICLE_MOD_VARIATION, veh, (int)VehicleMod.FrontWheels).ToString();// Util.HasCustomTires(veh).ToString();
                Data.AppendChild(CustomTires);


                //NEON COLORS GO HERE
                XmlElement Neons = originalXml.CreateElement("Neons");

                XmlElement NeonInfo = originalXml.CreateElement("Left");
                NeonInfo.InnerText = veh.IsNeonLightsOn(VehicleNeonLight.Left).ToString();
                Neons.AppendChild(NeonInfo);

                NeonInfo = originalXml.CreateElement("Right");
                NeonInfo.InnerText = veh.IsNeonLightsOn(VehicleNeonLight.Right).ToString();
                Neons.AppendChild(NeonInfo);

                NeonInfo = originalXml.CreateElement("Front");
                NeonInfo.InnerText = veh.IsNeonLightsOn(VehicleNeonLight.Front).ToString();
                Neons.AppendChild(NeonInfo);

                NeonInfo = originalXml.CreateElement("Back");
                NeonInfo.InnerText = veh.IsNeonLightsOn(VehicleNeonLight.Back).ToString();
                Neons.AppendChild(NeonInfo);

                Data.AppendChild(Neons);


                XmlElement NeonColor = originalXml.CreateElement("NeonColor");
                XmlElement Color = originalXml.CreateElement("R");
                Color.InnerText = veh.NeonLightsColor.R.ToString();
                NeonColor.AppendChild(Color);

                Color = originalXml.CreateElement("G");
                Color.InnerText = veh.NeonLightsColor.G.ToString();
                NeonColor.AppendChild(Color);

                Color = originalXml.CreateElement("B");
                Color.InnerText = veh.NeonLightsColor.B.ToString();
                NeonColor.AppendChild(Color);

                Data.AppendChild(NeonColor);

            }
            if (1==1)
            {
                XmlElement ModToggles = originalXml.CreateElement("ModToggles");

                for (int i = 0; i <= 15; i++)
                {
                    XmlElement Component = originalXml.CreateElement("Toggle");

                    XmlAttribute Attribute = originalXml.CreateAttribute("ToggleIndex");
                    Attribute.InnerText = i.ToString();
                    Component.Attributes.Append(Attribute);

                    if (Function.Call<bool>(Hash.IS_TOGGLE_MOD_ON, veh, i))
                    {
                        Component.InnerText = "true";
                        ModToggles.AppendChild(Component);
                    }
                }
                Data.AppendChild(ModToggles);

                XmlElement Mods = originalXml.CreateElement("Mods");
                for (int i = 0; i <= 500; i++)
                {
                    XmlElement Component = originalXml.CreateElement("Mod");

                    XmlAttribute Attribute = originalXml.CreateAttribute("ModIndex");
                    Attribute.InnerText = i.ToString();
                    Component.Attributes.Append(Attribute);

                    if (Function.Call<int>(Hash.GET_VEHICLE_MOD, veh, i) != -1)
                    {
                        Component.InnerText = Function.Call<int>(Hash.GET_VEHICLE_MOD, veh, i).ToString();
                        Mods.AppendChild(Component);
                    }
                }
                Data.AppendChild(Mods);
            }
            */

        }
         List<dynamic> LoadVehicle (string name, Vector3 place)
        {
            Vehicle car = null;
            XmlDocument XMLFile = new XmlDocument();

            List<dynamic> result = new List<dynamic>();
            List<XmlDocument> files = new List<XmlDocument>();

            foreach (string filename in Directory.GetFiles(@"Scripts\NewRacingSystem\Vehicles\"))
            {
                XMLFile.Load(filename);
                UI.Notify("Loading");
                string vehiclename = XMLFile.SelectSingleNode("//Name").InnerText;

                if(vehiclename==name)
                {
                    UI.Notify("Found");
                    break;
                }
                //UI.Notify("~g~"+XMLFile.SelectSingleNode("//Name").InnerText);


            }
            UI.Notify("Creating");

            car = World.CreateVehicle(int.Parse(XMLFile.SelectSingleNode("//Model").InnerText), place);
            car.PrimaryColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Primary").InnerText);
            car.SecondaryColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Secondary").InnerText);
            car.PearlescentColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Pearl").InnerText);
            car.RimColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Wheel").InnerText);
            car.DashboardColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Dash").InnerText);
            car.TrimColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Trim").InnerText);

            foreach (XmlElement modelement in XMLFile.SelectNodes("//Mods/Mod")) car.SetMod((VehicleMod)int.Parse(modelement.GetAttribute("ModID")), int.Parse(modelement.InnerText),false);



            foreach (XmlElement modelement in XMLFile.SelectNodes("//Mods/ToggleMod")) car.ToggleMod((VehicleToggleMod)int.Parse(modelement.GetAttribute("ModID")), bool.Parse(modelement.InnerText));


            foreach (XmlElement modelement in XMLFile.SelectNodes("//Extras/Extra")) car.ToggleExtra(int.Parse(modelement.InnerText),true);




            float acc = float.Parse(XMLFile.SelectSingleNode("//Acceleration").InnerText);

            if(Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc)
            {
                float mul = 10f;
                while (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION,car) < acc)
                {
                    mul += 10;
                    car.EnginePowerMultiplier = mul;
                    Script.Wait(0);
                }
            }




            car.IsPersistent = false;

            result.Add(car);
            result.Add(XMLFile);

            UI.Notify("Finished");

            return result;
        }

        List<dynamic> LoadGrid(string discipline, int maxcars)
        {
            Vehicle car = null;
            XmlDocument XMLFile = new XmlDocument();

            List<dynamic> result = new List<dynamic>();
            List<XmlDocument> files = new List<XmlDocument>();
            List<XmlDocument> candidates = new List<XmlDocument>();
            foreach (string filename in Directory.GetFiles(@"Scripts\NewRacingSystem\Vehicles"))
            {
                XMLFile.Load(filename);
                foreach(XmlElement disc in XMLFile.SelectNodes("//Disciplines/Discipline"))
                {
                    if (disc.InnerText == discipline)
                    {
                        candidates.Add(XMLFile);
                    }
                }
                XMLFile = new XmlDocument();
                //UI.Notify("~g~"+XMLFile.SelectSingleNode("//Name").InnerText);
            }

            foreach (XmlDocument File in candidates)
            {


                car = World.CreateVehicle(int.Parse(File.SelectSingleNode("//Model").InnerText), Path[40]);
                car.InstallModKit();
                car.PrimaryColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Primary").InnerText);
                car.SecondaryColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Secondary").InnerText);
                car.PearlescentColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Pearl").InnerText);
                car.RimColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Wheel").InnerText);
                car.DashboardColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Dash").InnerText);
                car.TrimColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Trim").InnerText);

                foreach (XmlElement modelement in File.SelectNodes("//Mods/Mod")) car.SetMod((VehicleMod)int.Parse(modelement.GetAttribute("ModIndex")), int.Parse(modelement.InnerText), false);



                foreach (XmlElement modelement in File.SelectNodes("//Mods/ToggleMod")) car.ToggleMod((VehicleToggleMod)int.Parse(modelement.GetAttribute("ModIndex")),  int.Parse(modelement.InnerText) ==1 ? true :false );


                foreach (XmlElement modelement in File.SelectNodes("//Extras/Extra")) car.ToggleExtra(int.Parse(modelement.InnerText), true);




                float acc = float.Parse(File.SelectSingleNode("//Acceleration").InnerText);

                if (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc)
                {
                    float mul = 10f;
                    while (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc&& mul<500)
                    {
                        mul += 10;
                        car.EnginePowerMultiplier = mul;
                        Script.Wait(0);
                    }
                }
                car.Position = Path[Racers.Count*4];
                Racer r = new Racer(car, car.CreateRandomPedOnSeat(VehicleSeat.Driver));
                r.Name = File.SelectSingleNode("//Name").InnerText;
                Racers.Add(r);
            }





           // car.IsPersistent = false;

            result.Add(car);
            result.Add(XMLFile);

            return result;
        }

        void CreateVehicle(string name, Vehicle car)
        {
            string filePath = @"Scripts\NewRacingSystem\Vehicles\" + name + ".xml";




                File.AppendAllText(filePath, "");

            // File.Create(filePath);
            //            if (File.Exists(@"scripts\\NewRacingSystem.ini"))

            Script.Wait(200);

            XmlDocument XMLFile = new XmlDocument();
            //    XMLFile.Load(filePath);

            if (XMLFile == null)
            {
                UI.Notify("~r~cannot find file");
            }

            XmlNode Data = XMLFile.CreateNode(XmlNodeType.Element, "Data", null);
            XMLFile.AppendChild(Data);

            XmlNode Vehicle = XMLFile.CreateNode(XmlNodeType.Element, "Vehicle", null);

            //Name and model
            
            /*
            XmlElement FriendlyName = XMLFile.CreateElement("ModelName");
            FriendlyName.InnerText = car.FriendlyName;
            if (FriendlyName.InnerText == "NULL") FriendlyName.InnerText = car.DisplayName;
            Vehicle.AppendChild(FriendlyName);
            */

            XmlNode temp = XMLFile.CreateElement("Name");
            temp.InnerText = name;
            Vehicle.AppendChild(temp);


            XmlNode Class = XMLFile.CreateElement("Class");
            Class.InnerText = Game.GetUserInput(32);
            Vehicle.AppendChild(Class);

            List<string> keywords = new List<string>();



            for (int i = 0; i <= 6; i++)
            {
                string k = Game.GetUserInput(32);
                if (k == "") break; else keywords.Add(k.ToLowerInvariant());

            }

            XmlNode keyw = XMLFile.CreateElement("Disciplines");
            foreach (string keyword in keywords)
            {
                XmlNode ktoadd = XMLFile.CreateElement("Discipline");
                ktoadd.InnerText = keyword;
                keyw.AppendChild(ktoadd);
            }

            Vehicle.AppendChild(keyw);

            temp = XMLFile.CreateElement("Model");
            temp.InnerText = car.Model.Hash.ToString();
            Vehicle.AppendChild(temp);


            //Absolute acceleration, it iss affected by the engine power multiplier and its used to simulate further engine performance mods.
            //On load, the vehicle will be boosted until its acceleration equals this one.
            temp = XMLFile.CreateElement("Acceleration");
            temp.InnerText = Math.Round( Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car), 3).ToString();
            temp.InnerText = temp.InnerText.Replace(",", ".");

            Vehicle.AppendChild(temp);


            XmlAttribute vname = XMLFile.CreateAttribute("ModelName");
            vname.InnerText = car.FriendlyName;
            if (vname.InnerText == "NULL") vname.InnerText = car.DisplayName;
            temp.Attributes.Append(vname);

            XmlElement Colors = XMLFile.CreateElement("Colors");

            XmlElement c = XMLFile.CreateElement("Primary");
            c.InnerText = ((int)car.PrimaryColor).ToString();
            Colors.AppendChild(c);

             c = XMLFile.CreateElement("Secondary");
            c.InnerText = ((int)car.SecondaryColor).ToString();
            Colors.AppendChild(c);

             c = XMLFile.CreateElement("Pearl");
            c.InnerText = ((int)car.PearlescentColor).ToString();
            Colors.AppendChild(c);

             c = XMLFile.CreateElement("Wheel");
            c.InnerText = ((int)car.RimColor).ToString();
            Colors.AppendChild(c);

             c = XMLFile.CreateElement("Dash");
            c.InnerText = ((int)car.DashboardColor).ToString();
            Colors.AppendChild(c);

             c = XMLFile.CreateElement("Trim");
            c.InnerText = ((int)car.TrimColor).ToString();
            Colors.AppendChild(c);

            Vehicle.AppendChild(Colors);
            XmlElement Mods = XMLFile.CreateElement("Mods");
            for (int i = 0; i <= 100; i++)
            {
                XmlElement Component = XMLFile.CreateElement("Mod");

                XmlAttribute Attribute = XMLFile.CreateAttribute("ModIndex");
                Attribute.InnerText = i.ToString();
                Component.Attributes.Append(Attribute);

                if (Function.Call<int>(Hash.GET_VEHICLE_MOD, car, i) != -1)
                {
                    Component.InnerText = Function.Call<int>(Hash.GET_VEHICLE_MOD, car, i).ToString();
                    Mods.AppendChild(Component);
                }
            }
            //Vehicle.AppendChild(Mods);

            
            for (int i = 0; i <= 100; i++)
            {
                XmlElement Mod = XMLFile.CreateElement("ToggleMod");

                XmlAttribute Attribute = XMLFile.CreateAttribute("ModIndex");
                Attribute.InnerText = i.ToString();
                Mod.Attributes.Append(Attribute);

                if (Function.Call<int>(Hash.IS_TOGGLE_MOD_ON, car, i) != 0)
                {
                    Mod.InnerText = Function.Call<int>(Hash.IS_TOGGLE_MOD_ON, car, i).ToString();
                    Mods.AppendChild(Mod);
                }
            }
            Vehicle.AppendChild(Mods);



            XmlElement Components = XMLFile.CreateElement("Extras");

            for (int i = 0; i <= 15; i++)
            {
                if (Function.Call<bool>(Hash.IS_VEHICLE_EXTRA_TURNED_ON, car, i))
                {
                    XmlElement Component = XMLFile.CreateElement("Extra");
                    Component.InnerText = i.ToString();
                    Components.AppendChild(Component);
                }
            }
            Vehicle.AppendChild(Components);
            

            Data.AppendChild(Vehicle);




            XMLFile.AppendChild(Data);

            XMLFile.Save(@"scripts\\NewRacingSystem\Vehicles\" + name + ".xml");
            UI.Notify("Saved");
        }
        /*
        void SpawnDriversFromFile(List<String> NotPermitted, int maxtoadd, string LookFor)
        {
            File.AppendAllText(@"scripts\\DragMeets\debug.txt", "\n Spawning cars");

            if (LookFor != "") maxtoadd = 1;
            bool FirstTime = Racers.Count == 0;
            XmlDocument document = new XmlDocument();
            document.Load(RacersFile);
            int pat = 0;
            while (document == null && pat < 500)
            {
                document.Load(RacersFile);
                Script.Wait(0);
            }
            if (pat >= 500)
            {

                WarnPlayer(ScriptName + " " + ScriptVer, "Racers.xml LOAD ERROR", "~r~Couldn't load the file.");
                ClearMeet(true);
                return;
            }
            XmlElement docroot = document.DocumentElement;


            XmlNodeList nodelist = docroot.SelectNodes("//Racers/*");
            if (nodelist.Count == 0) nodelist = docroot.SelectNodes("//Drivers/*");

            if (nodelist.Count == 0)
            {
                WarnPlayer(ScriptName + " " + ScriptVer, "Racers.xml LOAD ERROR", "~r~No vehicles found in Racers.xml.");
                return;
            }
            XmlNodeList nodelist2 = nodelist;
            List<String> drivers = new List<String>();
            List<String> pickeddrivers = new List<String>();
            int limit = maxtoadd;

            foreach (XmlElement driver in nodelist)
            {

                if (driver.GetAttribute("Name") != null && (LookFor == "" && !NotPermitted.Contains(driver.GetAttribute("Name"))) || (driver.GetAttribute("Name").ToLowerInvariant() == LookFor.ToLowerInvariant()))
                {

                    if (driver.SelectSingleNode("RacesAllowed") == null)
                    {
                        drivers.Add(driver.GetAttribute("Name"));
                        if (DebugNotifications) UI.Notify("Added generic driver: " + driver.GetAttribute("Name"));
                    }
                    else
                    {
                        //foreach (string kind in KindsAllowed) UI.Notify("Allowed:" +kind);
                        foreach (XmlElement component in driver.SelectNodes("RacesAllowed/*"))
                        {
                            //UI.Notify(driver.GetAttribute("Name")+": "+component.InnerText);
                            if (KindsAllowed.Contains(component.InnerText) || LookFor != "")
                            {
                                drivers.Add(driver.GetAttribute("Name"));
                                break;
                            }
                        }
                    }

                }
                else if (DebugNotifications) UI.Notify("~o~" + driver.GetAttribute("Name") + " is already in the Meet");


            }
            if (limit > drivers.Count)
            {
                limit = drivers.Count;
                if (DebugNotifications) UI.Notify("Not enough cars for this Meet, lowering limit to  " + limit);
                if (limit < maxtoadd) maxtoadd = limit;
            }

            var copyDrivers = new List<string>(drivers);
            for (int _ = 0; _ < limit; _++)
            {
                int i = Util.RandomInt(0, copyDrivers.Count);
                pickeddrivers.Add(copyDrivers[i]);
                copyDrivers.RemoveAt(i);
            }

            float num = 1;
            // if (limit != maxtoadd) num = 200;
            foreach (XmlElement driver in nodelist)
            {
                //Script.Wait(50);
                if (pickeddrivers.Contains(driver.GetAttribute("Name")))
                {

                    File.AppendAllText(@"scripts\\DragMeets\debug.txt", "\n" + driver.GetAttribute("Name"));
                    Vector3 position = WaitingArea;

                    num += 3f;
                    if (Game.Player.Character.IsInRangeOf(WaitingArea, 200f))
                    {
                        if (ManualMeetSpawn && FirstTime)
                        {
                            if (num > WaitingAreRange)
                            {
                                num += 20f;
                                position = World.GetNextPositionOnStreet(DragMeets.WaitingArea.Around(num));
                            }
                            else
                            {
                                position = DragMeets.WaitingArea.Around(num);
                            }
                        }
                        else
                        {
                            if (num < 200) num = 200;
                            num += 20f;
                            position = World.GetNextPositionOnStreet(DragMeets.WaitingArea.Around(num));
                        }
                    }
                    else
                    {
                        position = DragMeets.WaitingArea.Around(num);
                    }


                    bool IsRandomVehicle = false;
                    Vehicle veh = null;
                    int patience = 0;
                    int maxpatience = 1000;
                    while (!CanWeUse(veh) && patience < maxpatience)
                    {
                        patience++;
                        if (patience > maxpatience / 2 && DebugNotifications) DisplayHelpTextThisFrame("Trying to spawn " + driver.SelectSingleNode("Vehicle/Model").InnerText + " for the Drag Meet...(" + patience + "/" + maxpatience + ")");


                        int n;
                        if (int.TryParse(driver.SelectSingleNode("Vehicle/Model").InnerText, out n))
                        {
                            veh = World.CreateVehicle(n, position);
                        }
                        else
                        {
                            veh = World.CreateVehicle(driver.SelectSingleNode("Vehicle/Model").InnerText, position);
                        }
                    }

                    bool Error = false;
                    if (patience >= maxpatience)
                    {
                        if (DebugNotifications) WarnPlayer(ScriptName + " " + ScriptVer, "VEHICLE LOAD ERROR", "Error trying to load " + driver.SelectSingleNode("Vehicle/Model").InnerText + ". Skipping this car.");
                        File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + " ERROR vehicle model not found in game files, SKIPPED");

                        Error = true;
                    }
                    if (Error) continue;
                    File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + " created");

                    Ped ped = null;

                    if (driver.SelectSingleNode("PedModel") != null)
                    {
                        if (driver.SelectSingleNode("PedModel").InnerText == "random")
                        {
                            ped = World.CreatePed(RacerModel[Util.RandomInt(0, RacerModel.Count)], veh.Position.Around(2f));
                            //ped = Function.Call<Ped>(Hash.CREATE_RANDOM_PED_AS_DRIVER, veh, true);
                        }
                        else
                        {
                            int nped;
                            if (int.TryParse(driver.SelectSingleNode("PedModel").InnerText, out nped))
                            {
                                ped = World.CreatePed(nped, veh.Position.Around(2f));
                            }
                            else
                            {
                                ped = World.CreatePed(driver.SelectSingleNode("PedModel").InnerText, veh.Position.Around(2f));
                            }
                        }
                    }
                    if (!CanWeUse(ped)) ped = Function.Call<Ped>(Hash.CREATE_RANDOM_PED_AS_DRIVER, veh, true);

                    while (veh == null || ped == null)
                    {
                        Script.Wait(0);
                    }
                    File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + " ped created");

                    if (RandomTuningAll)
                    {
                        Script.Wait(40);
                        Util.RandomTuning(veh, false, false);
                        File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + "tuned (random)");
                    }
                    else
                    {
                        if (UseDesigns) //driver.SelectSingleNode("Vehicle//PrimaryColor") != null
                        {
                            Function.Call(Hash.SET_VEHICLE_MOD_KIT, veh, 0);
                            if (driver.SelectSingleNode("Vehicle/PrimaryColor") != null)
                            {

                                if (driver.SelectSingleNode("Vehicle/WheelType") != null) veh.WheelType = (VehicleWheelType)int.Parse(driver.SelectSingleNode("Vehicle/WheelType").InnerText, CultureInfo.InvariantCulture);
                                if (driver.SelectSingleNode("Vehicle/PrimaryColor") != null) veh.PrimaryColor = (VehicleColor)int.Parse(driver.SelectSingleNode("Vehicle/PrimaryColor").InnerText, CultureInfo.InvariantCulture); else IsRandomVehicle = true;
                                if (driver.SelectSingleNode("Vehicle/SecondaryColor") != null) veh.SecondaryColor = (VehicleColor)int.Parse(driver.SelectSingleNode("Vehicle/SecondaryColor").InnerText, CultureInfo.InvariantCulture);
                                if (driver.SelectSingleNode("Vehicle/PearlescentColor") != null) veh.PearlescentColor = (VehicleColor)int.Parse(driver.SelectSingleNode("Vehicle/PearlescentColor").InnerText, CultureInfo.InvariantCulture);
                                if (driver.SelectSingleNode("Vehicle/TrimColor") != null) Function.Call((Hash)0xF40DD601A65F7F19, veh, int.Parse(driver.SelectSingleNode("Vehicle/TrimColor").InnerText, CultureInfo.InvariantCulture));
                                if (driver.SelectSingleNode("Vehicle/DashColor") != null) Function.Call((Hash)0x6089CDF6A57F326C, veh, int.Parse(driver.SelectSingleNode("Vehicle/DashColor").InnerText, CultureInfo.InvariantCulture));
                                if (driver.SelectSingleNode("Vehicle/RimColor") != null) veh.RimColor = (VehicleColor)int.Parse(driver.SelectSingleNode("Vehicle/RimColor").InnerText, CultureInfo.InvariantCulture);
                                if (driver.SelectSingleNode("Vehicle/LicensePlateText") != null) veh.NumberPlate = driver.SelectSingleNode("Vehicle/LicensePlateText").InnerText;
                                if (driver.SelectSingleNode("Vehicle/LicensePlate") != null) Function.Call(Hash.SET_VEHICLE_NUMBER_PLATE_TEXT_INDEX, veh, int.Parse(driver.SelectSingleNode("Vehicle/LicensePlate").InnerText, CultureInfo.InvariantCulture));
                                if (driver.SelectSingleNode("Vehicle/WindowsTint") != null) veh.WindowTint = (VehicleWindowTint)int.Parse(driver.SelectSingleNode("Vehicle/WindowsTint").InnerText, CultureInfo.InvariantCulture);

                                if (driver.SelectSingleNode("Vehicle//SmokeColor") != null)
                                {
                                    Color color = Color.FromArgb(255, int.Parse(driver.SelectSingleNode("Vehicle//SmokeColor/Color/R").InnerText), int.Parse(driver.SelectSingleNode("Vehicle//SmokeColor/Color/G").InnerText), int.Parse(driver.SelectSingleNode("Vehicle//SmokeColor/Color/B").InnerText));
                                    veh.TireSmokeColor = color;
                                }

                                if (driver.SelectSingleNode("Vehicle//NeonColor") != null)
                                {

                                    if (driver.SelectSingleNode("Vehicle//NeonColor/Color") != null)
                                    {
                                        Color color = Color.FromArgb(255, int.Parse(driver.SelectSingleNode("Vehicle//NeonColor/Color/R").InnerText), int.Parse(driver.SelectSingleNode("Vehicle//NeonColor/Color/G").InnerText), int.Parse(driver.SelectSingleNode("//Vehicle/NeonColor/Color/B").InnerText));
                                        veh.NeonLightsColor = color;
                                    }
                                    else
                                    {
                                        Color color = Color.FromArgb(255, int.Parse(driver.SelectSingleNode("Vehicle//NeonColor/R").InnerText), int.Parse(driver.SelectSingleNode("Vehicle//NeonColor/G").InnerText), int.Parse(driver.SelectSingleNode("Vehicle//NeonColor/B").InnerText));
                                        veh.NeonLightsColor = color;
                                    }

                                }
                                if (driver.SelectSingleNode("Vehicle/Neons/Back") != null) veh.SetNeonLightsOn(VehicleNeonLight.Back, bool.Parse(driver.SelectSingleNode("Vehicle/Neons/Back").InnerText));
                                if (driver.SelectSingleNode("Vehicle/Neons/Front") != null) veh.SetNeonLightsOn(VehicleNeonLight.Front, bool.Parse(driver.SelectSingleNode("Vehicle/Neons/Front").InnerText));
                                if (driver.SelectSingleNode("Vehicle/Neons/Left") != null) veh.SetNeonLightsOn(VehicleNeonLight.Left, bool.Parse(driver.SelectSingleNode("Vehicle/Neons/Left").InnerText));
                                if (driver.SelectSingleNode("Vehicle/Neons/Right") != null) veh.SetNeonLightsOn(VehicleNeonLight.Right, bool.Parse(driver.SelectSingleNode("Vehicle/Neons/Right").InnerText));

                                foreach (XmlElement component in driver.SelectNodes("Vehicle/Components/*"))
                                {
                                    int t = int.Parse(component.InnerText, CultureInfo.InvariantCulture);
                                    if (t == 1) t = 0; else t = 1;
                                    Function.Call(Hash.SET_VEHICLE_EXTRA, veh, int.Parse(component.GetAttribute("ComponentIndex")), t);
                                }
                                foreach (XmlElement component in driver.SelectNodes("Vehicle/ModToggles/*"))
                                {
                                    Function.Call(Hash.TOGGLE_VEHICLE_MOD, veh, int.Parse(component.GetAttribute("ToggleIndex")), bool.Parse(component.InnerText));
                                }
                                foreach (XmlElement component in driver.SelectNodes("Vehicle/Mods/*"))
                                {
                                    veh.SetMod((VehicleMod)int.Parse(component.GetAttribute("ModIndex")), int.Parse(component.InnerText, CultureInfo.InvariantCulture), bool.Parse(driver.SelectSingleNode("Vehicle/CustomTires").InnerText));
                                }
                                File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + "tuned");
                            }
                            else
                            {
                                if (RandomTuningGeneric)
                                {
                                    Script.Wait(40);
                                    Util.RandomTuning(veh, false, false);
                                    File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + "tuned (random)");
                                }
                            }
                        }
                    }


                    int turbo = 1;
                    if (driver.SelectSingleNode("CustomTurbo") != null)
                    {
                        turbo = int.Parse(driver.SelectSingleNode("CustomTurbo").InnerText, CultureInfo.InvariantCulture);
                    }

                    //Shifting
                    int shiftskill = 50;
                    if (driver.GetAttribute("Shifting") != "" && driver.GetAttribute("Shifting") != "50")
                    {
                        shiftskill = int.Parse(driver.GetAttribute("Shifting"));
                    }
                    else
                    {
                        shiftskill = Util.RandomInt(35, 80);
                    }

                    //Reaction
                    int reactSkill = 250;
                    if (driver.GetAttribute("Reaction") != "" && driver.GetAttribute("Reaction") != "250")
                    {
                        reactSkill = int.Parse(driver.GetAttribute("Reaction"));
                    }
                    else
                    {
                        reactSkill = Util.RandomInt(150, 850);
                    }

                    File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + "skilled");

                    //Name
                    string name = veh.FriendlyName;
                    bool ShouldBepersistent = true;
                    if (UseDesigns)
                    {
                        if (driver.GetAttribute("Name") != "") name = driver.GetAttribute("Name");
                        if (driver.GetAttribute("DriverName") != "") name = driver.GetAttribute("Name");
                    }
                    else
                    {
                        ShouldBepersistent = false;
                    }

                    ShouldBepersistent = PersistentRacers;

                    if (turbo > 1 && DebugNotifications) name = "(Supercharged) " + name;
                    veh.Heading = Util.RandomInt(-180, 180);


                    //Parachutes
                    bool Parachute = false;
                    if (AllowParachutes)
                    {
                        if (driver.GetAttribute("Parachute") == "true") Parachute = true;
                        if (SupercarsUseParachutes)
                        {
                            if (veh.ClassType == VehicleClass.Super) Parachute = true;
                        }
                    }
                    int Money = 0;
                    if (driver.HasAttribute("Money")) Money = int.Parse(driver.GetAttribute("Money"));

                    int Won = 0;
                    if (driver.HasAttribute("RacesWon")) Won = int.Parse(driver.GetAttribute("RacesWon"));
                    int Lost = 0;
                    if (driver.HasAttribute("RacesLost")) Lost = int.Parse(driver.GetAttribute("RacesLost"));

                    Racers.Add(new Racer(name, ped, veh, turbo, reactSkill, shiftskill, !FirstTime, Won, Lost, Money, Parachute, ShouldBepersistent));
                    File.AppendAllText(@"scripts\\DragMeets\debug.txt", " - " + "finished ");
                }

            }

        }

        */
    }

}