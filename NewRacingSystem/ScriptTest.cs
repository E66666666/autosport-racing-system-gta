using GTA;
using GTA.Math;
using GTA.Native;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading;
using System.Windows.Forms;
using System.Xml;
using System.Text.RegularExpressions;
namespace NewRacingSystem
{
    public enum RaceState
    {
       None, NotInitiated, Countdown, InProgress, PostRace, Finished,
    }

    public enum Options
    {
        Brakepower, RestartRace, StartRace, Start,GridSize, Laps,LeaveRace, StopRace, Freecam, LoadTrack, DebugLevel, SaveTrack,UpdateTrackFile, CreateTrack, ExitCreator, TrackNameFilter, TrackList,
        SaveThisCar, SaveDriverModel, Disciplines, FindCustomProps
    }


    public enum DebugMode
    {
        None, Inputs, Trails, Cornering, Interactions, Route, RacingLineEdit, PropEdit
    }


    public class ARS : Script
    {
        public static List<Vehicle> GlobalTraffic = new List<Vehicle>();
        public static List<string> KnownDisciplines = new List<string>();
        public static List<string> KnownTracks = new List<string>();
        public static int RaceReward = 0;

        public static XmlDocument TrackFile = new XmlDocument();
        public static ScriptSettings SettingsFile;
        public static ScriptSettings DevSettingsFile;

        public static Dictionary<int, float> RacingLine = new Dictionary<int, float>();
        public static Dictionary<int, float> RacingLineGuide = new Dictionary<int, float>();

        public static bool HideHudMode = false;
        public static int extracurvedip = 0;
        public static int extradistancedip = -2;

        

        public static float ForcedBrakepower = 1f;
        public static List<Prop> CustomProps = new List<Prop>();
        public static List<Prop> AutoGeneratedProps = new List<Prop>();

        public static int OptionHovered = 0;
        public static List<Options> OptionsList = new List<Options>();

        
        public static List<Racer> LeaderboardFinish = new List<Racer>();

        bool IsDroneMode = true;
        public static Prop FreecCamRide = null;
        public static List<Model> RacerModels = new List<Model> { "a_m_y_motox_01", "a_m_y_motox_02" };
        public static RaceState RaceStatus = RaceState.None;

        string ScriptName = "ARS";
        string ScriptVer = "0.0.0.0";
        string ScriptDate = "30/09/2018";

        public static bool debugInfo = true;


        //offsets
        static public ulong steeroffset = 0x0;
        static public ulong throttleOffset = 0x0;
        static public ulong brakeOffset = 0x0;
        public static ulong wheelsptr = 0x0;
        public static ulong numwheelsoffset = 0x0;

        public static PedHash[] streetModels = { PedHash.Car3Guy2, PedHash.Vinewood02AFY, PedHash.Stwhi02AMY, PedHash.StrPunk02GMY, PedHash.Stbla02AMY };

        public static List<int> Other = new List<int> { 555004797, -399872228, -1447280105, 722686013 };
        public static List<int> Road = new List<int> { 1187676648, 282940568, -108464011, 1187676648, -1084640111, };       //-1286696947<grass
        public static List<int> Dirt = new List<int> { 1144315879, 510490462, -1907520769, -1885547121, -700658213, 2128369009,
            -1595148316,-765206029,509508168,1333033863,951832588,-840216541,-1907520769,510490462,-1942898710}; //-461750719
        public static List<int> Sand = new List<int> { 1288448767, };

        public static List<string> HelpMessages = new List<string>();




        //public static int SettingsFile.GetValue("GENERAL_SETTINGS","Laps", 5) = 1;

        //Loaded from config
        public static float MaxIdealSpeed = 200f;
        public static float SpeedToInput = 10f;
        public static float max_angle = 3f;
        public static float delta = 0.2f;
        public static float max_speed = 80f;
        public static float min_speed = 15f;
        public static int TuningLevel = 0;
        public static int TCSLevel = -1;
        public static int AIRacerAutofix = 1;
       // public static bool SpawnTracksideProps = true;

        //AI racers, and the player if they participate
        public static List<Racer> Racers = new List<Racer>();

        //General AI behavior
        public static float idealSld = 5; //In degrees. Over this, AI starts to countersteer
        public static float maxWheelspinAllowed = -1f;// -0 to -5. 


        //Route info
        public static List<Vector3> Path = new List<Vector3>(); //List of nodes that conform the race path.
        public static Dictionary<int, float> Angles = new Dictionary<int, float>(); //List of angles from node to node, on the path above.
        public static Dictionary<int, float> MultiplierInTerrain = new Dictionary<int, float>();  //Grip multiplier on each node. Initially empty, the first racer fills them as they pass.

        public static Dictionary<int, float> WideDict = new Dictionary<int, float>(); //How wide (meters) each node is.

        public static Dictionary<int, float> EditWideDict = new Dictionary<int, float>();
        public static List<Prop> TrackLimits = new List<Prop>(); //Trackside props, placed automatically.

        public static Vector3 MiniMap = Vector3.Zero; //Center of the minimap. Functional, but unused.


        public static XmlDocument CurrentFile = null;


        static bool routeEditMode = false;
        
        public static int DebugLevel = 0;
        public static bool IsShiftOn = false;



        int TimeToFinishRace = 0;
        float TimeScale = 1f;
        float IdealTimeScale = 1f;
        int GameTimeRef = 0;
        int GametimerefLong = 0;

        public enum TerrainTypes
        {
            Sand = 1288448767,
            RockySand = -1595148316,
            Gravel = -1885547121,
            GravelGrass = 2128369009,
            LooseGravel = 510490462,
            Rock = -840216541,
            MoreTarmac = 1187676648, //Concrete
            Tarmac = 282940568,
            WetTarmac = 999829011,
            Grass = 1286696947,
            FullGrass = -461750719,
            ShortGrass = 1333033863,
        }

        bool Loaded = false;
        public void LoadScript()
        {
            DisplayHelpTextTimed("Loading ~b~ARS.~w~ May take a while.", 10000);
            FillKnownDisciplines();
            Script.Yield();
            FillKnownTracks();
            ReFilterKnownTracks(TrackFilter);


            World.RenderingCamera = null;

            Log(LogImportance.Info, "Initialization complete.");
            DisplayHelpTextTimed("~g~ARS has loaded.", 2000);
            HelpMessages.Add("Press ~INPUT_SPRINT~ + ~INPUT_CONTEXT~ to open the ARSe menu.");
            Loaded = true;
        }
        public ARS()
        {
            Tick += OnTick;
            KeyDown += OnKeyDown;
            KeyUp += OnKeyUp;

            File.WriteAllText(@"scripts\ARS\Log.log", "----------------------------");
            Log(LogImportance.Info, "Script initialized - " + DateTime.Now);
            File.AppendAllText(@"scripts\ARS\Log.log", "\n----------------------------");



            LoadSettings();

            // Get the version of the current application.
            Assembly assem = Assembly.GetExecutingAssembly();
            AssemblyName assemName = assem.GetName();
            Version ver = assemName.Version;
            ScriptVer = ver.ToString();
            ScriptDate = System.IO.File.GetLastWriteTimeUtc(@"scripts/ARS/ARS.dll").ToString();


            UI.Notify("~b~" + ScriptName + "~g~e~w~" + "~y~ " + ScriptVer + "~n~Build: ~g~" + ScriptDate);

        }




        Dictionary<string, string> TrackTags = new Dictionary<string, string>();
        public void FillKnownTracks()
        {
            TrackTags.Clear();
            Log(LogImportance.Info, "Learning available tracks...");
            List<string> folders = Directory.GetDirectories(@"scripts\ARS\Tracks").ToList();
            folders.Add(@"scripts\ARS\Tracks");
            foreach (string  dir in folders)
            {
                int count = 0;
                foreach (string st in Directory.EnumerateFiles(@dir))
                {
                    string n = System.IO.Path.GetFileName(st);
                    Log(LogImportance.Info, st +" - ["+ string.Join(", ", GetTrackTags(st))+"]");
                    TrackTags.Add( st, string.Join(", ", GetTrackTags(st)));

                    count++;
                    if (count > 20)
                    {
                        count = 0;
                        Yield();
                    }
                }
            }
            KnownTracks = Directory.GetFiles(@"scripts\ARS\Tracks").ToList();
            Log(LogImportance.Info, "Done.");
            Log(LogImportance.Info, "-------------");

        }

        public static List<string> GetTrackTags(string path)
        {
            XmlDocument document = new XmlDocument();
            document.Load(path);
            int pat = 0;

            while (document == null && pat < 1000)
            {
                pat++;
                document.Load(path);
            }

            //string tags = "";
            List<string> tags = new List<string>();
            tags.Add(System.IO.Path.GetFileName(path).ToLowerInvariant());
            XmlNodeList nl = document.SelectNodes("//Tags/*");
            foreach (XmlNode node in nl)
            {
                tags.Add(node.InnerText.ToLowerInvariant());
            }


            return tags;
            
        }


        public static List<string> GetRacerTags(string path)
        {
            XmlDocument document = new XmlDocument();
            document.Load(path);
            int pat = 0;

            while (document == null && pat < 1000)
            {
                pat++;
                document.Load(path);
            }

            //string tags = "";
            List<string> tags = new List<string>();
            string dir = System.IO.Path.GetDirectoryName(path);

            dir = dir.Split(System.IO.Path.DirectorySeparatorChar).Last().ToLowerInvariant();
            if(dir!= "vehicles") tags.Add(dir);
            XmlNodeList nl = document.SelectNodes("//Disciplines/*");
            foreach (XmlNode node in nl)
            {
                tags.Add(node.InnerText.ToLowerInvariant());
            }


            return tags;

        }
        public  void ReFilterKnownTracks(string filter = "test")
        {
            
            FilteredTrackList.Clear();
            string[] tags = filter.ToLowerInvariant().Split(' ');
            foreach (string file in TrackTags.Keys)
            {
                int score = 0;
                foreach (string tag in tags)
                {
                    if (TrackTags[file].Contains(tag)) score++;
                }
                if(score==tags.Length) FilteredTrackList.Add(file);
            }            
        }
        public void FillKnownDisciplines()
        {
            RacerTags.Clear();
            Log(LogImportance.Info, "-------------");
            Log(LogImportance.Info, "Learning available disciplines...");
            List<string> folders = Directory.GetDirectories(@"scripts\ARS\Vehicles").ToList();
            folders.Add(@"scripts\ARS\Vehicles");
            foreach (string dir in folders)
            {
                int count = 0;
                foreach (string st in Directory.EnumerateFiles(@dir))
                {
                    //string n = System.IO.Path.GetFileName(st);
                    Log(LogImportance.Info, st + " - [" + string.Join(", ", GetRacerTags(st)) + "]");
                    RacerTags.Add(st, string.Join(", ", GetRacerTags(st)));

                    count++;
                    if(count > 20)
                    {
                        count = 0;
                        Yield();
                    }
                }
            }
            KnownTracks = Directory.GetFiles(@"scripts\ARS\Tracks").ToList();
            Log(LogImportance.Info, "Done.");
            Log(LogImportance.Info, "-------------");
            
        }
        public static float Clamp(float val, float min, float max)
        {
            if (val.CompareTo(min) < 0) return min;
            else if (val.CompareTo(max) > 0) return max;
            else return val;
        }
        public static float LeftOrRight(Vector3 pos, Vector3 refr, Vector3 dir)
        {
            Vector3 right = Vector3.Cross(dir, Vector3.WorldUp);
            Vector3 rPos = pos - refr;

            return Vector3.Dot(right, rPos);

        }
        public static Vector3 GetOffset(Entity reference, Entity ent)
        {

            Vector3 pos = ent.Position;
            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, reference, pos.X, pos.Y, pos.Z);

        }
        public static Vector3 GetOffset(Entity reference, Vector3 pos)
        {

            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, reference, pos.X, pos.Y, pos.Z);

        }

        public static Vector3 ConvertToLocalOffset(Entity reference, Vector3 pos)
        {

            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_IN_WORLD_COORDS, reference, pos.X, pos.Y, pos.Z);

        }

        public static float map(float x, float in_min, float in_max, float out_min, float out_max, bool clamp = false)
        {

            float r= (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
            if (clamp)r= Clamp(r, out_min, out_max);
            return r;
        }
    
        public static float mapGamma(float value, float in_min, float in_max, float min, float max, float gamma)
        {
            if (value > in_max) value = in_max;
            value /= in_max; // scale to 1.0;
            value = (float)Math.Pow(value, gamma); //original 0.4f

            float r = map(value, 0.0f, 1.0f, in_min, in_max);
            r = map(r, in_min, in_max, min, max);
            return r;
        }
        /*
        public static float GetSpeedForAngle(float degrees, float confidence)
        {
            degrees /= confidence;
            if (degrees > max_angle) degrees = max_angle;
            degrees /= max_angle; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, 0.2f); //original 0.4f

            float maxSpeed = max_speed;//60f;
            float minSpeed = min_speed;//20f;

            float minAngle = 0f;
            float maxAngle = 1.0f;


            float speed = map(degrees, minAngle, maxAngle, maxSpeed, minSpeed);

            if (speed < minSpeed) speed = minSpeed;
            if (speed > maxSpeed) speed = maxSpeed;
            return speed;
        }
        */
        public unsafe static byte* FindPattern(string pattern, string mask)
        {
            ProcessModule module = Process.GetCurrentProcess().MainModule;

            ulong address = (ulong)module.BaseAddress.ToInt64();
            ulong endAddress = address + (ulong)module.ModuleMemorySize;

            for (; address < endAddress; address++)
            {
                for (int i = 0; i < pattern.Length; i++)
                {
                    if (mask[i] != '?' && ((byte*)address)[i] != pattern[i])
                    {
                        break;
                    }
                    else if (i + 1 == pattern.Length)
                    {
                        return (byte*)address;
                    }
                }
            }

            return null;
        }



        static public unsafe float GetTrueSteer(Vehicle handle)
        {

            if (!CanWeUse(handle)) return 0f;

            if (steeroffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {


                    steeroffset = *(uint*)(addr + 6) + 8;
                    Log(LogImportance.Info, "[MEMORY] Learned the steer offset:" + steeroffset);
                }
            }
            else
            {
                var address = (ulong)handle.MemoryAddress;
                return *((float*)(address + steeroffset));
            }

            return 0;
        }


        static public unsafe void SetNitroOn(Vehicle v)
        {
            var vehHandle = v.MemoryAddress;
            IntPtr address = (IntPtr)FindPattern("\x38\x8B\x00\x00\x00\x00\x74\x04\xB1\x01\xEB\x58", "xx????xxxxxx");
            //\x38\x8B\x00\x00\x00\x00\x74\x04\xB1\x01\xEB\x58
            //\x8A\x83\x00\x00\x00\x00\x84\xC0\x75\x09\x40\x84\xFF
            if (address != null)
            {


                var g_vehNitroEnabledOffset = *(int*)(address + 2);
                bool d = *((bool*)(vehHandle + g_vehNitroEnabledOffset));
                
                Function.Call(Hash.REQUEST_NAMED_PTFX_ASSET, "veh_xs_vehicle_mods");

                Function.Call((Hash)0xC8E9B6B71B8E660D, v, 1);//Enable nitro
                Function.Call((Hash)0x30B5831ECD9C35C5, v, 1f); //Set mult
                Function.Call((Hash)0x6E31900C2247D4ED, v, 1); //??
                Function.Call((Hash)0x6DEE944E1EE90CFB, v, 1); //??
                Function.Call((Hash)0x6411EB7E837170B5, v, 1f); //??

                Function.Call((Hash)0x2970EAA18FD5E42F, v, 1); //??



                // *((bool*)(vehHandle + g_vehNitroEnabledOffset)) = true;
            }
        }
        static public unsafe void SetTrueSteer(Vehicle handle, float value)
        {

            if (steeroffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {
                    steeroffset = *(uint*)(addr + 6) + 8;
                    Log(LogImportance.Info, "[MEMORY] Learned the steer offset: " + steeroffset);

                }
            }
            else if (1 == 1)
            {
                var address = (ulong)handle.MemoryAddress;
                *((float*)(address + steeroffset)) = value;
            }

        }
        static public unsafe void SetThrottle(Vehicle handle, float value)
        {
            if (throttleOffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {


                    throttleOffset = *(uint*)(addr + 6) + 0x10;
                    Log(LogImportance.Info, "[MEMORY] Learned the throttle offset: " + throttleOffset);

                }
            }
            else if (1 == 1)
            {
                var address = (ulong)handle.MemoryAddress;

                *((float*)(address + throttleOffset)) = value;
            }


        }
        /*
        static public unsafe float GetThrottle(Vehicle handle)
        {
            if (throttleOffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {


                    throttleOffset = *(uint*)(addr + 6) + 0x10;
                    Log(LogImportance.Info, "[MEMORY] Learned the throttle offset:" + throttleOffset);

                }
            }
            else if (1 == 1)
            {
                var address = (ulong)handle.MemoryAddress;

               return *((float*)(address + throttleOffset));
            }

            return 0;
        }
        */
        static public unsafe void SetBrakes(Vehicle handle, float value)
        {
            if (!CanWeUse(handle)) return;
            if (brakeOffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x74\x0A\xF3\x0F\x11\xB3\x1C\x09\x00\x00\xEB\x25", "xxxxxx????xx");

                if (addr != null)
                {

                    brakeOffset = *(uint*)(addr + 6) + 0x14;
                    Log(LogImportance.Info, "[MEMORY] Learned the brakeOffset offset:" + brakeOffset);

                }
            }
            else if (1 == 1)
            {
                var address = (ulong)handle.MemoryAddress;

                *((float*)(address + brakeOffset)) = value;
            }

        }
        public static float rad2deg(float rad)
        {
            return (rad * (180.0f / (float)Math.PI)); //3.14159265358979323846264338327950288f));
        }

        public static float deg2rad(float angle)
        {
            return (float)(Math.PI * angle / 180.0f);
        }


        public static float MapIdealSpeedForDistance(float distance, float speedThere, float ratio)
        {
            float result = speedThere + ((ratio / 10) * (distance));
            if (result < speedThere) return speedThere;
            else return result;

        }
        public static float GetSpeedForAngle(float degrees, float confidence)
        {

          //  degrees -= min_angle;

            degrees /= confidence;
            if (degrees > max_angle) degrees = max_angle;
            degrees /= max_angle; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, delta); //original 0.4f

            float maxSpeed = max_speed;//60f;
            float minSpeed = min_speed;//20f;

            float minAngle = 0f;
            float maxAngle = 1.0f;
            

            float speed = map(degrees, minAngle, maxAngle, maxSpeed, minSpeed);

            if (speed < minSpeed) speed = minSpeed;
            if (speed > maxSpeed) speed = maxSpeed;
            return speed;
        }


        
        public static float GetRatioForAngle(float degrees, float gamma)
        {
            if (degrees > 40) degrees = 40;
            degrees /= 40; // scale to 1.0;
            degrees = (float)Math.Pow(degrees, gamma);
            float maxSpeed = 0f;
            float minSpeed = 1f;

            float minAngle = 0f;
            float maxAngle = 1.0f;

           
            float speed = map(degrees, minAngle, maxAngle, maxSpeed, minSpeed);

            if (speed > 1f) speed = 1f;


            return speed;
        }

        public static float GetSteerOffsetToReachDeviation(float distToDev, float maxDist, float maxSteer)
        {

            float result = 0f;
            
            result = map(distToDev, -maxDist, maxDist,-maxSteer, maxSteer);
            result = Clamp(result, -maxSteer, maxSteer);

            return result;
        }
        

     
        List<Vector3> temp = new List<Vector3>();


        Vector3 rBezier = Vector3.Zero;
        float scale = 1.5f;
        int wide = 5;

        int PathDisplayFidelity = 1;

        int GametimeCountDown = 0;
        int MaxCountDown = 7;
        int CountDown = 7;

        Vector3 FreeCamMovement = Vector3.Zero;
        Vector3 FreeCamRotation = Vector3.Zero;
        Entity FreeCamFollow = null;
        public static Scaleform scaleform = new Scaleform("INSTRUCTIONAL_BUTTONS");
        public static Scaleform racertext = null;// new Scaleform("mp_car_stats_01");
        public static Scaleform debugFrontend = new Scaleform("instructional_buttons");
        public static Scaleform floatingtext = new Scaleform("HUD_FLOATING_HELP_TEXT");
        public static Scaleform SCCountdown = new Scaleform("MP_BIG_MESSAGE_FREEMODE");



        string ParsedEnum(string t)
        {
            return string.Concat(t.Select(x => Char.IsUpper(x) ? " " + x : x.ToString())).TrimStart(' ');
        }

        public static List<string> FilteredTrackList = new List<string>();
        //public static List<XmlDocument> CurrentGrid = new List<XmlDocument>();
        public static string TrackFilter = "airport";
        public static string DisciplineFilter = "sports";


        Dictionary<string, string> RacerTags = new Dictionary<string, string>();

        public static int TrackListPos = 0;
        void HandleMenu()
        {
            if (OptionsList.Count == 0) return;
            if (TrackListPos > FilteredTrackList.Count - 1) TrackListPos = FilteredTrackList.Count - 1;
            if (TrackListPos < 0) TrackListPos = 0;

            Game.DisableControlThisFrame(2, GTA.Control.Phone);

            string Menu = "-- Options --";
            if (OptionHovered > OptionsList.Count - 1) OptionHovered = OptionsList.Count - 1;
            if (OptionHovered < 0) OptionHovered = OptionsList.Count - 1;

            float zoffset = 0;
            foreach (Options o in OptionsList)
            {
                string name = ParsedEnum(o.ToString());
                Menu += "~w~~n~";

                if (o == Options.TrackList) name = "Track";
               // if (o == Options.TrackNameFilter) name = "Search Tracks";
                if (o == OptionsList[OptionHovered]) Menu += "~b~> " + name + "~w~";
                else Menu += name;

                if (o == Options.Brakepower) Menu += " [" + Math.Round(ForcedBrakepower, 2) + "]";
                if (o == Options.TrackNameFilter) Menu += " [" + TrackFilter + "]";
                if (o == Options.Laps) Menu += " [~y~" + SettingsFile.GetValue("GENERAL_SETTINGS","Laps", 5) + "~w~]";
                if (o == Options.GridSize) Menu += " [~y~" + intendedOpponents + "~w~]";
                if (o == Options.DebugLevel) Menu += " [" + (DebugMode)DebugLevel + "]";
                if (o == Options.TrackList)
                {



                    Menu += " [";
                    int c = 0;
                    foreach (string s in FilteredTrackList)
                    {

                        if (c == TrackListPos) Menu += "~y~";
                        string d = System.IO.Path.GetFileName(FilteredTrackList[c]);
                        Regex r = new Regex("\\.{1}(xml)");
                        Menu += "" + r.Replace(d, "") + " ";
                        if (c == TrackListPos) Menu += "~w~";
                        c++;
                    }
                    Menu += "]";
                }
                if (o== Options.Disciplines)
                {
                    string s = DisciplineFilter.Replace("+", "~g~+");
                     s = s.Replace("-", "~o~-");
                     s = s.Replace("*", "~b~*");
                     s = s.Replace(" ", "~w~ ");
                        Menu +=" ~w~[~y~"+s+"~w~]";
                }


                DrawText(new Vector2(0.02f, 0.2f + zoffset), Menu, Color.White, DrawTextFont.Default, DrawTextAlign.Left, 0.5f);
                Menu = "";
                zoffset += 0.04f;

            }

            Options oSelected = OptionsList[OptionHovered];
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendDown)) OptionHovered++;
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendUp)) OptionHovered--;

            if (OptionHovered < 0) OptionHovered = OptionsList.Count - 1;
            if (OptionHovered > OptionsList.Count - 1) OptionHovered = 0;

            if (Game.IsControlJustPressed(2, GTA.Control.FrontendLeft))
            {
                if (oSelected == Options.GridSize) intendedOpponents--;
                if (oSelected == Options.Laps) SettingsFile.SetValue("GENERAL_SETTINGS", "Laps", SettingsFile.GetValue<int>("GENERAL_SETTINGS", "Laps", 5) - 1);

                if (intendedOpponents < 0) intendedOpponents = 0;
                if (SettingsFile.GetValue("GENERAL_SETTINGS", "Laps", 5) < 1) SettingsFile.SetValue("GENERAL_SETTINGS", "Laps", 5);

                if (oSelected == Options.TrackList) TrackListPos--;
                if (TrackListPos < 0) TrackListPos = FilteredTrackList.Count - 1;

                if (oSelected == Options.Brakepower)
                {
                    
                    ForcedBrakepower -= 0.2f;
                }
                if (oSelected == Options.DebugLevel)
                {
                 //   if (DebugLevel == (int)DebugMode.Inputs) SetSPLVisibility(false);

                    DebugLevel--;
                    if (DebugLevel < 0) DebugLevel = 0;

                    if (DebugLevel == (int)DebugMode.Inputs) SetSPLVisibility(true);

                }
            }
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendRight))
            {
                if (oSelected == Options.TrackList) TrackListPos++;
                if (oSelected == Options.GridSize) intendedOpponents++;
                if (oSelected == Options.Laps) SettingsFile.SetValue("GENERAL_SETTINGS", "Laps", SettingsFile.GetValue<int>("GENERAL_SETTINGS", "Laps", 5) + 1);
                if (TrackListPos > FilteredTrackList.Count - 1) TrackListPos = 0;

                if (oSelected == Options.Brakepower)
                {
                    ForcedBrakepower += 0.2f;
                }
                if (oSelected == Options.DebugLevel)
                {
                    if (DebugLevel == (int)DebugMode.Inputs) SetSPLVisibility(false);

                 if(DebugLevel<7)  DebugLevel++;
                    

                    if(DebugLevel == (int)DebugMode.Inputs) SetSPLVisibility(true);

                }
            }
            if (Game.IsControlJustPressed(2, GTA.Control.FrontendAccept))
            {


                if (oSelected == Options.FindCustomProps)
                {
                    FindCustomProps();
                }
                if(oSelected == Options.Laps)
                {
                    int p = 6;
                    int.TryParse(Game.GetUserInput(4), out p);
                    SettingsFile.SetValue("GENERAL_SETTINGS","Laps", p);
                }
                if (oSelected == Options.GridSize)
                {
                    int p = 6;
                    int.TryParse(Game.GetUserInput(4), out p);
                    intendedOpponents = p;
                }
                if (oSelected == Options.Disciplines)
                {
                    DisciplineFilter = Game.GetUserInput(999);

                    string[] disciplines = DisciplineFilter.Split(' ');
                    string[] aliases = SettingsFile.GetAllValues("GENERAL_SETTINGS", "alias");
                    string[] atags = SettingsFile.GetAllValues("GENERAL_SETTINGS", "tags");
                    for (int d = 0; d < disciplines.Length; d++)
                    {
                        for (int i = 0; i < aliases.Length; i++)
                        {
                            if (aliases[i] == disciplines[d])
                            {

                                disciplines[d] = atags[i];
                                break;
                            }
                        }
                    }
                    DisciplineFilter = string.Join(" ", disciplines);
                }
                if (oSelected == Options.SaveDriverModel)
                {
                    CreateDriver(Game.Player.Character);
                }
                if (oSelected == Options.SaveThisCar)
                {
                    CreateVehicle(Game.Player.Character.CurrentVehicle);
                }
                if (oSelected == Options.TrackList)
                {
                    TrackFilter = Game.GetUserInput(40);
                    ReFilterKnownTracks(TrackFilter);
                }
                if (oSelected == Options.CreateTrack)
                {
                    routeEditMode = true;

                    if (routeEditMode)
                    {
                        RacingLineGuide.Clear();
                        RacingLine.Clear();
                        if (!InFreeCam) ToggleFreeCam();
                        IsDroneMode = false;
                    }
                }
                if (oSelected == Options.ExitCreator)
                {
                    routeEditMode = false;
                    CleanEverything();
                }

                if (oSelected == Options.SaveTrack)
                {
                    UI.ShowSubtitle("Write a name for the track.", 5000);

                    SaveRoute(Game.GetUserInput(30));

                }
                if (oSelected == Options.UpdateTrackFile)
                {
                    //UI.ShowSubtitle("Write a name for the track.", 90000);
                    UpdateRoute(true, true, true);
                    //SaveRoute(Game.GetUserInput(30));

                }
                if (oSelected == Options.StopRace)
                {

                    CleanRacers();

                }
                if (oSelected == Options.LeaveRace)
                {
                    CleanEverything();
                  //  LoadSettings();
                }

                if (oSelected == Options.Start)
                {
                    if (FilteredTrackList.Count > 0)
                    {

                        XmlDocument f = LoadTrackFile(FilteredTrackList[TrackListPos]);//Game.GetUserInput(30)

                        foreach (Vehicle v in World.GetAllVehicles().Where(s => s.Health>0 && s.IsDriveable && s.IsInRangeOf(Game.Player.Character.Position, 30f) &&  !CanWeUse(s.GetPedOnSeat(VehicleSeat.Driver))))
                        {
                            Log(LogImportance.Info, "Added " + v.FriendlyName);
                            Racer RandomRacer = new Racer(v, v.CreateRandomPedOnSeat(VehicleSeat.Driver));
                            Racers.Add(RandomRacer);
                        }

                        LoadTrack(f);
                        LoadGrid(DisciplineFilter, (int)Clamp( intendedOpponents-Racers.Count, 0, GridPositions.Count));//Game.GetUserInput(128).ToLowerInvariant()


                        
                        StartRace();
                       if(CanWeUse(Game.Player.Character.CurrentVehicle)) HelpMessages.Add("Rev up your engine to start the countdown.");
                    }
                    else
                    {
                        UI.Notify("~r~No track selected.");
                    }
                    
                }
                if (oSelected == Options.StartRace)
                {
                    LoadGrid(DisciplineFilter, intendedOpponents);//Game.GetUserInput(128).ToLowerInvariant()

                    StartRace();
                    
                }
                if (oSelected == Options.Freecam)
                {
                    ToggleFreeCam();
                }
                if (oSelected == Options.RestartRace)
                {
                    if (Racers.Count > 0)
                    {
                        GametimeCountDown = 0;
                        SetupRace(true, false);
                        StartCoundown();
                    }
                }
                
                if (oSelected == Options.Brakepower)
                {
                    foreach (Racer r in Racers) r.mphStopInTenMeters = ForcedBrakepower;
                    UI.Notify("Forced " + ForcedBrakepower + " expected brakepower on all racers.");
                }
                

                //Exits the menu any time an option is applied, exept the TrackNameFilter input.
                if (!(new List<Options> { Options.Laps, Options.GridSize, Options.TrackList, Options.Disciplines }.Contains(OptionsList[OptionHovered])))
                {
                    if (oSelected == Options.DebugLevel)
                    {
                        if (DebugLevel == (int)DebugMode.PropEdit)
                        {
                            HelpMessages.Add("The ~b~Prop Edit~w~ mode lets you modify which props will be saved along the route.");
                            HelpMessages.Add("Props marked in ~g~green~w~ are considered part of the route.");
                            HelpMessages.Add("Remember to update the current route on the menu after you're finished.");
                        }
                        if (DebugLevel == (int)DebugMode.RacingLineEdit)
                        {
                            HelpMessages.Add("The ~y~Racing Line Edit~w~ mode lets you define a racing line along the route.");
                            HelpMessages.Add("The RL operates on ~y~guides~w~, which let you only define a couple key points.");
                            HelpMessages.Add("Navigate the nodes using the up/down arrows and edit them using left or right.");
                            HelpMessages.Add("You can delete the current node with the Delete key.");
                        }
                    }

                  //  if (SettingsFile != null) SettingsFile.Save();
                   // if (DevSettingsFile != null) DevSettingsFile.Save();
                    OptionsList.Clear(); //

                }
            }
        }
       public static float MStoMPH(float ms)
        {
            return ms * 2.236936f;
        }
        public static float MPHtoMS(float mph)
        {
            return mph * 0.44704f;
        }
        void CleanEverything()
        {
            CleanRacers();

            foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();

            RacingLineGuide.Clear();
            RacingLine.Clear();

            WideDict.Clear();
            EditWideDict.Clear();
            Path.Clear();

            foreach (int fx in FlareFX) Function.Call(Hash.STOP_PARTICLE_FX_LOOPED, fx);
            FlareFX.Clear();
            LeaderboardFinish.Clear();
            routeEditMode = false;
            TimeToFinishRace = 0;

            foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
            
            Angles.Clear();
            Path.Clear();
            WideDict.Clear();

            RaceStatus = RaceState.None;
        }
        //Wheelspin turbulence
        float wheelspin = 0f;
        void HandlePlayerDebugStuff()
        {
            //Generates camera shake if youre wheels are suffering wheelspin.
            return;
            Vehicle v = Game.Player.Character.CurrentVehicle;

            if (CanWeUse(v))
            {
                
                float newwheelspin = GetWheelsAvgWheelspin(v);
                if (newwheelspin > wheelspin)
                {
                    if (newwheelspin > wheelspin + 1.3f) wheelspin += 1.3f; else wheelspin = newwheelspin;
                }
                else
                {
                    if (newwheelspin < wheelspin - 1.3f) wheelspin -= 1.3f; else wheelspin = newwheelspin;
                }
                if (Math.Abs(wheelspin) > 0f)
                {
                    GameplayCamera.Shake(CameraShake.Jolt, -wheelspin * 0.02f);
                    //Function.Call(Hash._0xF4C8CF9E353AFECA, "JOLT_SHAKE", Math.Abs(wheelspin * 0.005f));
                    Function.Call(Hash.SHAKE_CINEMATIC_CAM, "JOLT_SHAKE", -wheelspin * 0.02f);
                }
            }
        }


        void DrawBlackBars(float intensity)
        {
            Function.Call(Hash.DRAW_RECT, 0.5f, 0f, 1f, intensity, 0f, 0f, 0f, 255, 0f);
            Function.Call(Hash.DRAW_RECT, 0.5f, 1f, 1f, intensity, 0f, 0f, 0f, 255, 0f);
        }
        int playerdebuggametime = 0;


        List<Vector3> MiniaturizedPath = new List<Vector3>();
        void DrawMiniaturizedPath(Vector3 pos)
        {
            if (!Game.Player.Character.IsInRangeOf(pos, 20f)) return;
            if (Path.Count > 0)
            {
                if (MiniaturizedPath.Count == 0)
                {
                    Vector3 middle = Vector3.Zero;
                    foreach (Vector3 posp in Path) middle += posp;
                    middle /= Path.Count;
                    int c = (int)(Path.Count * 0.1f);
                    Vector3 newpos = (Path[4]) - middle;
                    foreach (Vector3 modded in Path)
                    {
                        c++;
                        if (c >= 15)
                        {
                            c = 0;

                            Vector3 lerped = Vector3.Lerp(middle, modded, 0.005f);
                            MiniaturizedPath.Add(lerped);

                        }
                    }
                }
                else
                {
                    Vector3 modified = (pos - MiniaturizedPath[0]);
                    Vector3 last = MiniaturizedPath[MiniaturizedPath.Count - 1];
                    foreach (Vector3 vm in MiniaturizedPath)
                    {

                        if (vm == MiniaturizedPath[0])
                        {
                            World.DrawMarker(MarkerType.CheckeredFlagRect, vm + modified, (last - vm).Normalized, new Vector3(0, 0, 0), new Vector3(0.1f, 0.1f, 0.1f), Color.White);// DrawLine(vm,last, Color.Black);
                        }
                        else
                        {
                            DrawLine(vm + modified, last + modified, Color.SkyBlue);
                        }
                        last = vm;
                    }

                }



                //     DrawLine(MiniaturizedPath[0], Game.Player.Character.Position+new Vector3(0,0,3), Color.Red);
                //  DrawPath(MiniaturizedPath, null, 1);
                //foreach(Vector3 final in mini) DrawLine(final, Game.Player.Character.Position, Color.Red);
            }
        }
        int RLineNode = 20;



        void HandleRacingLineEditor()
        {
            if ((DebugMode)DebugLevel != DebugMode.RacingLineEdit) return;
            DisplayHelpText("Edit the white guides to adjust the racing line. You can create new guides moving left or right.");

            if (RLineNode > RacingLine.Count - 1) RLineNode = 0;
            if (RLineNode < 0) RLineNode = 0;
            if (OptionsList.Count == 0)
            {
                if (Game.IsControlJustPressed(2, GTA.Control.FrontendDelete))
                {
                    if (RacingLineGuide.ContainsKey(RLineNode)) RacingLineGuide.Remove(RLineNode);
                    ReGenerateLines();

                    return;
                }
                if (Game.IsControlJustPressed(2, GTA.Control.FrontendLeft))
                {
                    if (!RacingLineGuide.ContainsKey(RLineNode)) RacingLineGuide.Add(RLineNode, 0.0f);
                    else RacingLineGuide[RLineNode] -= 1f;
                    ReGenerateLines();
                    return;
                }
                if (Game.IsControlJustPressed(2, GTA.Control.FrontendRight))
                {
                    if (!RacingLineGuide.ContainsKey(RLineNode)) RacingLineGuide.Add(RLineNode, 0.0f);
                    else RacingLineGuide[RLineNode] += 1f;
                    //  RacingLineGuide[RLineNode] = (float)Math.Round(RacingLineGuide[RLineNode], 1, MidpointRounding.AwayFromZero);
                    ReGenerateLines();
                    return;
                }

                if (Game.IsControlJustPressed(2, GTA.Control.FrontendUp))
                {
                    if (!Game.IsControlPressed(2, GTA.Control.CharacterWheel)) RLineNode++; else RLineNode += 5;
                    if (Game.IsControlPressed(2, GTA.Control.Sprint)) while (!RacingLineGuide.ContainsKey(RLineNode) && RLineNode < RacingLine.Count - 1) RLineNode++;                 
                }

                if (Game.IsControlJustPressed(2, GTA.Control.FrontendDown))
                {
                    if (!Game.IsControlPressed(2, GTA.Control.CharacterWheel)) RLineNode--; else RLineNode -= 5;
                    if (Game.IsControlPressed(2, GTA.Control.Sprint)) while (!RacingLineGuide.ContainsKey(RLineNode) && RLineNode > 0) RLineNode--;                                      
                }
            }
        }

        //Re-assigns an ideal racing line offset to each route node, based on the guides dotted around the track.
        public static void ReGenerateLines()
        {
            float offset = 0f;
            RacingLine.Clear();

            for (int node = 0; node < RacingLineGuide.Count - 1; node++)
            {
                if (RacingLineGuide.ContainsKey(node))
                {
                    float d = RacingLineGuide[node];
                    d = (float)Math.Round(d, 0);
                    RacingLineGuide[node] = d;
                }
            }

            int oldn = 0;
            for (int node = 0; node < Path.Count - 1; node++)
            {

                if (RacingLineGuide.ContainsKey(node))
                {
                    int frecuency = node - oldn;
                    oldn = node;
                    float added = (float)Math.Round(RacingLineGuide[node], 0);
                    if (node == 0) added = 0;
                    int count = RacingLine.Count;

                    float oldoff = 0;
                    if (RacingLine.Count > 0)
                    {
                        oldoff = (float)Math.Round(RacingLine.Values.Last(), 0);
                        offset = oldoff;
                    }

                    for (int e = count; e < count + frecuency; e++)
                    {

                        offset = map(e, count, count + frecuency, oldoff, added);

                        offset = (float)Math.Round(offset, 3);
                        RacingLine.Add(e, offset);
                    }
                }
            }
        }
        int GameTimeShort = Game.GameTime;
        bool Shaking = false;

        void OnTick(object sender, EventArgs e)
        {
                
            if (!Loaded)
            {
                if(DevSettingsFile.GetValue<bool>("GENERAL", "LoadAtStart", true) || WasCheatStringJustEntered("arson"))
                {
                    LoadScript();

                }
                
                return;
            }

            Vehicle v = Game.Player.Character.LastVehicle;
            if (CanWeUse(v))
            {
                
                if (steeroffset == 0) SetTrueSteer(v, 0f);
                if (throttleOffset == 0) SetThrottle(v, 0f);
                if (brakeOffset == 0) SetBrakes(v, 0f);
            }


            IsShiftOn = false;
            if (Game.IsControlPressed(2, GTA.Control.Sprint))
            {
                IsShiftOn = true;
            }


            HandleTrackCreator();


            if (DebugLevel == (int)DebugMode.Route || DebugLevel == (int)DebugMode.RacingLineEdit || routeEditMode)
            {
                DrawPath(Path, WideDict, PathDisplayFidelity);
            }




            //Priority, anticrash checks
            if (!CanWeUse(FreecCamRide))
            {
                FreecCamRide = World.CreateProp("ba_prop_battle_drone_quad_static", Game.Player.Character.Position + new Vector3(0, 0, 10), true, false);//prop_wheel_tyre
                                                                                                                                                         //FreecCamRide.IsPersistent = false;
               if(CanWeUse(FreecCamRide)) FreecCamRide.HasGravity = false;
                Log(LogImportance.Error, "Freecam object not found, creating a new one.");
            }
            HandleFreecam();


            //Drawing and GUI stuff
            if (TimeToFinishRace != 0 && TimeToFinishRace>Game.GameTime) DisplayHelpText("~y~"+(TimeToFinishRace - Game.GameTime) / 1000+"s~w~ to end the race.");
            HandleRacingLineEditor();
            if (DebugLevel == (int)DebugMode.PropEdit) foreach (Prop p in CustomProps) if (CanWeUse(p) && p.IsInRangeOf(Game.Player.Character.Position, 100f)) World.DrawMarker(MarkerType.ReplayIcon, p.Position + new Vector3(0, 0, p.Model.GetDimensions().Z + 2f), Vector3.Zero, p.Rotation, new Vector3(2, 2, 2), Color.Green);// DrawLine(p.Position, Path[ClosestNodeToPlace(p.Position, Path)]+new Vector3(0,0,0.5f), Color.Red);


            if (Path.Count > 0 && !HideHudMode && (routeEditMode || DebugLevel == (int)DebugMode.Inputs))
            {
                foreach (int inode in SPDLimiter.Keys)
                {
                    if (PlayerOrCameraNearPos(Path[inode], 25f))
                    {
                        float mult = SPDLimiter[inode];
                        DrawText(Path[inode] + new Vector3(0, 0,   2), "Multiplier:~n~~y~" + mult.ToString(), Color.White, 0.4f);
                    }
                }
            }

            //Scaleforms
            if (SCCountdown.IsLoaded)  SCCountdown.Render2D();

            //Info & Tips
            if (DebugLevel == (int)DebugMode.PropEdit) DisplayHelpTextThisFrame("Add or remove any ~g~prop~w~ with the tool of your prefence. They must be ~y~persistent~w~.");



            if (listenmode)
            {
                if(Game.IsControlJustPressed(2, GTA.Control.Jump))
                {
                    Vehicle playerVeh = Game.Player.Character.CurrentVehicle;
                    if (CanWeUse(playerVeh)) CreateVehicle(playerVeh, true);
                }
            }
            



            //Timescale control
            if (GameTimeShort < Game.GameTime)
            {
                GameTimeShort = Game.GameTime + 50;
              
                if (TimeScale > IdealTimeScale)
                {
                    TimeScale -= 0.01f;
                    if (TimeScale < IdealTimeScale) TimeScale = IdealTimeScale;
                    TimeScale = (float)Math.Round(TimeScale, 12);
                    Game.TimeScale = TimeScale;
                }
                if (TimeScale < IdealTimeScale)
                {
                    TimeScale += 0.1f;
                    if (TimeScale > IdealTimeScale) TimeScale = IdealTimeScale;
                    TimeScale = (float)Math.Round(TimeScale, 2);
                    Game.TimeScale = TimeScale;
                }
            }


            //Never really used
            if (Path.Count > 20 && MiniMap != Vector3.Zero) DrawMiniaturizedPath(MiniMap);


            
            
            //Prevents the world from generating population. The AI cannot handle traffic yet
            
            if ( (routeEditMode || Path.Count>0)  && DevSettingsFile.GetValue("GENERAL_SETTINGS", "Traffic", false) ==false)// Path.Count > 0 ||
            {
                Function.Call(Hash.SET_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
                Function.Call(Hash.SET_RANDOM_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
                Function.Call(Hash.SET_PARKED_VEHICLE_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
                if (Racers.Count() > 0) Function.Call(Hash._0x90B6DA738A9A25DA, 0f); //Actively forces deletion of anything unwanted
                Function.Call(Hash.SET_PED_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
                Function.Call(Hash.SET_SCENARIO_PED_DENSITY_MULTIPLIER_THIS_FRAME, 0f);
            }
            

            //???
            if (playerdebuggametime < Game.GameTime)
            {
                playerdebuggametime = Game.GameTime + 50;
                HandlePlayerDebugStuff();
            }

            //Create the menu on key inputs
            if (OptionsList.Count == 0)
            {
                if (Game.IsControlPressed(2, GTA.Control.Sprint) && Game.IsControlPressed(2, GTA.Control.Context))
                {

                    if (routeEditMode)
                    {
                        OptionsList.Add(Options.SaveTrack);
                        OptionsList.Add(Options.ExitCreator);
                    }
                    else
                    {
                        if (Path.Count == 0)
                        {
                            OptionsList.Add(Options.TrackList);
                            OptionsList.Add(Options.Disciplines);
                            OptionsList.Add(Options.GridSize);
                            OptionsList.Add(Options.Laps);
                            OptionsList.Add(Options.Start);

                            if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "AdvOptions", true))
                            {
                                OptionsList.Add(Options.CreateTrack);
                                if (CanWeUse(Game.Player.Character.CurrentVehicle))
                                {
                                    OptionsList.Add(Options.SaveThisCar);
                                 //   OptionsList.Add(Options.SaveDriverModel);
                                }                                
                            }
                        }
                        else
                        {
                            if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "AdvOptions", true)) OptionsList.Add(Options.DebugLevel);

                            if (Racers.Count==0)
                            {
                                OptionsList.Add(Options.Disciplines);
                                OptionsList.Add(Options.StartRace);
                                OptionsList.Add(Options.GridSize);
                                OptionsList.Add(Options.Laps);
                            }
                            OptionsList.Add(Options.LeaveRace);

                            if (RaceStatus > RaceState.NotInitiated)
                            {
                                OptionsList.Add(Options.RestartRace);

                            }

                            
                            
                            if (DebugLevel==(int)DebugMode.RacingLineEdit)
                              {
                                    OptionsList.Add(Options.UpdateTrackFile);
                                    
                            }
                            if (DebugLevel == (int)DebugMode.PropEdit)
                            {
                                OptionsList.Add(Options.FindCustomProps);
                                OptionsList.Add(Options.UpdateTrackFile);

                            }
                        }
                    }
                    OptionsList.Add(Options.Freecam);
                }
            }
            else
            {
                if (Game.IsControlJustPressed(2, GTA.Control.FrontendCancel))
                {
                    if (OptionsList[OptionHovered] == Options.DebugLevel)
                    {
                        if (DebugLevel == (int)DebugMode.PropEdit)
                        {
                            HelpMessages.Add("The ~b~Prop Edit~w~ mode lets you modify which props will be saved along the route.");
                            HelpMessages.Add("Props marked in ~g~green~w~ are considered part of the route.");
                            HelpMessages.Add("Remember to update the current route on the menu after you're finished.");
                        }
                        if (DebugLevel == (int)DebugMode.RacingLineEdit)
                        {
                            HelpMessages.Add("The ~y~Racing Line Edit~w~ mode lets you define a racing line along the route.");
                            HelpMessages.Add("The RL operates on ~y~guides~w~, which let you only define a couple key points.");
                            HelpMessages.Add("Navigate the nodes using the up/down arrows and edit them using left or right.");
                            HelpMessages.Add("You can delete the current node with the Delete key.");
                        }
                    }
                    OptionsList.Clear();
                    SetSPLVisibility(false);

                }
                else
                {
                    HandleMenu();
                }
            }

            
            //Lighting
            if (Path.Count > 0 && TrackLimits.Count > 0 && 1==2)
            {
                if (CountDown < 5)
                {
                    Prop p = TrackLimits[0];
                    Vector3 pbase = p.Position + (p.UpVector * (p.Model.GetDimensions().Z - 1f) + (p.ForwardVector * ((p.Model.GetDimensions().Y * 0.5f) + 0.2f)));
                    Vector3 leftmost = Vector3.Zero;
                    Vector3 left = Vector3.Zero;
                    Vector3 right = Vector3.Zero;
                    Vector3 rightmost = Vector3.Zero;
                    Color c = Color.Red;
                    switch (CountDown)
                    {
                        default:
                            {
                                c = Color.Red;
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);

                                rightmost = pbase + (p.RightVector * -0.45f);
                                break;
                            }
                        case 5:
                            {
                                break;
                            }
                        case 4:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);
                                break;
                            }
                        case 3:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);
                                break;
                            }
                        case 2:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);
                                break;
                            }
                        case 1:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);

                                rightmost = pbase + (p.RightVector * -0.45f);
                                break;
                            }
                        case 0:
                            {
                                leftmost = pbase + (p.RightVector * 0.45f);

                                left = pbase + (p.RightVector * 0.15f);

                                right = pbase + (p.RightVector * -0.15f);

                                rightmost = pbase + (p.RightVector * -0.45f);
                                leftmost.Z -= 0.3f;
                                left.Z -= 0.3f;
                                right.Z -= 0.3f;
                                rightmost.Z -= 0.3f;
                                c = Color.Green;
                                break;
                            }
                    }

                    if (leftmost != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, leftmost, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(leftmost, c, 0.4f, 1f);
                    }


                    if (left != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, left, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(left, c, 0.4f, 1f);
                    }
                    if (right != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, right, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(right, c, 0.4f, 1f);
                    }
                    if (rightmost != Vector3.Zero)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, rightmost, Vector3.Zero, Vector3.Zero, new Vector3(0.05f, 0.05f, 0.05f), c, false, false, 0, false, "", "", false);
                        World.DrawLightWithRange(rightmost, c, 0.4f, 1f);
                    }
                }

            }


            //Handle the countdown
            if (RaceStatus != RaceState.Countdown && GametimeCountDown - Game.GameTime > 5000) CountDown = MaxCountDown-1;
            if (RaceStatus == RaceState.NotInitiated)
            {
                if (CanWeUse(Game.Player.Character.CurrentVehicle))
                {
                if ((Game.IsControlJustPressed(2, GTA.Control.VehicleAccelerate)))    StartCoundown();
                }
                else StartCoundown();

            }


            if (GametimeCountDown < Game.GameTime)
            {
                GametimeCountDown = Game.GameTime + 1000;



                if (Path.Count > 0 && DebugLevel >= (int)DebugMode.None)
                {
                    SPDLimiter.Clear();
                    foreach (Prop p in World.GetAllProps()) if (p.Model == "prop_mp_max_out_lrg")
                        {
                            int node = ClosestNodeToPlace(p.Position, Path);
                            if (!SPDLimiter.ContainsKey(node))
                            {
                                float m = 1+((p.HeightAboveGround - 5f)*0.1f);
                                SPDLimiter.Add(node, (float)Math.Round(m, 1));
                            }
                        }
                }

                //While the countdown is on, you can enter the opponents' vehicles
                Vehicle jack = Game.Player.Character.GetVehicleIsTryingToEnter();
                if (Racers.Count>0 && CanWeUse(jack) && jack != Game.Player.Character.LastVehicle  && jack.Handle == Racers.OrderBy(c => c.Car.Position.DistanceTo(Game.Player.Character.Position)).ToList()[0].Car.Handle)
                {
                    Game.Player.Character.SetIntoVehicle(jack, VehicleSeat.Passenger);
                }

                if (RaceStatus == RaceState.Countdown)
                {
                    foreach (Racer r in Racers) r.BaseBehavior = RacerBaseBehavior.GridWait;
                    CountDown--;
                    if (CountDown <= 3)
                    {
                        if (CountDown == 3) foreach (Racer r in Racers) if (r.Car.HasRoof && r.Car.RoofState== VehicleRoofState.Closed) r.Car.RoofState = VehicleRoofState.Opening; //Function.Call(Hash.SET_VEHICLE_ENGINE_ON, r.Car, true, false, false);

                        
                        Game.PlaySound("3_2_1", "HUD_MINI_GAME_SOUNDSET");
                        
                        if(CountDown==0) SCCountdown.CallFunction("SHOW_SHARD_CENTERED_TOP_MP_MESSAGE", "GO", "", (int)12, (int)2);
                        else SCCountdown.CallFunction("SHOW_SHARD_CENTERED_TOP_MP_MESSAGE", CountDown, "", (int)12, (int)2);

                        if (CountDown == 0)
                        {
                            
                            SCCountdown.CallFunction("TRANSITION_OUT", 0.6f);
                        }
                    }

                    if (CountDown <= 0)
                    {
                        foreach (Racer r in Racers)
                        {
                            r.Launch();
                           
                           
                           
                        }
                        CountDown = MaxCountDown;
                        RaceStatus = RaceState.InProgress;
                    }
                }
            }
            
            
            //Where the magic happens.
            foreach (Racer racer in Racers)
            {
                racer.ProcessTick();
                if ((racer.Lap > SettingsFile.GetValue("GENERAL_SETTINGS","Laps", 5)) && !LeaderboardFinish.Contains(racer))
                {
                   if(racer.Car.CurrentBlip!=null) racer.Car.CurrentBlip.Color = BlipColor.Green;

                    LeaderboardFinish.Add(racer);
                    racer.BaseBehavior = RacerBaseBehavior.FinishedRace;
                    if (IsPointToPoint) racer.BaseBehavior = RacerBaseBehavior.FinishedStandStill;
                    if (TimeToFinishRace == 0) TimeToFinishRace = Game.GameTime + (30*1000);
                }
            }


            //Handle the racing positions
            if (GameTimeRef < Game.GameTime)
            {
                GameTimeRef = Game.GameTime + 200;
                GlobalTraffic = World.GetAllVehicles().ToList();
                foreach (Racer r in ARS.Racers) if (GlobalTraffic.Contains(r.Car)) GlobalTraffic.Remove(r.Car);

                List<Racer> LapPos = new List<Racer>();
                List<Racer> RPositions = Racers;
                if (Racers.Count > 0)
                {
                    RPositions = RPositions.OrderBy(d => d.Lap).Reverse().ToList();
                    int L = RPositions[0].Lap;

                    int pos = 1;

                    while (pos < Racers.Count - 1)
                    {
                        LapPos = RPositions.Where(vl => vl.Lap == L).ToList();
                        LapPos = LapPos.OrderBy(vl => vl.CurrentNode).Reverse().ToList();
                        foreach (Racer r in LapPos)
                        {
                            r.Pos = pos;
                            pos++;
                        }
                        L--;

                    }
                }
                Racers = Racers.OrderBy(vl => vl.Pos).ToList();
            }

            //Configure the leaderboard and handle lapping logic
            List<string> positions = new List<string>();
            if (LeaderboardFinish.Count > 0)
            {

                if(TimeToFinishRace!=0 && Game.GameTime > TimeToFinishRace)
                {
                    if (LeaderboardFinish[0].Driver.IsPlayer) Game.Player.Money += RaceReward;
                    RaceStatus = RaceState.Finished;
                }
                foreach (Racer r in LeaderboardFinish)
                {
                    int totaltime = 0;
                    int count = 0;
                    if (r.LapTimes.Count > 0)
                    {
                        foreach (int i in r.LapTimes)
                        {
                            int time = 0;
                            if (count == 0) time = i - r.StartTime; else time = i - r.LapTimes[count - 1];
                            totaltime += time;
                            count++;
                        }
                    }
                    else
                    {
                        if (r.StartTime != 0)
                        {
                            totaltime = Game.GameTime - r.StartTime;
                        }
                    }
                    TimeSpan ttt = new TimeSpan();
                    ttt = TimeSpan.FromMilliseconds(totaltime);
                    string fTime = ttt.ToString("m':'ss'.'f"); //"mm':'ss'.'fff"
                    if (r.Driver.IsPlayer) positions.Add("~g~" + r.Pos + "º~w~ " + r.Name + " T" + fTime + "~n~");
                    else positions.Add("~y~" + r.Pos + "º~w~ " + r.Name + " T" + fTime + "~n~");
                }
                if (LeaderboardFinish.Count == Racers.Count)
                {
                    if (LeaderboardFinish[0].Driver.IsPlayer) Game.Player.Money += RaceReward;
                    
                    RaceStatus = RaceState.Finished;

                }
            }
            else
            {
                if (Game.IsControlPressed(2, GTA.Control.Sprint))
                {
                    foreach (Racer r in Racers)
                    {
                        int totaltime = 0;

                        if (r.LapTimes.Count > 0)
                        {
                            totaltime = Game.GameTime - r.LapTimes.Last();
                        }
                        else
                        {
                            if (r.StartTime != 0)
                            {
                                totaltime = Game.GameTime - r.StartTime;
                            }
                        }
                        TimeSpan ttt = new TimeSpan();
                        ttt = TimeSpan.FromMilliseconds(totaltime);
                        string fTime = ttt.ToString("m':'ss'.'f"); //"mm':'ss'.'fff"
                        if (r.Driver.IsPlayer) positions.Add("~g~" + r.Pos + "º~g~ " + r.Name + " T" + fTime + "~n~");
                        else positions.Add("~b~" + r.Pos + "º~w~ " + r.Name + " T" + fTime + "~n~");
                    }
                }
                else
                {
                    foreach (Racer r in Racers)
                    {

                        if (r.Driver.IsPlayer) positions.Add("~g~" + r.Pos + "º~g~ " + r.Name + " ~w~L" + r.Lap + "~n~~w~");
                        else positions.Add("~b~" + r.Pos + "º~w~ " + r.Name + "~n~~w~");

                    }
                }
            }


            //Draw the leaderboard positions
            if (positions.Count > 0 && !HideHudMode && OptionsList.Count==0)
            {
                float or = 0.25f;
                float z = 0.15f;
                float scale = 0.4f;

                float height = scale * 0.06f;
                float width = 0f;
                Vector2 point = new Vector2(0.016f, 0.008f);
                foreach (string st in positions)
                {
                    float w = DrawText(point + new Vector2(0f, z), "~u~" + st, Color.White, DrawTextFont.Default, DrawTextAlign.Left, scale);
                    if (w > width) width = w;
                    z += scale * 0.06f;
                }
                //Function.Call(Hash.DRAW_RECT, point.X + (width * 0.15f) - 0.016f, point.Y+(or*0.5f) + (point.Y * 0.5f) + (z * 0.5f), ((width) * 0.25f), (z-or) + 0.008f, 0f, 0f, 0f, 100, 0f);
            }

            if (GametimerefLong < Game.GameTime)
            {
                GametimerefLong = Game.GameTime + 3000;
                if (HelpMessages.Count > 0 && !HideHudMode)
                {
                    if (!Function.Call<bool>(Hash.IS_HELP_MESSAGE_BEING_DISPLAYED))
                    {
                        DisplayHelpTextTimed(HelpMessages[0], (int)(HelpMessages[0].Length * 120));
                        HelpMessages.RemoveAt(0);
                    }
                }
            }


            Cheats();

            if (RaceStatus == RaceState.Finished) CleanEverything();
        }

        public void ToggleSPLVisibility()
        {
            foreach (Prop p in World.GetAllProps()) if (p.Model == "prop_mp_max_out_lrg") if (p.Alpha == 0) p.Alpha = 255; else p.Alpha = 0;
        }

        public void SetSPLVisibility(bool state)
        {
            foreach (Prop p in World.GetAllProps()) if (p.Model == "prop_mp_max_out_lrg") if (state) p.Alpha = 255; else p.Alpha = 0;
        }
        bool InFreeCam = false;
        void HandleTrackCreator()
        {

            //Visuals
            int Cool = -1; //If cool, the track is closed, no need to render more

            if (Path.Count > 50)
            {
                if (temp.Count > 0)
                {
                    Vector3 last = temp[temp.Count - 1];
                    if (Path[Path.Count - 1].DistanceTo(Path[0]) < 20f)
                    {
                        if (Path[0].DistanceTo(Path[Path.Count - 1]) < 2f)
                        {
                            Cool = 1;
                            DrawLine(Path[Path.Count - 1], Path[0], Color.Green);
                        }
                        else
                        {
                            Cool = 0;
                            DrawLine(Path[Path.Count - 1], Path[0], Color.Red);
                        }
                    }
                    if (Cool < 1 && last.DistanceTo(Path[0]) < 20f)
                    {
                        World.DrawMarker(MarkerType.DebugSphere, last + new Vector3(0, 0, 0.2f), Vector3.Zero, Vector3.Zero, new Vector3(0.5f, 0.5f, 0.5f), Color.Blue);
                        World.DrawMarker(MarkerType.DebugSphere, Path[0] + new Vector3(0, 0, 0.2f), Vector3.Zero, Vector3.Zero, new Vector3(0.5f, 0.5f, 0.5f), Color.Black);
                        if (last.DistanceTo(Path[0]) > 2f)
                        {

                            DrawLine(last + new Vector3(0, 0, 0.2f), Path[0] + new Vector3(0, 0, 0.2f), Color.Red);
                        }
                        else
                        {
                            DrawLine(last + new Vector3(0, 0, 0.2f), Path[0] + new Vector3(0, 0, 0.2f), Color.Green);
                        }
                    }
                }
            }
            if (Cool < 1) DrawSection(temp, EditWideDict);

            //Creating the track
            if (routeEditMode && InFreeCam)
            {
                if (wide < 1) wide = 1;
                if (scale < 5f) scale = 5f;
                RaycastResult ray = World.Raycast(GameplayCamera.Position, GameplayCamera.Position + ((GameplayCamera.Direction.Normalized) * 100), IntersectOptions.Everything);

                //Already started
                if (Path.Count > 0)
                {
                    if (Cool == -1) DisplayHelpTextThisFrame("Create the rest of the route. ~n~- Looped: ~b~Circuit~n~~w~- Open: ~b~Point to Point");
                    if (Cool == 0) DisplayHelpTextThisFrame("Close the circuit near the ~b~Start Line.");
                    if (Cool == 1) DisplayHelpTextThisFrame("~g~The circuit is closed.");


                    //Controls
                    if (Game.IsControlJustPressed(2, GTA.Control.NextWeapon))
                    {
                        if (!Game.IsControlPressed(2, GTA.Control.Sprint)) scale -= 5f; else wide--;
                    }
                    if (Game.IsControlJustPressed(2, GTA.Control.PrevWeapon))
                    {
                        if (!Game.IsControlPressed(2, GTA.Control.Sprint)) scale += 5f; else wide++;
                    }
                    if (Game.IsControlJustPressed(2, GTA.Control.Aim))
                    {          
                        if (Path.Count > 2) 
                        {
                            if (IsShiftOn)
                            {
                                int i = 0;
                                while (i < 10)
                                {
                                    if (Path.Count == 0) break;
                                    Path.RemoveAt(Path.Count - 1);
                                    i++;
                                }
                            }
                            else
                            {
                                Path.RemoveAt(Path.Count - 1);
                            }
                        }
                        else
                        {
                            Path.Clear();
                            return;
                        }
                    }

                    //Add section
                    if (Game.IsControlJustPressed(2, GTA.Control.Attack) && Cool < 1)
                    {
                        for (int i = 1; i < temp.Count; i++)
                        {
                            Path.Add(temp[i]);
                        }
                    }
                }
                else //Placing the Start Line
                {
                    DisplayHelpTextThisFrame("Place the ~b~Start Line.");

                    if (Game.IsControlJustPressed(2, GTA.Control.NextWeapon)) wide--;
                    if (Game.IsControlJustPressed(2, GTA.Control.PrevWeapon)) wide++;

                }



                //Section rendering
                if (Path.Count > 1)
                {
                    if (ray.DitHitAnything && Cool < 1)
                    {

                        Vector3 projection = Vector3.Lerp(Path[Path.Count - 2], Path[Path.Count - 1], Path[Path.Count - 2].DistanceTo(ray.HitCoords)*0.5f);

                        //Reference marker
                        World.DrawMarker(MarkerType.DebugSphere, ray.HitCoords, Vector3.Zero, -Vector3.WorldDown, new Vector3(0.25f, 0.25f, 0.25f), Color.Blue);
                      
                        float projectedD = projection.DistanceTo(Path[Path.Count - 1]);

                        Vector3 start = (Path[Path.Count - 2] - Path[Path.Count - 1]).Normalized * (projectedD); //( v.Position -Path[Path.Count-1] ).Normalized

                        Vector3 end = ((ray.HitCoords ) - projection).Normalized * (projectedD);

                        Vector3 control = new Vector3(0f,0f,0f);

                        DrawLine(start+ projection, projection, Color.Black);
                        DrawLine(end+ projection, projection, Color.Black);

                        int divided = 100;
                        float ddc = 0f;

                        Vector3 oldp = Path[Path.Count - 1];
                        temp.Clear();
                        Vector3 oldDir = (Path[Path.Count - 1] - Path[Path.Count - 2]).Normalized;
                        if (divided == 0) return;

                        float step = (1 / end.DistanceTo(start)) ;

                        float increasingstep = 0;
                      //  UI.ShowSubtitle(Math.Round(step, 3).ToString(), 100);
                        int p = 0;
                        float offset = 0;

                        while (increasingstep<1f && p<2000)
                        {
                            p++;

                            if (1 == 1)
                            {

                                Vector3 b = projection + Bezier2(start, control, end, increasingstep);
                                Vector3 bd = projection + Bezier2(start, control, end, increasingstep+offset);

                                int tries = 0;
                                while (b.DistanceTo(bd) < 1.0000f && tries<1000)
                                {
                                    tries++;
                                    offset += 0.001f;
                                    bd = projection + Bezier2(start, control, end, increasingstep + step + offset);
                                }

                                while (b.DistanceTo(bd) > 1.0000f && tries < 1000)
                                {
                                    tries++;
                                    offset -= 0.001f;
                                    bd = projection + Bezier2(start, control, end, increasingstep + step + offset);
                                }
                                increasingstep += step;
                                float distpr = b.DistanceTo(bd);

                                if (!Game.IsControlPressed(2, GTA.Control.Sprint))
                                {
                                    RaycastResult DSAD = World.Raycast(bd + new Vector3(0, 0, 2f), bd + (Vector3.WorldDown * 30f), IntersectOptions.Map);
                                    if (DSAD.DitHitAnything) bd.Z = DSAD.HitCoords.Z;
                                }
                                Vector3 oldDirection = Vector3.Zero;
                                Vector3 oldplace = Path[Path.Count - 1];
                                if (temp.Count < 1)
                                {
                                    oldDirection = (Path[Path.Count - 1] - Path[Path.Count - 2]).Normalized;
                                    oldplace = Path.Last();
                                }
                                else
                                {
                                    oldplace = temp.Last();

                                    if (temp.Count == 1)
                                    {
                                        oldDirection = (temp[0] - Path[Path.Count - 1]).Normalized;
                                    }
                                    else
                                    {
                                        oldDirection = (temp[temp.Count - 1] - temp[temp.Count - 2]).Normalized;
                                    }

                                }

                                Vector3 currentDir = (bd - oldplace).Normalized;

                                oldDir = currentDir;
                                Color chevcolor = Color.FromArgb(50, Color.Red);
                                Color chevcolorr = Color.FromArgb(50, Color.SkyBlue);
                                
                               // DrawLine(bd, Vector3.Lerp( bd, bd+ oldDir, 3f), Color.White);

                                oldDirection.Z = 0f;
                                currentDir.Z = 0f;

                                float ang = (float)Math.Round(Vector3.SignedAngle(oldDirection, currentDir, Vector3.WorldUp), 1);
                                if (ang / 1 != ang) ang = 0f;
                                string pref = "~g~";


                                float mappedand = map(Math.Abs(ang), 0f, 4f, 100, 0);
                                mappedand = Clamp(mappedand, 0, 100);


                                Color col = GetColorFromRedYellowGreenGradient(mappedand);

                                col = Color.FromArgb(150, col.R, col.G, col.B);

                                string text = "";

                                if (PlayerOrCameraNearPos(bd, 20f)) text = pref + ang + "º";
                                
                                Color alpha = Color.FromArgb(100, col.R, col.G, col.B);
                                
                                World.DrawMarker(MarkerType.ChevronUpx1, bd+new Vector3(0,0,1f), currentDir, new Vector3(90, 0, 0), new Vector3(4f, 2f, 2f), alpha);// DrawLine(vm,last, Color.Black);

                                if (oldp != Vector3.Zero) DrawLine(oldp, bd, col);
                                ddc = b.DistanceTo(bd);




                                temp.Add(bd);
                                oldp = bd;
                            }
                        }
                        

                        EditWideDict.Clear();
                        for (int d = 0; d < temp.Count - 1; d++)
                        {
                            EditWideDict.Add(d, wide);
                        }
                      if (temp.Count>4)
                        {
                            Vector3 aim = Vector3.Lerp(temp[temp.Count - 2] + new Vector3(0, 0, 0.5f), temp[temp.Count - 1] + new Vector3(0, 0, 0.5f), 10f);

                            DrawLine(temp[temp.Count - 2] + new Vector3(0, 0, 0.5f), aim, Color.Blue);
                        }
                    }
                }
                else
                {
                    World.DrawMarker(MarkerType.ChevronUpx3, ray.HitCoords, FreecCamRide.ForwardVector, new Vector3(-90, 0, 0), new Vector3(1, 1, 1), Color.Blue);
                    World.DrawMarker(MarkerType.ChevronUpx3, ray.HitCoords, FreecCamRide.ForwardVector, new Vector3(-90, 0, 0), new Vector3(1, 1, 1), Color.Blue);
                    DrawLine(ray.HitCoords, ray.HitCoords - (FreecCamRide.ForwardVector * 10), Color.Blue);

                    Vector3 right = ray.HitCoords + (FreecCamRide.RightVector * wide);
                    Vector3 left = ray.HitCoords - (FreecCamRide.RightVector * wide);

                    World.DrawMarker(MarkerType.UpsideDownCone, right + new Vector3(0, 0, 1), FreecCamRide.ForwardVector, new Vector3(0, 0, 0), new Vector3(1, 1, 1), Color.Blue);
                    World.DrawMarker(MarkerType.UpsideDownCone, left + new Vector3(0, 0, 1), FreecCamRide.ForwardVector, new Vector3(0, 0, 0), new Vector3(1, 1, 1), Color.Blue);
                    DrawLine(left + new Vector3(0, 0, 0.05f), right + new Vector3(0, 0, 0.05f), Color.Blue);

                    if (Game.IsControlJustPressed(2, GTA.Control.Attack) && ray.DitHitAnything)
                    {
                        Vector3 p = ray.HitCoords;// + new Vector3(0, 0, 0.5f);
                        Path.Add(p);
                        p = ray.HitCoords - (FreecCamRide.ForwardVector * 1);
                        Path.Add(p);
                        rBezier = (ray.HitCoords - (FreecCamRide.ForwardVector * 6));

                    }
                }

                for (int i = 0; i < Path.Count - 1; i++)
                {
                    if (WideDict.Count - 1 < Path.Count - 1)
                    {
                        if (!WideDict.ContainsKey(i))
                        {
                            WideDict.Add(i, wide);
                        }
                    }
                }

                while (WideDict.Count - 1 > Path.Count - 1)
                {
                    WideDict.Remove(WideDict.Count - 1);
                }

            }
        }
        


        

        public static Color GetColorFromRedYellowGreenGradient(double percentage)
        {
            
            

            var red = (percentage > 50 ? 1 - 2 * (percentage - 50) / 100.0 : 1.0) * 255;
            var green = (percentage > 50 ? 1.0 : 2 * percentage / 100.0) * 255;
            var blue = 0.0;
            Color result = Color.FromArgb((int)red, (int)green, (int)blue);
            return result;
        }

        void SetloadingPromptText(string t)
        {
            Function.Call(Hash._0xABA17D7CE615ADBF, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);
            Function.Call(Hash._0xBD12F8228410D9B4, 5);
        }
        


        public void HandleFreecam()
        {

            if (World.RenderingCamera == null && HideHudMode) HideHudMode = false;
            

            if (!CanWeUse(FreecCamRide))
            {
                return;
            }

            if (!InFreeCam && FreecCamRide.Position.DistanceTo(Game.Player.Character.Position) > 100f) FreecCamRide.Position = Game.Player.Character.Position + new Vector3(0, 0, 20);

            if (InFreeCam)
            {
                Function.Call(Hash.HIDE_HUD_AND_RADAR_THIS_FRAME, true);
                
                if (Game.IsControlJustPressed(2, GTA.Control.Detonate))
                {
                    HideHudMode = !HideHudMode;
                }


                



                //Instructional buttons
                if (1 == 1)
                {
                    if (scaleform == null || !scaleform.IsLoaded)
                    {
                        scaleform = new Scaleform("INSTRUCTIONAL_BUTTONS");
                        UI.ShowSubtitle("~o~Scaleform not loaded", 500);
                        return;
                    }

                    scaleform.CallFunction("CLEAR_ALL", true);
                    scaleform.CallFunction("CREATE_CONTAINER");

                    if (1 == 1)
                    {
                        if (DebugLevel == (int)DebugMode.RacingLineEdit)
                        {
                            scaleform.CallFunction("SET_DATA_SLOT", 4, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.FrontendUp), "Next Guide");
                            scaleform.CallFunction("SET_DATA_SLOT", 3, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.FrontendDown), "Previous Guide");
                            scaleform.CallFunction("SET_DATA_SLOT", 2, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.FrontendLeft), "Move Left");
                            scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.FrontendRight), "Move Right");

                            scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.FrontendDelete), "Delete guide");
                        }
                        else if (routeEditMode)
                        {
                            if (Path.Count() > 0)
                            {

                                if (IsShiftOn)
                                {
                                    scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Aim), "Delete last ten nodes");
                                }
                                else
                                {

                                    scaleform.CallFunction("SET_DATA_SLOT", 2, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Attack), "Apply Section");
                                    scaleform.CallFunction("SET_DATA_SLOT",1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Aim), "Delete last node");
                                    scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Sprint), "More options");

                                }
                            }
                            else
                            {
                                scaleform.CallFunction("SET_DATA_SLOT", 2, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Attack), "Place Start Line");
                                scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelPrev), "Widen");
                                scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.WeaponWheelNext), "Tighten");
                            }

                        }
                        else
                        {

                            if (IsDroneMode) scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.NextCamera), "Freecam Mode");
                            else scaleform.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.NextCamera), "Drone Mode");
                            scaleform.CallFunction("SET_DATA_SLOT", 1, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Detonate), "Hide Hud");
                            scaleform.CallFunction("SET_DATA_SLOT", 2, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Jump), "Slow Mo");

                        }
                    }
                    scaleform.CallFunction("DRAW_INSTRUCTIONAL_BUTTONS", 0);
                    if (!HideHudMode) scaleform.Render2D();

                }
                Game.DisableControlThisFrame(0, GTA.Control.Attack);
                Game.DisableControlThisFrame(0, GTA.Control.Aim);
                Game.DisableControlThisFrame(0, GTA.Control.NextCamera);
                Game.DisableControlThisFrame(0, GTA.Control.Sprint);
                Game.DisableControlThisFrame(0, GTA.Control.Jump);
                Game.DisableControlThisFrame(0, GTA.Control.Phone);
                
                /*
                for (int i = 0; i < 50; i++)
                {
                    Game.DisableControlThisFrame(0, (GTA.Control)i);
                    //(Function.Call(Hash.DISABLE_CONTROL_ACTION, 0, i);

                }

                //                Function.Call(Hash.DISABLE_ALL_CONTROL_ACTIONS, 0);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.ReplayRecord);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.ReplayStartStopRecording);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.SaveReplayClip);


                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.LookLeftRight);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.LookUpDown);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.CursorX);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.CursorY);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.FrontendPauseAlternate);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.WeaponWheelPrev);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.WeaponWheelNext);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.EnterCheatCode);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.Jump);

                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.FrontendUp);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.FrontendLeft);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.FrontendDown);
                Function.Call(Hash.ENABLE_CONTROL_ACTION, 0, (int)GTA.Control.FrontendRight);

                */
                //Controls
                if (Game.IsControlJustPressed(2, GTA.Control.Jump))
                {

                    if (TimeScale > 0.1f)
                    {
                        if (TimeScale > 0.5) Function.Call(Hash._START_SCREEN_EFFECT, "FocusOut", 500, false);

                        TimeScale = 0.001f;
                        IdealTimeScale = 0.001f;
                        Game.TimeScale = 0.001f;
                    }
                    else
                    {
                        IdealTimeScale = 1.0f;
                        if (TimeScale < 0.1f) TimeScale = 0.1f;
                        Game.TimeScale = TimeScale;
                    }
                }
                

                FreecCamRide.Position = FreecCamRide.Position + (FreeCamMovement * 1f);
                FreecCamRide.Rotation = new Vector3(0f, 0f, FreecCamRide.Rotation.Z);

                bool Reduce = true;
                float mouseX = Function.Call<float>(Hash.GET_CONTROL_NORMAL, 0, (int)GTA.Control.LookLeftRight);
                float mouseY = Function.Call<float>(Hash.GET_CONTROL_NORMAL, 0, (int)GTA.Control.LookUpDown);
                FreecCamRide.Rotation = FreecCamRide.Rotation + new Vector3(0, 0, GameplayCamera.RelativeHeading);

                float spd = 0.01f;
                float heightd = FreecCamRide.HeightAboveGround;

                string dir = "" + Math.Round(CamIntendedHeight - heightd, 1);
                if (CamIntendedHeight - heightd <= -1f) dir = "v " + Math.Round(CamIntendedHeight - heightd, 0);
                if (CamIntendedHeight - heightd >= 1f) dir = "^ " + Math.Round(CamIntendedHeight - heightd, 0);

                Game.Player.Character.Position = FreecCamRide.Position + new Vector3(0, 0, -1.5f);
                Game.Player.Character.Rotation = FreecCamRide.Rotation + new Vector3(0, 0, 180f);
                if (FreeCamMovement.Length() < 7f)
                {
                    if (!IsDroneMode) spd = 0.02f;
                    if (IsShiftOn) spd += 0.05f;

                    if (GameplayCamera.IsRendering)
                    {

                        if (Game.IsControlJustPressed(2, GTA.Control.NextCamera))
                        {
                            IsDroneMode = !IsDroneMode;
                            if (IsDroneMode) CamIntendedHeight = FreecCamRide.HeightAboveGround;
                        }

                        if (Game.IsControlPressed(2, GTA.Control.WeaponWheelPrev)) CamIntendedHeight+=3;
                        if (Game.IsControlPressed(2, GTA.Control.WeaponWheelNext)) CamIntendedHeight-=3;

                        if (Game.IsControlPressed(2, GTA.Control.VehicleAccelerate))
                        {
                            Reduce = false;

                            if (!IsDroneMode) FreeCamMovement += GameplayCamera.Direction * spd; else FreeCamMovement += Game.Player.Character.ForwardVector * spd;
                        }
                        if (Game.IsControlPressed(2, GTA.Control.VehicleBrake))
                        {
                            Reduce = false;
                            if (!IsDroneMode) FreeCamMovement -= GameplayCamera.Direction * spd; else FreeCamMovement -= Game.Player.Character.ForwardVector * spd;

                        }
                        if (Game.IsControlPressed(2, GTA.Control.MoveLeftOnly))
                        {
                            Reduce = false;
                            FreeCamMovement += Game.Player.Character.RightVector * -spd;
                        }
                        if (Game.IsControlPressed(2, GTA.Control.MoveRightOnly))
                        {
                            Reduce = false;
                            FreeCamMovement += Game.Player.Character.RightVector * +spd;
                        }
                    }
                    if (IsDroneMode)
                    {
                        if (CamIntendedHeight < 2f) CamIntendedHeight = 2f;
                        if (heightd > 0.0f)
                        {
                            if (heightd > CamIntendedHeight + 1f)
                            {
                                if (FreeCamMovement.Z > -0.2f) FreeCamMovement -= new Vector3(0, 0, (heightd - (CamIntendedHeight + 1f)) * 0.002f);
                            }
                            else if (heightd < CamIntendedHeight - 1f)
                            {

                                if (FreeCamMovement.Z < 0.5f)
                                {
                                    float d = map(heightd, 1f, 4f, 5f, 1f);
                                    d = Clamp(d, 1f, 5f);
                                    FreeCamMovement += new Vector3(0, 0, ((CamIntendedHeight - 1f) - heightd) * (0.0025f * d));//0.04f
                                }
                            }
                            else FreeCamMovement.Z *= 0.9f;
                        }


                    }

                }
                if (Reduce)
                {
                    if (IsDroneMode)
                    {

                        if (Reduce)
                        {

                            if (FreeCamMovement.Length() > 0.2f)
                            {
                                FreeCamMovement.X *= 1 - (spd * 0.5f); // *= new Vector3(1f, 1f, 1f);
                                FreeCamMovement.Y *= 1 - (spd * 0.5f);
                                if (Math.Abs(heightd) < 1f) FreeCamMovement.Z *= 1 - (spd * 2f);
                            }
                            else
                            {
                                FreeCamMovement.X *= 1 - (spd * 2f); // *= new Vector3(1f, 1f, 1f);
                                FreeCamMovement.Y *= 1 - (spd * 2f);
                                if (Math.Abs(heightd) < 1f) FreeCamMovement.Z *= 1 - (spd * 2f);

                            }
                        }
                    }
                    else
                    {
                        if (Reduce)
                        {
                            FreeCamMovement.X *= 1 - (spd * 2f); // *= new Vector3(1f, 1f, 1f);
                            FreeCamMovement.Y *= 1 - (spd * 2f);
                            FreeCamMovement.Z *= 1 - (spd * 2f);
                        }

                    }
                }
                
            }
            else //Freecam is not rendering
            {
                FreeCamMovement = Vector3.Zero;
            }


        }


        public void StartRace()
        {
            if (Path.Count == 0)
            {
                UI.Notify("~r~Load or create a path route first.");
                return;
            }

          //  UI.ShowSubtitle("Type in the Discipline tags used to look up the vehicles, separated by a space. Example: ~b~muscle~w~ ~b~racecar~w~ ",5000);
            

            AddPlayerToGrid();
            if (Racers.Count == 0)
            {
                UI.Notify("~r~No vehicles found with those tags.");
                return;
            }

            Game.MissionFlag = true;
            SetupRace(true, true);

            if (!InFreeCam || Game.IsScreenFadedIn) Function.Call(Hash.DO_SCREEN_FADE_IN, 500);
            Game.SetControlNormal(2, GTA.Control.VehicleLookBehind, 1f);


        }

        public void CleanRacers()
        {
            Game.MissionFlag = false;
            foreach (Racer r in Racers)
            {
                r.Delete();
            }
            Racers.Clear();
            LeaderboardFinish.Clear();
            RaceStatus = RaceState.NotInitiated;
        }


        bool AddPlayerToGrid()
        {
            Vehicle cv = Game.Player.Character.CurrentVehicle;
            if (CanWeUse(cv))
            {
                Racers.Add(new Racer(cv, Game.Player.Character));
                return true;
            }
            return false;
        }

        void LoadAndRace()
        {


            LoadTrack(LoadTrackFile(FilteredTrackList[0]));

            LoadGrid("muscle", intendedOpponents);
            SetupRace(true, true);
            StartCoundown();

        }
        void PlaceCars(bool sortbypower)
        {
            if (sortbypower) Racers = Racers.OrderBy(v => Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, v.Car)).ToList();
            Racer p=null;
            int index = 0;
            foreach (Racer r in Racers) if (r.Driver.IsPlayer)
                {
                    index = Racers.IndexOf(r);
                    p = r;
                }
            if (p != null)
            {

                Racers.RemoveAt(index);
                Racers.Add(p);
            }

            Vector3 start = Path[Path.Count - 2];
            if (IsPointToPoint) start = Path[0];
            int pos = 0;
            foreach (Racer r in Racers)
            {
                r.Initialize();

                r.Car.Position = GridPositions[pos];
                if (IsPointToPoint)
                {
                    r.Car.Heading = (Path[2] - Path[0]).ToHeading();
                }
                else
                {
                    if (pos > GridPositions.Count - 2)
                    {
                        r.Car.Heading = (GridPositions[pos - 2] - GridPositions[pos]).Normalized.ToHeading();
                    }
                    else
                    {
                        r.Car.Heading = (GridPositions[pos] - GridPositions[pos + 2]).Normalized.ToHeading();
                    }
                }

                /*
                Prop p = World.CreateProp("prop_start_grid_01", r.Car.Position + (r.Car.ForwardVector * ((r.Car.Model.GetDimensions().Y / 2) + 0.0f)), false, true);
                p.Heading = r.Car.Heading;
                
                AutoGeneratedProps.Add(p);
                */
                pos++;

            }

            
        }
        float CamIntendedHeight = 4f;
        public void SetupRace(bool placecars, bool tunecars)
        {
            LeaderboardFinish.Clear();

            /* Equalizes all racers' enginepower to the highest in the grid
             * 
             * float maxacc = 0f;
            foreach (Racer r in Racers)

            {
                if (maxacc < Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car)) maxacc = Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car);

            }

            foreach (Racer r in Racers)
            {
                float mul = 10f;
                while (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, r.Car) < maxacc)
                {
                    mul += 10;
                    r.Car.EnginePowerMultiplier = mul;
                    Script.Wait(0);
                }
            }
            */

            if (placecars)
            {
                PlaceCars(true);
                Racer mostPower = Racers.OrderBy(v => Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, v.Car)).ToList()[0];
                int r = ((Path.Count/3) * SettingsFile.GetValue("GENERAL_SETTINGS","Laps", 5)) + (Racers.Count * 100) + (int)Math.Round(Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, mostPower.Car) * 400, 0);
                RaceReward = (int)(Math.Round((float)r/100))*100;//(
            }
            if (tunecars)
            {
                foreach (Racer r in Racers)
                {
                    if (!Game.Player.Character.IsInVehicle(r.Car) && r.Car.GetMod(VehicleMod.Engine) == -1)
                    {
                        switch (TuningLevel)
                        {
                            case 0: continue;
                            case 1: ARS.RandomTuning(r.Car, true, true, true, false, false); break;
                            case 2: ARS.RandomTuning(r.Car, true, true, true, true, false); break;
                            case 3: ARS.RandomTuning(r.Car, true, true, true, true, false); r.Car.EnginePowerMultiplier = GetRandomInt(1, 5) * 10; break;
                        }
                    }
                }
            }

            if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "Ghosts", false) && 1==2)
            {
                DisplayHelpTextTimed("Ghosting cars...", 10000);
                List<int> orig = new List<int>();
                List<int> target = new List<int>();
                
                foreach (Racer o in Racers)
                {
                    foreach (Racer t in Racers)
                    {
                        if (o.Car.Handle == t.Car.Handle) continue;

                        Script.Wait(500);
                        bool dupe = false;

                        if (orig.Contains(t.Car.Handle))
                        {

                            for (int i = orig.IndexOf(t.Car.Handle); i < orig.Count; i++)
                            {
                                if (orig[i] != t.Car.Handle) break;
                                if (target[i] == o.Car.Handle)
                                {
                                    dupe = true;
                                    break;
                                }
                            }
                        }

                        if(!dupe)
                        {

                            Function.Call(Hash.SET_ENTITY_NO_COLLISION_ENTITY, o.Car, t.Car, false);
                            orig.Add(o.Car.Handle);
                            target.Add(t.Car.Handle);
                            Log(LogImportance.Info, o.Car.Handle + " " + t.Car.Handle);
                        }
                        else Log(LogImportance.Info, o.Car.Handle + "-" + t.Car.Handle);

                    }
                }
                DisplayHelpTextTimed("Done.", 2000);
            }
            RaceStatus = RaceState.NotInitiated;
        }
        public void StartCoundown()
        {
             HelpMessages.Add("The prize is: ~g~"+RaceReward.ToString()+"~w~$.");
            RaceStatus = RaceState.Countdown;
            GametimeCountDown = Game.GameTime;
            CountDown = MaxCountDown;

        }
        public static int GetSurfaceHash(Vector3 start, Vector3 end)
        {
            Vector3 pos = start;// v.Position + (v.UpVector * 2f);
            Vector3 endpos = end;// v.Position + (v.UpVector * -5f);

            int shape = Function.Call<int>(Hash._0x28579D1B8F8AAC80, pos.X, pos.Y, pos.Z, endpos.X, endpos.Y, endpos.Z, 0.3f, (int)IntersectOptions.Map, Game.Player.Character, 7);

            OutputArgument didhit = new OutputArgument();
            OutputArgument hitpos = new OutputArgument();
            OutputArgument snormal = new OutputArgument();
            OutputArgument materialhash = new OutputArgument();

            OutputArgument entity = new OutputArgument();

            Function.Call(Hash._0x65287525D951F6BE, shape, didhit, hitpos, snormal, materialhash, entity);


            return materialhash.GetResult<int>();
        }
        public void  PlaceOnGround(Prop p)
        {

        }



        static public List<Vector3> GridPositions = new List<Vector3>();
        List<int> FlareFX = new List<int>();
        static public bool IsPointToPoint = false;
        public void SpawnTrackLimits(List<Vector3> nodes, Dictionary<int, float> widedict, int fidelity)
        {
            
            string ModelOne = "none"; //xm_prop_base_fence_01//prop_offroad_tyres01//prop_wheel_tyre
            string ModelTwo = "none";// "prop_offroad_tyres02"; //prop_ind_light_03c//prop_mp_cone_03
            //if (nodes.Count < 5) return;
            Vector3 oldpos = Vector3.Zero;
            int dd = 0;
            Vector3 pos = Vector3.Zero;
            Vector3 rCol = nodes[0];// nodes.OrderBy(v => v.DistanceTo(Game.Player.Character.Position)).Reverse().ToList()[0];
            Function.Call(Hash.REQUEST_COLLISION_AT_COORD, rCol.X, rCol.Y, rCol.Z);
            //  Function.Call(Hash._SET_FOCUS_AREA, rCol.X, rCol.Y, rCol.Z);
            //Prop gate = World.CreateProp("prop_start_gate_01b", nodes[0] + new Vector3(0f, 0f, -0.25f), new Vector3(0, 0, (nodes[1] - nodes[0]).Normalized.ToHeading()), false, false); //prop_tri_start_banner

            Color FlaresColor = Color.GreenYellow;
            if (TrackLimits.Count == 0)
            {
                int f = 0;
                string att = GetAttribute((CurrentFile.SelectSingleNode("//Trackside")) as XmlElement, "Flares");
                if (att!=""  && att.ToLowerInvariant() !="false" && att.Length==9 && int.TryParse(att, out f))
                {
                    //  Color col = Color.FromName(GetAttribute((CurrentFile.SelectSingleNode("//Trackside")) as XmlElement, "HasFlares").ToLowerInvariant());
                    FlaresColor= Color.FromArgb(int.Parse(att.Substring(0, 3)), int.Parse(att.Substring(3, 3)), int.Parse(att.Substring(6, 3)));
                    Vector3 p = nodes[0];
                    if (IsPointToPoint) p = nodes[8 + ((intendedOpponents) * 3)];
                    Prop gate = World.CreateProp("prop_flare_01b",p + new Vector3(0f, 0f, 0.05f), new Vector3(0, 0, (nodes[1] - nodes[0]).Normalized.ToHeading() + 90f), false, false); 
                    gate.Position = GetPerpendicular(gate.Position, gate.Position - gate.RightVector, WideDict[0], true);
                    AttachFlare(gate, FlaresColor);
                    gate.FreezePosition = true;
                    gate.HasCollision = false;
                    TrackLimits.Add(gate);


                    gate = World.CreateProp("prop_flare_01b",p + new Vector3(0f, 0f, 0.05f), new Vector3(0, 0, (nodes[1] - nodes[0]).Normalized.ToHeading() + 90f), false, false); ;
                    gate.Position = GetPerpendicular(gate.Position, gate.Position + gate.RightVector, WideDict[0], true);
                    AttachFlare(gate, FlaresColor);
                    gate.FreezePosition = true;
                    gate.HasCollision = false;
                    TrackLimits.Add(gate);
                }

            }


            if (nodes[0].DistanceTo(nodes[nodes.Count-1])>20f)
            {
                IsPointToPoint = true;

            }


            if (IsPointToPoint)
            {
             if(GetAttribute((CurrentFile.SelectSingleNode("//Trackside")) as XmlElement, "Flares").ToLowerInvariant() == "true")
                {
                    
                    int c= nodes.Count();
                    Prop gate = World.CreateProp("prop_flare_01b", nodes.Last() + new Vector3(0f, 0f, 0.05f), new Vector3(0, 0, (nodes[c-2] - nodes.Last()).Normalized.ToHeading() + 90f), false, false); ;
                    gate.Position = GetPerpendicular(gate.Position, gate.Position - gate.RightVector, WideDict[0], true);
                    AttachFlare(gate, FlaresColor);
                    gate.FreezePosition = true;
                    gate.HasCollision = false;
                    TrackLimits.Add(gate);


                    gate = World.CreateProp("prop_flare_01b", nodes.Last() + new Vector3(0f, 0f, 0.05f), new Vector3(0, 0, (nodes[c - 2] - nodes.Last()).Normalized.ToHeading() + 90f), false, false); ;
                    gate.Position = GetPerpendicular(gate.Position, gate.Position + gate.RightVector, WideDict[0], true);
                    AttachFlare(gate, FlaresColor);
                    gate.FreezePosition = true;
                    gate.HasCollision = false;
                    TrackLimits.Add(gate);
                }
                
            }

            int frecuency = 6;
            bool Frozen = false;
            if (CurrentFile != null)
            {
                
                XmlNode frozen = CurrentFile.SelectSingleNode("Data/Trackside");
                if ((frozen as XmlElement).HasAttribute("Frozen"))
                {
                    if((frozen as XmlElement).GetAttribute("Frozen") =="true") Frozen = true;
                }
                XmlNode f = CurrentFile.SelectSingleNode("Data/Trackside/Frecuency");
                if (f != null) int.TryParse(f.InnerText, out frecuency);

                f = CurrentFile.SelectSingleNode("Data/Trackside/Model");
                if (DevSettingsFile.GetValue<bool>("TRACK", "SpawnTracksideProps", true) && f != null) ModelOne = f.InnerText;
            }
            else UI.Notify("current file is null");
            int barriers = 0;
            int lights = 0;
            int terrain = 0;
            List<int> Terrains = new List<int>();

            // RaycastResult terrainRaycast = World.Raycast(Path[0], Path[0] + new Vector3(0, 0, -5), IntersectOptions.Map);

            //int _GET_SHAPE_TEST_RESULT_EX(int rayHandle, bool* hit, Vector3* endCoords, Vector3* surfaceNormal, Hash* materialHash, Entity* entityHit) // 0x65287525D951F6BE 0x4301E10C b323
            int hash = GetSurfaceHash(Path[0], Path[0] + new Vector3(0, 0, -5));
            if (hash > 0) Terrains.Add(hash);
            
          //  Vector3 behind = (nodes[5] - nodes[1]).Normalized;

            if (IsPointToPoint)
            {
                for(int i=50; i>1; i--)
                {
                    Vector3 p =nodes[i*3];
                    Vector3 pnorm = (p - nodes[(i * 3) - 1]).Normalized;
                    GridPositions.Add((p) - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * (pnorm * ((i % 2==1) ? widedict[0]*0.45f : -widedict[0]*0.45f)));

                }
                /*
                GridPositions.Add(behindLine - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((behindLineb - behindLine).Normalized * (6f)));
                GridPositions.Add(behindLine - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((behindLineb - behindLine).Normalized * (6f)));
                GridPositions.Add(behindLine - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((behindLineb - behindLine).Normalized * (1.25f)));
                GridPositions.Add(behindLine - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((behindLineb - behindLine).Normalized * (1.25f)));
                GridPositions.Add(behindLine - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((behindLineb - behindLine).Normalized * (3.5f)));
                GridPositions.Add(behindLine - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((behindLineb - behindLine).Normalized * (3.5f)));
                */
            }

            for (int ph = 0; ph < nodes.Count; ph++)
            {

                int percent = (100 * ph) / (nodes.Count - 1);
                SetloadingPromptText("Loading Objects - " + percent + "%");
                pos = nodes[ph];
                float w = 0f;
                float oldw = 0f;
                if (widedict.ContainsKey(dd)) w = widedict[dd];
                if (widedict.ContainsKey(dd - 1)) oldw = widedict[dd - 1]; else oldw = w;
                if (oldpos != Vector3.Zero)
                {
                    lights++;
                    barriers++;
                    terrain++;
                    if (IsPointToPoint)
                    {


                    }
                    else
                    {
                        if (percent > 75 && ph % 5 == 0)
                        {
                            if (ph % 2 == 0)
                            {
                                GridPositions.Add(oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * (2)));
                            }
                            else
                            {
                                GridPositions.Add(oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * (2)));
                            }
                        }
                    }


                    Vector3 oldrWidepos = oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * oldw);
                    Vector3 oldlWidepos = oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * oldw);

                    Vector3 rWidepos = Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * w);
                    Vector3 lWidepos = Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * w);
                    if (TrackLimits.Count > 0)
                    {
                        Function.Call(GTA.Native.Hash._SET_FOCUS_AREA, pos.X, pos.Y, pos.Z);

                    }


                    if (terrain >= 10)
                    {
                        terrain = 0;

                        hash = GetSurfaceHash(Path[ph], Path[ph] + new Vector3(0, 0, -5));
                        if (hash > 0) Terrains.Add(hash);
                    }
                    

                    if (barriers == frecuency && ((Model)ModelOne).IsValid)
                    {
                        barriers = 0;
                        Prop cone = null;
                        for (int i = 0; i < 5; i++)
                        {
                            if (!CanWeUse(cone))
                            {
                                cone = World.CreateProp(ModelOne, pos - lWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading() + 90f), true, false); //prop_mp_cone_03
                                cone.Position += new Vector3(0, 0, 2f);
                                if (i > 2) Script.Wait(10);
                            }
                            else
                            {
                                int patience = 100;
                                while (!Function.Call<bool>(Hash.HAS_COLLISION_LOADED_AROUND_ENTITY, cone) && patience > 0)
                                {
                                    patience--;
                                    Script.Wait(1);
                                }
                                cone.Position += new Vector3(0, 0, -cone.HeightAboveGround);
                                cone.FreezePosition = Frozen;
                                cone.HasCollision = !Frozen;
                                //Function.Call(Hash.SET_ENTITY_COLLISION, cone, false, false);
                                if (cone.Model == new Model("prop_flare_01b")) AttachFlare(cone , FlaresColor);
                                TrackLimits.Add(cone);
                                break;
                            }
                        }
                        cone = null;
                        for (int i = 0; i < 5; i++)
                        {
                            if (!CanWeUse(cone))
                            {
                                cone = World.CreateProp(ModelOne, pos - rWidepos, new Vector3(0, 0, (pos - oldpos).Normalized.ToHeading() + 90f), true, false);
                                cone.Position += new Vector3(0, 0, 2f);
                                if (i > 2) Script.Wait(10);
                            }
                            else
                            {
                                int patience = 100;
                                while (!Function.Call<bool>(Hash.HAS_COLLISION_LOADED_AROUND_ENTITY, cone) && patience > 0)
                                {
                                    patience--;
                                    Script.Wait(1);
                                }
                                cone.Position += new Vector3(0, 0, -cone.HeightAboveGround);
                                cone.FreezePosition = Frozen;
                                cone.HasCollision = !Frozen;
                                if (cone.Model == new Model("prop_flare_01b")) AttachFlare(cone, FlaresColor);
                                TrackLimits.Add(cone);
                                break;
                            }
                        }
                        Script.Wait(0);
                    }
                }
                oldpos = pos;
                dd++;
            }

            Function.Call(GTA.Native.Hash.CLEAR_FOCUS);

            float length = (float)Math.Round(Path.Count() * 0.001f, 1);
            float miles = (float)Math.Round(length * 0.62123, 1);
            int road = 0;
            int dirtp = 0;
            int otherp = 0;

            foreach (int d in Terrains)
            {

                foreach (TerrainTypes type in Enum.GetValues(typeof(TerrainTypes)))
                {

                    if ((int)type == d)
                    {
                        if (type.ToString().ToLowerInvariant().Contains("tarmac"))
                        {

                            road++;
                        }
                        else if (type.ToString().ToLowerInvariant().Contains("dirt") || type.ToString().ToLowerInvariant().Contains("grass") || type.ToString().ToLowerInvariant().Contains("gravel")) dirtp++;
                        else otherp++;

                    }
                }
            }

            int total = dirtp + road + otherp;

            float PercentRoad = (float)Math.Round((road * 100f) / total, 2);
            float PercentDirt = (float)Math.Round((dirtp * 100f) / total, 2);
            float PercentOther = (float)Math.Round((otherp * 100f) / total, 2);
            UI.Notify("Track stats:~n~~b~Track Length: ~w~" + length + " Km ~n~(" + miles + " Miles).~n~Road: " + PercentRoad + "%~n~Dirt: " + PercentDirt + "% ~n~Other: " + PercentOther + "% ");
            GridPositions.Reverse();
        }

        public bool PlayerOrCameraNearPos(Vector3 pos, float dist)
        {
            if (InFreeCam) return Game.Player.Character.Position.DistanceTo(pos) < dist;
            else return World.RenderingCamera.Position.DistanceTo(pos) < dist;


        }

        public void DrawPath(List<Vector3> nodes, Dictionary<int, float> widedict, int fidelity)
        {
            if (nodes.Count == 0) return;
            int closestnode = ClosestNodeToPlace(Game.Player.Character.Position, nodes);
            Vector3 oldpos = Vector3.Zero;

            int lastLineGuide = 0;
            int start = closestnode - 50;
            int end = closestnode + 50;
            int countmax = 1;
            int count = 0;
            int dd = 0;
            Vector3 pos = Vector3.Zero;
            Vector3 lastline = Vector3.Zero;
            if (start < 0) start = 0;
            if (end > nodes.Count - 1) end = nodes.Count - 1;
            dd = start;


          if(DebugLevel>= (int)DebugMode.Route || routeEditMode)  World.DrawMarker(MarkerType.CheckeredFlagRect, nodes[0]+new Vector3(0,0,3f), (nodes[1] - nodes[0]).Normalized, new Vector3(0, 0, 0), new Vector3(5f, 5f, 5f), Color.White);// DrawLine(vm,last, Color.Black);

            for (int ph = start; ph < end; ph += 1)
            {
                count++;

                
                if (count >= countmax || 1 == 1)//Math.Abs( ph-closestnode)>50
                {
                    bool IsClose = false;
                    

                    count = 0;

                    pos = nodes[ph];
                    float w = 0f;
                    float oldw = 0f;
                    if (widedict != null)
                    {
                        if (widedict.ContainsKey(dd)) w = widedict[dd];
                        if (widedict.ContainsKey(dd - 1)) oldw = widedict[dd - 1]; else oldw = w;
                    }

                    if (oldpos == Vector3.Zero) oldpos = nodes[nodes.Count - 1];


                    if (oldpos != Vector3.Zero && PlayerOrCameraNearPos(nodes[ph], 120))
                    {

                        if (1 == 1)//Game.Player.Character.IsInRangeOf(pos, 30000f)
                        {
                            Vector3 rWidepos = GetPerpendicular(pos, oldpos, w, true); //Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * w);
                            Vector3 lWidepos = GetPerpendicular(pos, oldpos, w, false); //Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * w);

                            Vector3 oldrWidepos = GetPerpendicular(pos, oldpos, oldw, true) - (pos - oldpos); // oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * oldw);
                            Vector3 oldlWidepos = GetPerpendicular(pos, oldpos, oldw, false) - (pos - oldpos);// oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * oldw);



                            if ((DebugMode)DebugLevel == DebugMode.RacingLineEdit)
                            {
                                if (RacingLine.ContainsKey(ph))
                                {
                                    float line = RacingLine[ph];
                                    Vector3 right = GetPerpendicular(pos, oldpos, line, true);

                                    // if (PlayerOrCameraNearPos(right, 20f)) DrawText(right, line.ToString(), Color.Green, 0.2f);

                                    if (RacingLineGuide.ContainsKey(ph))
                                    {

                                        if (ph == RLineNode) World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.5f, 0.5f, 0.5f), Color.Black);
                                         else World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.5f, 0.5f, 0.5f), Color.White);

                                   

                                        lastLineGuide = ph;
                                    }
                                    else
                                    {

                                        if (ph == RLineNode)
                                        {
                                            World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Black);
                                        }
                                        else
                                        {
                                 

                                            //if (Math.Abs(line) == 0.0f) World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Gray);
                                            //else World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Red);
                                        }

                                        if (lastline != Vector3.Zero)
                                        {
                                            if (Math.Abs(line) == 0.0f) DrawLine(lastline + new Vector3(0, 0, 0.05f), right + new Vector3(0, 0, 0.05f), Color.White);
                                            else DrawLine(lastline + new Vector3(0, 0, 0.05f), right + new Vector3(0, 0, 0.05f), Color.Red);
                                        }
                                        lastline = right;

                                    }
                                }

                            }
                            Color col = Color.Green;



                            //  World.DrawMarker(MarkerType.DebugSphere, pos, Vector3.Zero, -Vector3.WorldDown, new Vector3(0.2f, 0.2f, 0.2f), Color.Blue);

                            if (w != 0f)
                            {
                             
                                if ((DebugMode)DebugLevel == DebugMode.Route || (DebugMode)DebugLevel == DebugMode.RacingLineEdit || routeEditMode)
                                {

                                    if (ph == end-1)
                                    {

                                      //  DrawLine(lWidepos + new Vector3(0, 0, 0.5f), rWidepos + new Vector3(0, 0, 0.5f), Color.Blue);
                                       // World.DrawMarker(MarkerType.DebugSphere, lWidepos , new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.3f, 0.3f, 0.3f), Color.Blue);// DrawLine(vm,last, Color.Black);
                                        //World.DrawMarker(MarkerType.DebugSphere, rWidepos, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.3f, 0.3f, 0.3f), Color.Blue);// DrawLine(vm,last, Color.Black);

                                    }                                
                                    else 
                                    if (pos != nodes[0] && ph % 5 == 0)
                                    {
                                  
                                        
                                            World.DrawMarker(MarkerType.DebugSphere, lWidepos, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Blue);// DrawLine(vm,last, Color.Black);
                                            World.DrawMarker(MarkerType.DebugSphere, rWidepos, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Blue);// DrawLine(vm,last, Color.Black);
                                           // DrawLine(lWidepos, rWidepos, Color.Blue);
                                        


                                    }
                                }

                                if ((DebugMode)DebugLevel == DebugMode.Route)
                                {
                                    col.ToArgb();

                                    Color chevcolor = Color.FromArgb(50, col);

                                    if (IsClose) World.DrawMarker(MarkerType.ChevronUpx1, pos, (oldpos - pos).Normalized, new Vector3(-90, 0, 0), new Vector3(4f, 2f, 2f), chevcolor);// DrawLine(vm,last, Color.Black);

                                    //       DrawLine(oldpos, pos, Color.Yellow);

                                }
                            }
                        }
                    }
                }

                oldpos = pos;

                dd++;
            }
        }


        public void DrawSection(List<Vector3> nodes, Dictionary<int, float> widedict)
        {
            if (nodes.Count == 0) return;
            int closestnode = ClosestNodeToPlace(Game.Player.Character.Position, nodes);
            Vector3 oldpos = Vector3.Zero;

            int lastLineGuide = 0;
            int start = closestnode - 100;
            int end = closestnode + 100;
            int countmax = 1;
            int count = 0;
            int dd = 0;
            Vector3 pos = Vector3.Zero;
            Vector3 lastline = Vector3.Zero;
            if (start < 0) start = 0;
            if (end > nodes.Count - 1) end = nodes.Count - 1;
            dd = start;
            for (int ph = start; ph < end; ph += 1)
            {
                count++;


                if (count >= countmax || 1 == 1)//Math.Abs( ph-closestnode)>50
                {
                    bool IsClose = false;


                    count = 0;

                    pos = nodes[ph];
                    float w = 0f;
                    float oldw = 0f;
                    if (widedict != null)
                    {
                        if (widedict.ContainsKey(dd)) w = widedict[dd];
                        if (widedict.ContainsKey(dd - 1)) oldw = widedict[dd - 1]; else oldw = w;
                    }

                    if (oldpos == Vector3.Zero) oldpos = nodes[nodes.Count - 1];


                    if (oldpos != Vector3.Zero && PlayerOrCameraNearPos(nodes[ph], 120))
                    {

                        if (1 == 1)//Game.Player.Character.IsInRangeOf(pos, 30000f)
                        {
                            Vector3 rWidepos = GetPerpendicular(pos, oldpos, w, true); //Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * w);
                            Vector3 lWidepos = GetPerpendicular(pos, oldpos, w, false); //Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * w);

                            Vector3 oldrWidepos = GetPerpendicular(pos, oldpos, oldw, true) - (pos - oldpos); // oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * 90f) * ((pos - oldpos).Normalized * oldw);
                            Vector3 oldlWidepos = GetPerpendicular(pos, oldpos, oldw, false) - (pos - oldpos);// oldpos - Quaternion.RotationAxis(Vector3.WorldUp, (float)(Math.PI / 180f) * -90f) * ((pos - oldpos).Normalized * oldw);



                            if ((DebugMode)DebugLevel == DebugMode.RacingLineEdit)
                            {
                                if (RacingLine.ContainsKey(ph))
                                {
                                    float line = RacingLine[ph];
                                    Vector3 right = GetPerpendicular(pos, oldpos, line, true);

                                    // if (PlayerOrCameraNearPos(right, 20f)) DrawText(right, line.ToString(), Color.Green, 0.2f);

                                    if (RacingLineGuide.ContainsKey(ph))
                                    {

                                        if (ph == RLineNode) World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.5f, 0.5f, 0.5f), Color.Black);
                                        else World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.5f, 0.5f, 0.5f), Color.White);



                                        lastLineGuide = ph;
                                    }
                                    else
                                    {

                                        if (ph == RLineNode)
                                        {
                                            World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Black);
                                        }
                                        else
                                        {


                                            //if (Math.Abs(line) == 0.0f) World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Gray);
                                            //else World.DrawMarker(MarkerType.DebugSphere, right, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Red);
                                        }

                                        if (lastline != Vector3.Zero)
                                        {
                                            if (Math.Abs(line) == 0.0f) DrawLine(lastline + new Vector3(0, 0, 0.05f), right + new Vector3(0, 0, 0.05f), Color.White);
                                            else DrawLine(lastline + new Vector3(0, 0, 0.05f), right + new Vector3(0, 0, 0.05f), Color.Red);
                                        }
                                        lastline = right;

                                    }
                                }

                            }
                            Color col = Color.Green;

                          
                            //  World.DrawMarker(MarkerType.DebugSphere, pos, Vector3.Zero, -Vector3.WorldDown, new Vector3(0.2f, 0.2f, 0.2f), Color.Blue);

                            if (w != 0f)
                            {

                                if (routeEditMode)
                                {
                                    //if(pos== nodes[0]) World.DrawMarker(MarkerType.CheckeredFlagRect, pos, new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(1f,1f,1f), Color.White);// DrawLine(vm,last, Color.Black);

                                    if (ph == end - 1)
                                    {

                                        DrawLine(lWidepos + new Vector3(0, 0, 0.5f), rWidepos + new Vector3(0, 0, 0.5f), Color.Blue);
                                        World.DrawMarker(MarkerType.DebugSphere, lWidepos + new Vector3(0, 0, 0.5f), new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.3f, 0.3f, 0.3f), Color.Blue);// DrawLine(vm,last, Color.Black);
                                        World.DrawMarker(MarkerType.DebugSphere, rWidepos + new Vector3(0, 0, 0.5f), new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.3f, 0.3f, 0.3f), Color.Blue);// DrawLine(vm,last, Color.Black);

                                    }
                                    else
                                    if (pos != nodes[0] && ph % 6 == 0)
                                    {


                                        World.DrawMarker(MarkerType.DebugSphere, lWidepos + new Vector3(0f, 0f, 0.5f), new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Green);// DrawLine(vm,last, Color.Black);
                                        World.DrawMarker(MarkerType.DebugSphere, rWidepos + new Vector3(0f, 0f, 0.5f), new Vector3(0, 0, 0), new Vector3(0, 0, 0), new Vector3(0.2f, 0.2f, 0.2f), Color.Green);// DrawLine(vm,last, Color.Black);
                                        DrawLine(lWidepos+new Vector3(0f,0f, 0.5f), rWidepos + new Vector3(0f, 0f, 0.5f), Color.Green);



                                    }
                                }
                            }
                        }
                    }
                }

                oldpos = pos;

                dd++;
            }
        }
        Vector3 GetPerpendicular(Vector3 a, Vector3 b, float length, bool clockwise)
        {
            Vector3 ab = (b - a).Normalized;
            Vector3 abCw = Vector3.Zero;
            if (clockwise)
            {
                abCw.X = -ab.Y;
                abCw.Y = ab.X;
            }
            else
            {
                abCw.X = ab.Y;
                abCw.Y = -ab.X;
            }
            return a + abCw * length;
        }
        public void Notify(string text, float timeMult)
        {

            GTA.Native.Function.Call(GTA.Native.Hash._SET_NOTIFICATION_TEXT_ENTRY, "STRING");
            GTA.Native.Function.Call(GTA.Native.Hash._ADD_TEXT_COMPONENT_STRING, text);
            GTA.Native.Function.Call(Hash._0x1E6611149DB3DB6B, "CHAR_DEFAULT", "CHAR_DEFAULT", false, 2, "", "", timeMult);

        }

        void ToggleFreeCam()
        {
            
            if (InFreeCam)
            {
                InFreeCam = false;

                Game.Player.Character.Heading = FreecCamRide.Heading;//+180f;
                Game.Player.Character.IsVisible = true;
                Game.Player.Character.HasGravity = true;
                Game.Player.Character.HasCollision = true;
                
                Game.Player.Character.Position = FreecCamRide.Position - new Vector3(0, 0, FreecCamRide.HeightAboveGround);
                if (IdealTimeScale != 1.0f)
                {
                    IdealTimeScale = 1.0f;
                    if (TimeScale < 0.1f) TimeScale = 0.1f;
                    Game.TimeScale = TimeScale;
                }


            }
            else
            {
                if ((CanWeUse(FreecCamRide)))
                {
                    if (Function.Call<int>(Hash.GET_FOLLOW_PED_CAM_VIEW_MODE) != 4)
                    {
                        Function.Call(Hash.SET_FOLLOW_PED_CAM_VIEW_MODE, 4);
                        // HelpMessages.Add("Its reccomended to use First Person to use the dronecam for now.");
                        // HelpMessages.Add("Except if you plan on recording anything via R* editor, of course.");

                    }

                    InFreeCam = true;
                    FreecCamRide.HasGravity = false;
                    Game.Player.Character.HasGravity = false;
                    Game.Player.Character.IsVisible = false;
                    Game.Player.Character.HasCollision = false;
                }

            }

        }

        public bool listenmode=false;
        public void Cheats()
        {
            if (WasCheatStringJustEntered("arson"))
            {
                LoadScript();
            }
            if(WasCheatStringJustEntered("arsoff"))
            {
                DisplayHelpTextTimed("ARS is now disabled. You can re-enable it with the 'arson' cheat.", 3000);
                Loaded = false;
            }
            
            if (WasCheatStringJustEntered("arsreload"))
            {
                UI.Notify("~b~[" + ScriptName+ "]:~w~ Reloading settings and filling track/racer dictionaries.");
               // UI.Notify("~b~[" + ScriptName+ "]:~w~ .");
                FillKnownDisciplines();
                
                FillKnownTracks();
                ReFilterKnownTracks(TrackFilter);
            }
            if (WasCheatStringJustEntered("arscarlisten"))
            {
                listenmode = !listenmode;
                if (listenmode) UI.Notify("~g~Listen mode is on."); else UI.Notify("~y~Listen mode disabled.");
            }
                if (WasCheatStringJustEntered("arsupdroute"))

            {
                UI.Notify("~b~[" + ScriptName + "]:~w~ Updating current route..");
                UpdateRoute(true, true, true);

            }
            if (WasCheatStringJustEntered("arsbuildcarlist"))
            {
                UI.Notify("~b~[" + ScriptName + "]:~w~ Generating vehicle files for all SHVDN known vehicles in the game.");

                foreach (VehicleHash hash in Enum.GetValues(typeof(VehicleHash)).Cast<VehicleHash>())
                {
                    Model m = new Model(hash);
                    if (m.IsBike || m.IsQuadbike || m.IsBicycle || m.IsCar) CreateVehicleFromHash(hash);
                    Script.Yield();
                    
                }
            }
            if (WasCheatStringJustEntered("arsrecreateline"))
            {
                UI.Notify("~b~[" + ScriptName + "]:~w~ Re-generating the racing line as an empty one.");

                recreateRLGuide();
            }
            if (WasCheatStringJustEntered("arsquick")) LoadAndRace();
            if (WasCheatStringJustEntered("arsloadsettings")) LoadSettings();
            if (WasCheatStringJustEntered("arsautogen"))
            {
                //UI.Notify("Random track " + KnownTracks[GetRandomInt(0, KnownTracks.Count - 1)] + ".");
                //UI.Notify("Random discipline " + KnownDisciplines[GetRandomInt(0, KnownDisciplines.Count - 1)] + ".");
            }
            if (WasCheatStringJustEntered("arssld"))
            {
                UI.ShowSubtitle("Sideways slide in degrees.~n~Use between 0 and 90, default is 5.");
                idealSld = int.Parse(Game.GetUserInput(2));
            }
            if (WasCheatStringJustEntered("arsspin"))
            {
                UI.ShowSubtitle("Max wheelspin. Use between 0 and 15, current is is ~b~"+maxWheelspinAllowed+".", 3000);
                maxWheelspinAllowed = -(float.Parse(Game.GetUserInput(5)));
            }

            if (WasCheatStringJustEntered("arsdip"))
            {
                extracurvedip = int.Parse(Game.GetUserInput(2));
            }
            if (WasCheatStringJustEntered("arsddip"))
            {
                extradistancedip = int.Parse(Game.GetUserInput(2));
            }
            if (WasCheatStringJustEntered("arssavedriver")) CreateDriver(Game.Player.Character);
            if (WasCheatStringJustEntered("arssavecar"))
            {
                CreateVehicle(Game.Player.Character.CurrentVehicle);//
            }            

            if (WasCheatStringJustEntered("arsclean"))
            {
                CleanEverything();
            }
        }
        public static bool IntHasFlag(int number, int flag)
        {

            if ((number & (int)flag) != 0) return true;
            return false;
        }
        public static void FindCustomProps()
        {
            if (Path.Count == 0) return;
            CustomProps.Clear();
            foreach (Prop propchecked in World.GetAllProps().ToList())
            {
                if (propchecked.IsPersistent && !AutoGeneratedProps.Contains(propchecked) && !TrackLimits.Contains(propchecked) && FreecCamRide != propchecked)
                {
                    float maxDist = 0f;



                    Vector3 d = Path.OrderBy(v => propchecked.Position.DistanceTo(v)).ToList().First();//.First().DistanceTo(propchecked.Position);
                    for (int i = 0; i < Path.Count; i++) if (d == Path[i]) if (WideDict.ContainsKey(i)) maxDist = WideDict[i] + 200f;
                    if (maxDist > propchecked.Position.DistanceTo(d))
                    {
                        CustomProps.Add(propchecked);
                    }
                }
            }
        }

        public static void UpdateRoute(bool path, bool raceline, bool props)
        {
            Log(LogImportance.Info, "-- UPDATING CURRENT ROUTE --");
            if (path || raceline)
            {
                UI.Notify("Updating path and raceline.");
                XmlNode route= CurrentFile.SelectSingleNode("//Route");
                Log(LogImportance.Info, "Removing original path.");
                route.RemoveAll();

                XmlElement p = null;
                XmlElement info = null;
                int i = 0;
                int W = 5;
                Log(LogImportance.Info, "Creating new path info from the current loaded path.");

                foreach (Vector3 v in Path)
                {
                    p = CurrentFile.CreateElement("Point");
                    //document.SelectSingleNode("Data/Route").AppendChild(element);

                    info = CurrentFile.CreateElement("X");
                    info.InnerText = Math.Round(v.X, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("Y");
                    info.InnerText = Math.Round(v.Y, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("Z");
                    info.InnerText = Math.Round(v.Z, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("Wide");
                    int wide = W;
                    if (WideDict.ContainsKey(i)) int.TryParse(WideDict[i].ToString(), out wide);
                    if (wide == 0)
                    {
                        wide = 5;
                        Log(LogImportance.Error, "Node nº" + i + "wide setting WAS 0, setting to default wide (5)");

                    }
                    else
                    {
                        W = wide;
                    }

                    info.InnerText = wide.ToString();
                    p.AppendChild(info);

                    if (RacingLineGuide.ContainsKey(i))
                    {
                        info = CurrentFile.CreateElement("RacingLine");
                        info.InnerText = RacingLineGuide[i].ToString();
                        p.AppendChild(info);

                    }

                    route.AppendChild(p);
                    i++;
                }
                CurrentFile.SelectSingleNode("Data").AppendChild(route);

            }

            if (props)
            {
                UI.Notify("Updating objects.");
                XmlElement info = null;
                Log(LogImportance.Info, "Removing all object references.");

                foreach (XmlNode o in CurrentFile.SelectNodes("//Objects")) o.RemoveAll();

                XmlNode objects = CurrentFile.SelectSingleNode("//Objects");
                if(objects==null) objects = CurrentFile.CreateElement("Objects");

                objects.RemoveAll();

                 CustomProps.Clear();
                FindCustomProps();

                Log(LogImportance.Info, "Filling objects list from the persistent props in the world. (Near the track).");

                /*
                foreach (Prop propchecked in World.GetAllProps().ToList())
                {
                    if (propchecked.IsPersistent && !AutoGeneratedProps.Contains(propchecked) && !TrackLimits.Contains(propchecked) && FreecCamRide!= propchecked)
                    {
                        float maxDist = 0f;



                        Vector3 d = Path.OrderBy(v => propchecked.Position.DistanceTo(v)).ToList().First();//.First().DistanceTo(propchecked.Position);
                        for (int i = 0; i < Path.Count; i++) if (d == Path[i]) if (WideDict.ContainsKey(i)) maxDist = WideDict[i]+10f;
                        if (maxDist > propchecked.Position.DistanceTo(d)) CustomProps.Add(propchecked);
                    }
                }*/

                foreach (Prop prop in CustomProps)
                {
                   XmlElement p = CurrentFile.CreateElement("Prop");
                    info = CurrentFile.CreateElement("Model");
                    info.InnerText = prop.Model.Hash.ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    //void _SET_OBJECT_TEXTURE_VARIANT(Object object, int paintIndex)

                    info = CurrentFile.CreateElement("TextureVariation");
                    info.InnerText = Function.Call<int>((Hash)0xE84EB93729C5F36A, prop).ToString();
                    p.AppendChild(info);


                    info = CurrentFile.CreateElement("X");
                    info.InnerText = Math.Round(prop.Position.X, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("Y");
                    info.InnerText = Math.Round(prop.Position.Y, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("Z");
                    info.InnerText = Math.Round(prop.Position.Z, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("RotX");
                    info.InnerText = Math.Round(prop.Rotation.X, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("RotY");
                    info.InnerText = Math.Round(prop.Rotation.Y, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("RotZ");
                    info.InnerText = Math.Round(prop.Rotation.Z, 2).ToString();
                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    info = CurrentFile.CreateElement("IsDynamic");
                    info.InnerText = (!prop.FreezePosition).ToString(); // (!Function.Call<bool>(Hash.IS_ENTITY_STATIC, prop)).ToString();


                    info.InnerText = info.InnerText.Replace(",", ".");
                    p.AppendChild(info);

                    objects.AppendChild(p);

                    //  document.SelectSingleNode("Data").AppendChild(info);
                }
                CurrentFile.SelectSingleNode("Data").AppendChild(objects);
            }

            XmlNode getname = CurrentFile.SelectSingleNode("//Name");
            if(getname!= null)
            {
                CurrentFile.Save(@"scripts\ARS\Tracks\" + CurrentFile.SelectSingleNode("//Name").InnerText + ".xml");

            }
            else
            {
                CurrentFile.Save(@"scripts\ARS\Tracks\" + Game.GetUserInput(200) + ".xml");

            }
        }
        public static bool RouteIsPointToPoint(List<Vector3> route)
        {
            if (route.Count < 2) return false;
            return ((route.First().DistanceTo(route.Last()) > 10f));
        }
        public static void SaveRoute(string filename)
        {
            if (filename == null || filename == "")
            {
                filename = World.GetStreetName(Path[0]);
            }

            if (File.Exists(@"scripts\ARS\Tracks\" + filename + ".xml"))
            {
                DateTime today = DateTime.Now;
                filename += " (" + today.Year+today.Month+ today.Day+ today.Hour+today.Minute+today.Second + ")";
            }


            XmlDocument document = new XmlDocument();


            
            XmlElement element = document.CreateElement("Data");
            document.AppendChild(element);



            /*
            XmlComment c = document.CreateComment("com");
            c.InnerText = "<StartLineGate>prop_start_gate_01b</StartLineGate>";
            element.AppendChild(c);

            c = document.CreateComment("com");
            c.InnerText = "<FinishLineGate>prop_start_gate_01b</FinishLineGate>";
            element.AppendChild(c);
            */

            XmlComment c = document.CreateComment("comment");
            
            c.InnerText = " Flares='204255051' would put flares at the startline.\n The value is actually three RGB values from 000 to 255.\n 255255255 would be white. ";
            element.AppendChild(c);

            XmlElement trackside = document.CreateElement("Trackside");
            XmlElement t = document.CreateElement("Model");
            t.InnerText = ARS.DevSettingsFile.GetValue("CREATOR_DEFAULTS", "TracksideModel", "prop_wheel_tyre");
            trackside.AppendChild(t);

            t = document.CreateElement("Frecuency");
            t.InnerText = ARS.DevSettingsFile.GetValue("CREATOR_DEFAULTS", "TracksideModelFrecuency", "10");
            trackside.AppendChild(t);

            
            XmlAttribute isFrozen = document.CreateAttribute("Frozen");
            isFrozen.InnerText = "true";
            trackside.Attributes.Append(isFrozen);

            XmlAttribute Flares = document.CreateAttribute("Flares");
            Flares.InnerText = "false";
            trackside.Attributes.Append(Flares);

            element.AppendChild(trackside);



            //element = document.CreateElement("Route");
            XmlElement route = document.CreateElement("Route");

            XmlElement objects = document.CreateElement("Objects");

            XmlElement name = document.CreateElement("Name");
            name.InnerText = filename;
            element.AppendChild(name);




            UI.ShowSubtitle("Write any tags you want for this track, separated by spaces. Example: rally long");
            XmlElement tags = document.CreateElement("Tags");
            XmlElement tag = document.CreateElement("Tag");
            tag.InnerText = World.GetStreetName(Path[0]);
            tags.AppendChild(tag);
            tag = document.CreateElement("Tag");
            tag.InnerText = World.GetZoneName(Path[0]).Replace(" ", "");
            tags.AppendChild(tag);

            string userTags = Game.GetUserInput(32);
            if (userTags != "")
            {
                foreach (string s in userTags.Split(' '))
                {
                    tag = document.CreateElement("Tag");
                    tag.InnerText = s;
                    tags.AppendChild(tag);
                }
            }


            element.AppendChild(tags);




            XmlElement p = null;
            XmlElement info = null;
            int i = 0;
            int W = 5;
            
            foreach (Vector3 v in Path)
            {
                p = document.CreateElement("Point");
                //document.SelectSingleNode("Data/Route").AppendChild(element);

                info = document.CreateElement("X");
                info.InnerText = Math.Round(v.X, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Y");
                info.InnerText = Math.Round(v.Y, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Z");
                info.InnerText = Math.Round(v.Z, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Wide");
                if (WideDict.ContainsKey(i))  int.TryParse(WideDict[i].ToString(), out W);
                info.InnerText = W.ToString();
                p.AppendChild(info);

                if (RacingLineGuide.ContainsKey(i))
                {
                    info = document.CreateElement("RacingLine");
                    info.InnerText = RacingLineGuide[i].ToString();
                    p.AppendChild(info);

                }

                route.AppendChild(p);
                i++;
            }


            CustomProps.Clear();


            foreach (Prop propchecked in World.GetAllProps().ToList())
            {
                if (propchecked.IsPersistent && !AutoGeneratedProps.Contains(propchecked) && !TrackLimits.Contains(propchecked))
                {

                    float d = Path.OrderBy(v => propchecked.Position.DistanceTo(v)).ToList().First().DistanceTo(propchecked.Position);
                    if (d < 10) CustomProps.Add(propchecked);
                }
            }
            foreach (Prop prop in CustomProps)
            {
                p = document.CreateElement("Prop");
                info = document.CreateElement("Model");
                info.InnerText = prop.Model.Hash.ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                //void _SET_OBJECT_TEXTURE_VARIANT(Object object, int paintIndex)

                info = document.CreateElement("TextureVariation");
                info.InnerText = Function.Call<int>((Hash)0xE84EB93729C5F36A, prop).ToString();
                ;//"0";
                p.AppendChild(info);


                info = document.CreateElement("X");
                info.InnerText = Math.Round(prop.Position.X, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Y");
                info.InnerText = Math.Round(prop.Position.Y, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("Z");
                info.InnerText = Math.Round(prop.Position.Z, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("RotX");
                info.InnerText = Math.Round(prop.Rotation.X, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("RotY");
                info.InnerText = Math.Round(prop.Rotation.Y, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("RotZ");
                info.InnerText = Math.Round(prop.Rotation.Z, 2).ToString();
                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                info = document.CreateElement("IsDynamic");
                info.InnerText = (!prop.FreezePosition).ToString(); // (!Function.Call<bool>(Hash.IS_ENTITY_STATIC, prop)).ToString();


                info.InnerText = info.InnerText.Replace(",", ".");
                p.AppendChild(info);

                objects.AppendChild(p);

            }
            document.SelectSingleNode("Data").AppendChild(route);
            document.SelectSingleNode("Data").AppendChild(objects);

            
            document.Save(@"scripts\ARS\Tracks\" + filename + ".xml");
        }

        public  void AttachFlare(Prop p, Color color)
        {
            int d = 0;
            while (!Function.Call<bool>(Hash.HAS_NAMED_PTFX_ASSET_LOADED, "scr_apartment_mp") && d < 2000) 
            {
                Function.Call(Hash.REQUEST_NAMED_PTFX_ASSET, "scr_apartment_mp");
                d++;
                Script.Wait(0);
            }
            if (Function.Call<bool>(Hash.HAS_NAMED_PTFX_ASSET_LOADED, "scr_apartment_mp"))
            {
                Function.Call(Hash._SET_PTFX_ASSET_NEXT_CALL, "scr_apartment_mp");
                if (CanWeUse(p))
                {
                    int fx = Function.Call<int>(Hash.START_PARTICLE_FX_LOOPED_ON_ENTITY, "scr_finders_package_flare", p, 0f, 0f,0.1f, 0f, 0f, 0f, 1f, true, true, true);
                    Function.Call(Hash.SET_PARTICLE_FX_LOOPED_ALPHA, fx, 1f);
                    Function.Call(Hash.SET_PARTICLE_FX_LOOPED_COLOUR, fx, color.R/255f, color.G / 255f, color.B / 255f, 1f, true); //scr_lowrider scr_lowrider_flare
                     FlareFX.Add(fx);
                }
            }
        }
        public static bool NodeExists(XmlNode node, string name)
        {
            return node.SelectSingleNode(name) != null;
        }
        public static XmlElement GetChild(XmlNode node, string name)
        {
            XmlNode n=  node.SelectSingleNode(name);
            if (n == null) return null;
            else return n as XmlElement;
        }
        public static string GetAttribute(XmlElement node, string name)
        {
            if (node == null) return "";
            if (node.HasAttribute(name)) return node.GetAttribute(name);
            return "";
        }
        public static XmlDocument LoadTrackFile(string trackname = null)
        {
            Log(LogImportance.Info, "Loading " + trackname);
            XmlDocument doc = new XmlDocument();

            doc.Load(trackname);
            return doc;
            
        }

        public void LoadTrack(XmlDocument xmlFile)
        {
            if (xmlFile == null)
            {
                UI.Notify("~r~Invalid track file.");
                return;
            }

            if (!InFreeCam) Function.Call(Hash.DO_SCREEN_FADE_OUT, 200);
            SetloadingPromptText("Loading track...");
            Script.Wait(500);

            CurrentFile = xmlFile;
            foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
            Angles.Clear();
            Path.Clear();
            WideDict.Clear();
            TrackLimits.Clear();

            XmlNode r = xmlFile.SelectSingleNode("Data");

            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");

            foreach (XmlElement prop in r.SelectNodes("Objects/Prop"))
            {
                string x = "0";
                string y = "0";
                string z = "0";
                if (NodeExists(prop, "X") && NodeExists(prop, "Y") && NodeExists(prop, "Z"))
                {
                    x = prop.SelectSingleNode("X").InnerText;
                    y = prop.SelectSingleNode("Y").InnerText;
                    z = prop.SelectSingleNode("Z").InnerText;
                }

                bool isDynamic = false;

                if (NodeExists(prop, "IsDynamic")) bool.TryParse(prop.SelectSingleNode("IsDynamic").InnerText, out isDynamic);

                float fx = 0f;
                float.TryParse(x, out fx);
                float fy = 0f;
                float.TryParse(y, out fy);
                float fz = 0f;
                float.TryParse(z, out fz);
                Vector3 pos = new Vector3(fx, fy, fz);
                if (NodeExists(prop, "RotX") && NodeExists(prop, "RotY") && NodeExists(prop, "RotZ"))
                {
                    x = prop.SelectSingleNode("RotX").InnerText;
                    y = prop.SelectSingleNode("RotY").InnerText;
                    z = prop.SelectSingleNode("RotZ").InnerText;
                }
                fx = 0f;
                float.TryParse(x, out fx);
                fy = 0f;
                float.TryParse(y, out fy);
                fz = 0f;
                float.TryParse(z, out fz);
                Vector3 rot = new Vector3(fx, fy, fz);

                if (NodeExists(prop, "Model"))
                {
                    int hash = 0;
                    int.TryParse(prop.SelectSingleNode("Model").InnerText, out hash);
                    if (hash != 0 && new Model(hash).IsValid)
                    {


                        Prop myprop = World.CreateProp(hash, pos, rot, false, false);
                        myprop.Position = pos;
                        Function.Call(Hash.SET_ENTITY_DYNAMIC, myprop, isDynamic);
                        Function.Call(Hash.FREEZE_ENTITY_POSITION, myprop, !isDynamic);
                        Function.Call(Hash.SET_OBJECT_PHYSICS_PARAMS, myprop, 200f * myprop.Model.GetDimensions().Length(), 1f);

                        if (prop.SelectSingleNode("TextureVariation") != null) Function.Call(Hash._0x971DA0055324D033, myprop, int.Parse(prop.SelectSingleNode("TextureVariation").InnerText));
                        //   myprop.HasCollision = false;
                        CustomProps.Add(myprop);


                        if (hash == Game.GenerateHash("prop_mp_repair_01") && 1==2) //Garage stuff, never used
                        {
                            myprop.Alpha = 50;


                            if (CanWeUse(Game.Player.Character.LastVehicle))
                            {
                                Game.Player.Character.LastVehicle.Position = myprop.Position + new Vector3(0, 0, 0);
                                Game.Player.Character.LastVehicle.Heading = myprop.Heading;
                                Game.Player.Character.LastVehicle.PlaceOnGround();
                            }

                            Prop autog = World.CreateProp("prop_gazebo_03", myprop.Position, myprop.Rotation, false, true);

                            AutoGeneratedProps.Add(autog);

                            Function.Call(Hash.FREEZE_ENTITY_POSITION, autog, true);
                            Function.Call(Hash.SET_ENTITY_DYNAMIC, autog, false);

                            autog = World.CreateProp("prop_table_04", myprop.Position -= (myprop.ForwardVector * 3), myprop.Rotation, false, true);
                            AutoGeneratedProps.Add(autog);

                            Function.Call(Hash.FREEZE_ENTITY_POSITION, autog, true);
                            Function.Call(Hash.SET_ENTITY_DYNAMIC, autog, false);


                            MiniMap = autog.Position + new Vector3(0, 0, (autog.Model.GetDimensions().Z / 2));

                        }
                    }
                }


            }
            List<XmlElement> RouteNodes = new List<XmlElement>();
            foreach (XmlElement e in r.SelectNodes("Route/Point")) RouteNodes.Add(e);

            if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "ReverseRoutes", false) == true)
            {
                RouteNodes.Reverse();
                UI.Notify("~g~Route is reversed.");
            }

            int i = 0;
            float W = 5;
            foreach (XmlElement e in RouteNodes)
            {


                string x = e.SelectSingleNode("X").InnerText;
                string y = e.SelectSingleNode("Y").InnerText;
                string z = e.SelectSingleNode("Z").InnerText;

                float fx = 0f;
                float.TryParse(x, out fx);
                float fy = 0f;
                float.TryParse(y, out fy);
                float fz = 0f;
                float.TryParse(z, out fz);
                Vector3 pos = new Vector3(fx, fy, fz);
                float sensibleW = W;
                float.TryParse(e.SelectSingleNode("Wide").InnerText, out W);

                if (Math.Abs(sensibleW) > Math.Abs(W) + 1) W = sensibleW - 0.25f;//1
                if (Math.Abs(sensibleW) < Math.Abs(W) - 1) W = sensibleW + 0.25f;//1

                if (e.SelectSingleNode("RacingLine") != null && SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "ReverseRoutes", false) == false)
                {
                    float racingline = 0.0f;
                    float.TryParse(e.SelectSingleNode("RacingLine").InnerText, out racingline);
                    if (!RacingLineGuide.ContainsKey(i)) RacingLineGuide.Add(i, racingline); //Disabled raceline
                }


                Path.Add(pos);
                WideDict.Add(i, W);

                i++;
            }


            GenerateRouteInfo();

            IsPointToPoint = false;
            if (Path[0].DistanceTo(Path[Path.Count - 1]) > 20) IsPointToPoint = true;
            
            Script.Wait(1000);

            SetloadingPromptText("Loading props...");
            SpawnTrackLimits(Path, WideDict, 1);

            if (ARS.CanWeUse(Game.Player.Character.CurrentVehicle)) Game.Player.Character.CurrentVehicle.Position = Path[0]; else Game.Player.Character.Position = Path[0]; 
            if(CanWeUse(FreecCamRide))  FreecCamRide.Position = Path[5] + new Vector3(0, 0, 20);
            SetloadingPromptText("");
            Function.Call(Hash._0x10D373323E5B9C0D);
            SetSPLVisibility(false);
        }

        public void LoadRoute(string filename)
        {
            RacingLine.Clear();
            RacingLineGuide.Clear();

            foreach (string f in Directory.GetFiles(@"scripts\ARS\Tracks"))
            {
                if (f.Contains(filename))
                {
                    //XML
                    string ConfigFile = f;
                    XmlDocument document = new XmlDocument();
                    document.Load(ConfigFile);
                    int pat = 0;
                    Script.Wait(20);
                    while (document == null && pat < 5)
                    {
                        pat++;
                        document.Load(ConfigFile);
                        Script.Wait(20);
                    }
                    if (document == null)
                    {
                        return;
                    }
                    else
                    {
                        CurrentFile = document;
                        foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
                        foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
                        foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
                        Angles.Clear();
                        Path.Clear();
                        WideDict.Clear();
                        XmlNode r = document.SelectSingleNode("Data");

                        Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");

                        foreach (XmlElement prop in r.SelectNodes("Objects/Prop"))
                        {
                            string x = "0";
                            string y = "0";
                            string z = "0";
                            if (NodeExists(prop, "X") && NodeExists(prop, "Y") && NodeExists(prop, "Z"))
                            {
                                x = prop.SelectSingleNode("X").InnerText;
                                y = prop.SelectSingleNode("Y").InnerText;
                                z = prop.SelectSingleNode("Z").InnerText;
                            }

                            bool isDynamic = false;

                            if (NodeExists(prop, "IsDynamic")) bool.TryParse(prop.SelectSingleNode("IsDynamic").InnerText, out isDynamic);

                            float fx = 0f;
                            float.TryParse(x, out fx);
                            float fy = 0f;
                            float.TryParse(y, out fy);
                            float fz = 0f;
                            float.TryParse(z, out fz);
                            Vector3 pos = new Vector3(fx, fy, fz);
                            if (NodeExists(prop, "RotX") && NodeExists(prop, "RotY") && NodeExists(prop, "RotZ"))
                            {
                                x = prop.SelectSingleNode("RotX").InnerText;
                                y = prop.SelectSingleNode("RotY").InnerText;
                                z = prop.SelectSingleNode("RotZ").InnerText;
                            }
                            fx = 0f;
                            float.TryParse(x, out fx);
                            fy = 0f;
                            float.TryParse(y, out fy);
                            fz = 0f;
                            float.TryParse(z, out fz);
                            Vector3 rot = new Vector3(fx, fy, fz);

                            if (NodeExists(prop, "Model"))
                            {
                                int hash = 0;
                                int.TryParse(prop.SelectSingleNode("Model").InnerText, out hash);
                                if (hash != 0)
                                {


                                    Prop myprop = World.CreateProp(hash, pos, rot, false, false);
                                    myprop.Position = pos;
                                    Function.Call(Hash.SET_ENTITY_DYNAMIC, myprop, isDynamic);
                                    Function.Call(Hash.FREEZE_ENTITY_POSITION, myprop, !isDynamic);
                                    Function.Call(Hash.SET_OBJECT_PHYSICS_PARAMS, myprop, 200f * myprop.Model.GetDimensions().Length(), 1f);

                                    if (prop.SelectSingleNode("TextureVariation") != null) Function.Call(Hash._0x971DA0055324D033, myprop, int.Parse(prop.SelectSingleNode("TextureVariation").InnerText));
                                    //   myprop.HasCollision = false;
                                    CustomProps.Add(myprop);


                                    if (hash == Game.GenerateHash("prop_mp_repair_01"))
                                    {
                                        myprop.Alpha = 50;


                                        if (CanWeUse(Game.Player.Character.LastVehicle))
                                        {
                                            Game.Player.Character.LastVehicle.Position = myprop.Position + new Vector3(0, 0, 0);
                                            Game.Player.Character.LastVehicle.Heading = myprop.Heading;
                                            Game.Player.Character.LastVehicle.PlaceOnGround();
                                        }

                                        Prop autog = World.CreateProp("prop_gazebo_03", myprop.Position, myprop.Rotation, false, true);

                                        AutoGeneratedProps.Add(autog);

                                        Function.Call(Hash.FREEZE_ENTITY_POSITION, autog, true);
                                        Function.Call(Hash.SET_ENTITY_DYNAMIC, autog, false);

                                        autog = World.CreateProp("prop_table_04", myprop.Position -= (myprop.ForwardVector * 3), myprop.Rotation, false, true);
                                        AutoGeneratedProps.Add(autog);

                                        Function.Call(Hash.FREEZE_ENTITY_POSITION, autog, true);
                                        Function.Call(Hash.SET_ENTITY_DYNAMIC, autog, false);


                                        MiniMap = autog.Position + new Vector3(0, 0, (autog.Model.GetDimensions().Z / 2));

                                    }
                                }
                            }


                        }
                        List<XmlElement> RouteNodes = new List<XmlElement>();
                        foreach (XmlElement e in r.SelectNodes("Route/Point")) RouteNodes.Add(e);

                        if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "ReverseRoutes", false) == true)
                        {
                            RouteNodes.Reverse();
                            UI.Notify("~g~Route is reversed.");
                        }

                        int i = 0;
                        float W = 5;
                        foreach (XmlElement e in RouteNodes)
                        {


                            string x = e.SelectSingleNode("X").InnerText;
                            string y = e.SelectSingleNode("Y").InnerText;
                            string z = e.SelectSingleNode("Z").InnerText;

                            float fx = 0f;
                            float.TryParse(x, out fx);
                            float fy = 0f;
                            float.TryParse(y, out fy);
                            float fz = 0f;
                            float.TryParse(z, out fz);
                            Vector3 pos = new Vector3(fx, fy, fz);//;, float.Parse(e.SelectSingleNode("Y").InnerText, NumberStyles.AllowDecimalPoint), float.Parse(e.SelectSingleNode("Z").InnerText, NumberStyles.AllowDecimalPoint));

                            // UI.Notify(pos.ToString());

                            float sensibleW = W;
                            float.TryParse(e.SelectSingleNode("Wide").InnerText, out W);

                            if (Math.Abs(sensibleW) > Math.Abs(W) + 1) W = sensibleW - 1;
                            if (Math.Abs(sensibleW) < Math.Abs(W) - 1) W = sensibleW + 1;
                            /*
                            if (sensibleW < 0)
                            {
                                if (sensibleW > W  1) W = W - 1;
                                else if (sensibleW > W + 1) W = W + 1;
                            }
                            else
                            {
                                if (sensibleW < W - 1) W = W - 1;
                                else if (sensibleW > W + 1) W = W + 1;
                            }*/

                            if (e.SelectSingleNode("RacingLine") != null && SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "ReverseRoutes", false) == false)
                            {
                                float racingline = 0.0f;
                                float.TryParse(e.SelectSingleNode("RacingLine").InnerText, out racingline);
                                //  if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "ReverseRoutes", false) == true) racingline = -racingline;
                                if (!RacingLineGuide.ContainsKey(i)) RacingLineGuide.Add(i, racingline);
                            }


                            Path.Add(pos);
                            WideDict.Add(i, W);

                            i++;
                        }
                        //            UI.Notify("Loaded route");
                        //

                        if (RacingLineGuide.Count > 0)
                        {
                            //   if (SettingsFile.GetValue<bool>("GENERAL_SETTINGS", "ReverseRoutes", false) == true) RacingLineGuide.Reverse();

                            if (!RacingLineGuide.ContainsKey(0)) RacingLineGuide.Add(0, 0f);

                            if (!RacingLineGuide.ContainsKey(Path.Count - 1)) RacingLineGuide.Add(Path.Count - 1, 0f);
                        }




                        //

                        GenerateRouteInfo();


                    }
                }
            }
        }


        public static void GenerateRouteInfo()
        {
            //Create pre-jump stuff
            int i = 0;
            Vector3 cDir = Vector3.Zero;
            Vector3 fDir = Vector3.Zero;
            foreach (Vector3 pos in Path)
            {

                //if (i > 3)
                if (i > 5 && i < Path.Count - 5)
                {

                    //cDir = (Path[i] - Path[i+1]).Normalized;
                    //fDir = (Path[i +19] - Path[i+20]).Normalized;

                    cDir = (Path[i - 1] - Path[i]).Normalized;
                    fDir = (Path[i] - Path[i + 1]).Normalized;



                    cDir.Z = 0f; //0.3
                    fDir.Z = 0f;

                    float angle = (float)Math.Round(Vector3.SignedAngle(cDir, fDir, Vector3.WorldUp), 2);
                    Angles.Add(i, angle ); //17
                }
                

                i++;
            }

            //Creatr racing line guide if there isn't one
            if (RacingLineGuide.Count == 0)
            {
                
              if(DebugLevel>0)  UI.Notify("~y~No raceline detected in this track, creating an empty one."); 
                RacingLineGuide.Add(0, 0f);
                for (int node = 1; node < Path.Count - 1; node++)
                {
                    int frecuency = 50;
                    if (node % frecuency == 0)
                    {
                        Script.Wait(20);
                        int added = 0;// GetRandomInt(-20, 20) * 5;//50 * (negate == true ? -1 : 1);
                        if (node == 0) added = 0;
                        RacingLineGuide.Add(node, 0);
                    }
                }

                RacingLineGuide.Add(Path.Count - 2, 0f);

            }

            ReGenerateLines();
        }

        void recreateRLGuide()
        {
            RacingLineGuide.Clear();
            RacingLine.Clear();
            UI.Notify("~y~Re-Creating racing line.");
            for (int node = 0; node < Path.Count - 1; node++)
            {
                int frecuency = 50;
                if (node % frecuency == 0)
                {
                    Script.Wait(20);

                    RacingLineGuide.Add(node, 0);
                }

                if (!RacingLineGuide.ContainsKey(0)) RacingLineGuide.Add(0, 0f);

                if (!RacingLineGuide.ContainsKey(Path.Count - 2)) RacingLineGuide.Add(Path.Count -2, 0f);

            }
            ReGenerateLines();
        }
        static public unsafe ulong GetWheelsPtr(Vehicle handle)
        {

            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;

            if (wheelsptr == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x3B\xB7\x48\x0B\x00\x00\x7D\x0D", "xx????xx");

                if (addr != null)
                {
                    wheelsptr = *(uint*)(addr + 2) - 8;
                }
            }

            //  //UI.ShowSubtitle((*((ulong*)(address + offset))).ToString());
            return *((ulong*)(address + wheelsptr));
        }

        static public unsafe int GetNumWheels(Vehicle handle)
        {

            if (numwheelsoffset == 0x0)
            {
                IntPtr addr = (IntPtr)FindPattern("\x3B\xB7\x48\x0B\x00\x00\x7D\x0D", "xx????xx");

                if (addr != null)
                {
                    numwheelsoffset = *(uint*)(addr + 2);
                }
            }
            GameVersion gameVersion = Game.Version;
            var address = (ulong)handle.MemoryAddress;
            //   ulong offset = 0xB60; // GetWheelsPtr(handle);// (ulong)(gameVersion >= GameVersion.VER_1_0_372_2_STEAM ? 0xAA0 : 0xA80);

            // offset += 8;


            // UI.ShowSubtitle((*((int*)(address + offset))).ToString());
            return *((int*)(address + numwheelsoffset));
        }

        static public unsafe List<ulong> GetWheelPtrs(Vehicle handle)
        {
            //if (wheelsptr == 0x0) GetWheelsPtr();
            var wheelPtr = GetWheelsPtr(handle);  // pointer to wheel pointers
            var numWheels = GetNumWheels(handle);
            List<ulong> wheelPtrs = new List<ulong>();
            for (int i = 0; i < numWheels; i++)
            {
                var wheelAddr = *((ulong*)(wheelPtr + 0x008 * (ulong)i));
                wheelPtrs.Add(wheelAddr);
            }
            return wheelPtrs;
        }


        static public unsafe List<float> GetWheelsGrip(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x198;


            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);

                angle.Add(pos);
            }
            return angle;
        }
        static public unsafe List<float> GetWheelsWetgrip(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x19C;


            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);

                angle.Add(pos);
            }
            return angle;
        }

        static public unsafe float GetWheelsMaxWheelspin(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x174;

            float w = 0f;
            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);
                if (Math.Abs(pos) > Math.Abs(w)) w = pos;
            }
            return w;
        }
        static public unsafe float GetWheelsAvgWheelspin(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x174;

            float w = 0f;

            foreach (var wheel in wheelPtrs)
            {

                float pos = (float)Math.Round(*((float*)(wheel + offset)), 2);
                w += pos;
            }
            return w / wheelPtrs.Count;
        }
        static public unsafe List<float> GetWheelSkidmark(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x1B8;
            if (Game.Version <= GameVersion.VER_1_0_1290_1_STEAM) offset = 0x1B8;
            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = *((float*)(wheel + offset));

                angle.Add(pos);
            }
            return angle;
        }


        static public void DrawStats(Racer r)
        {
            float diff = (r.Car.Velocity.Length() - r.IdealSpeed) * 10;
            float acc = (r.CurrentThrottle * 100f);

            string percent = "";

            for (int i = 0; i < 100 - acc; i++) percent += " ";
            for (int i = 0; i < acc; i++) percent += "<";
            //       percent += "~w~";
            if (diff < 0f) diff = 0f;
            //
            //    racertext.Unload();
            //  
            debugFrontend.CallFunction("CLEAR_ALL", true);
            debugFrontend.CallFunction("CREATE_CONTAINER");


            debugFrontend.CallFunction("SET_DATA_SLOT", 0, Function.Call<string>(Hash._0x0499D7B09FC9B407, 2, (int)GTA.Control.Attack), percent + "%");

            debugFrontend.CallFunction("DRAW_INSTRUCTIONAL_BUTTONS", -1);

            debugFrontend.Render2D();

            return;
            if (racertext == null || !racertext.IsLoaded)
            {
                racertext = new Scaleform("mp_car_stats_01");

            }
            else
            {


                float enginePoer = 0f;
                float traction = 0f;
                float topSpeed = 0f;
                racertext.CallFunction("SET_VEHICLE_INFOR_AND_STATS", r.Car.FriendlyName, r.Car.ClassType.ToString(), "MPCarHUD", "Dinka", "Acceleration", "Brake", "Slide", "IdealSpeedDiff", (int)acc, (int)r.CurrentBrake * 100f, (int)r.SideSlide * 100f, (int)diff);

                racertext.CallFunction("setBars", 1, r.Car.Speed);
                racertext.Render3D(r.Car.Position + new Vector3(0.0f, 0.0f, r.Car.Model.GetDimensions().Z + (1f + 3f)), GameplayCamera.Rotation, new Vector3(6f * 3f, 3f * 3f, 1f * 3f));
                if (GetRandomInt(0, 100) < 2)
                {
                    racertext.Unload();
                    racertext = new Scaleform("mp_car_stats_01");
                }

                //  
            }


        }

        static public void DrawStats(string entity_name, string entity_desc, string first_name, string second_name, string third_name, string fourth_name, int first_value, int second_value, int third_value, int fourth_value, Vector3 position)
        {

            if (racertext == null || !racertext.IsLoaded)
            {
                racertext = new Scaleform("mp_car_stats_01");


            }
            else
            {
                racertext.CallFunction("SET_VEHICLE_INFOR_AND_STATS", entity_name, entity_desc, "MPCarHUD", "Obey", first_name, second_name, third_name, fourth_name, first_value, second_value, third_value, fourth_value);


                racertext.CallFunction("setBars", 1, (float)Math.Round((float)(first_value * 2), 1));

                racertext.Render3D(position, GameplayCamera.Rotation, new Vector3(6f * 3f, 3f * 3f, 1f * 3f));
            }
        }
        static public unsafe List<float> GetWheelSlippage(Vehicle handle)
        {
            List<ulong> wheelPtrs = GetWheelPtrs(handle);

            ulong offset = 0x1A8;

            List<float> angle = new List<float>();

            foreach (var wheel in wheelPtrs)
            {

                float pos = *((float*)(wheel + offset));

                angle.Add(pos);
            }
            return angle;
        }


        public static float GetRoadHeading(Entity E, float ahead)
        {
            if (CanWeUse(E))
            {
                OutputArgument outArgA = new OutputArgument();
                OutputArgument outArgB = new OutputArgument();
                Vector3 p = E.Position + (E.ForwardVector * ahead);

                if (Function.Call<bool>(Hash.GET_CLOSEST_VEHICLE_NODE_WITH_HEADING, p.X, p.Y, p.Z, outArgA, outArgB, 0, 1077936128, 0))
                {
                    Vector3 pos = outArgA.GetResult<Vector3>();

                    return outArgB.GetResult<float>();
                }
            }
            return 0;
        }

        public static float GetRoadOutOfBoundsX(Entity E, float ahead)
        {
            if (CanWeUse(E))
            {
                OutputArgument outArgA = new OutputArgument();
                OutputArgument outArgB = new OutputArgument();
                Vector3 p = E.Position + (E.ForwardVector * ahead);

                if (Function.Call<bool>(Hash.GET_CLOSEST_VEHICLE_NODE_WITH_HEADING, p.X, p.Y, p.Z, outArgA, outArgB, 0, 1077936128, 0))
                {
                    Vector3 pos = outArgA.GetResult<Vector3>();

                    return GetOffset(E, pos).X;
                }
            }
            return 0;
        }

        public static Vector3 GetRoadPos(Entity E, float ahead)
        {
            if (CanWeUse(E))
            {
                OutputArgument outArgA = new OutputArgument();
                OutputArgument outArgB = new OutputArgument();
                Vector3 p = E.Position + (E.ForwardVector * ahead);

                if (Function.Call<bool>(Hash.GET_CLOSEST_VEHICLE_NODE_WITH_HEADING, p.X, p.Y, p.Z, outArgA, outArgB, 0, 1077936128, 0))
                {
                    Vector3 pos = outArgA.GetResult<Vector3>();

                    return pos;
                    //return outArgB.GetResult<float>();
                }
            }
            return Vector3.Zero;
        }



        public static Vector3 Bezier2(Vector3 Start, Vector3 Control, Vector3 End, float t)
        {
            return (((1 - t) * (1 - t)) * Start) + (2 * t * (1 - t) * Control) + ((t * t) * End);
        }
        //List<Racer> ddd = Racers.OrderBy(vs => vs.Car.Position.DistanceTo(World.RenderingCamera.Position)).ToList();
        public static int ClosestNodeToPlace(Vector3 v, List<Vector3> PathRoute)
        {
            Vector3 closest = PathRoute.OrderBy(p => p.DistanceTo(v)).ToList()[0];
            for (int i = 0; i < PathRoute.Count - 1; i++) if (PathRoute[i] == closest) return i;
            return 0;
        }
        //0 = id, 1 = pos, 2 = heading, 3= xOffset, 4=current corner, 5=future corner angle, 6 =old pos
        public static List<dynamic> GetClosestNodeInfo(Entity E, List<Vector3> PathRoute, float ahead, int refNode)
        {
            List<dynamic> result = new List<dynamic>();
            if (CanWeUse(E))
            {
                float NodeCornerAngle = 0f;
                int node = 0;
                float distToVehicle = 0;
                int count = 0;
                Vector3 nodePos = Vector3.Zero;

                if (refNode > 0 && refNode < PathRoute.Count - 1 && 1 == 2)
                {
                    node = refNode - 1;
                    nodePos = Path[node];
                }

                else
                {
                    //Get closest node


                    foreach (Vector3 position in PathRoute)
                    {
                        if (distToVehicle == 0 || position.DistanceTo(E.Position) < distToVehicle)
                        {
                            distToVehicle = position.DistanceTo(E.Position);
                            node = count;
                            nodePos = position;
                        }
                        count++;
                    }
                }

                //Relative X offset (deviation) to that node
                float xOffset = GetOffset(E, nodePos).X;

                //Advance nodes from the closest one you got
                if (ahead > 0f)
                {
                    for (int i = 0; i < 20; i++)
                    {
                        node++;
                        if (node >= PathRoute.Count - 1) node = 0;

                        float yOffset = GetOffset(E, PathRoute[node]).Y; //PathRoute[node].DistanceTo(E.Position+(E.ForwardVector*(E.Model.GetDimensions().Y/2))) 
                        if (yOffset > ahead)
                        {
                            nodePos = PathRoute[node];
                            break;
                        }
                    }
                }
                Vector3 oldnode = nodePos;
                if (node > 2) oldnode = PathRoute[node - 3]; else oldnode = PathRoute[PathRoute.Count - 3];

                result.Add(node); // 0, node id
                result.Add(nodePos); //1 nodepos

                //Current node angle
                int fNode = node + 1;
                if (fNode >= PathRoute.Count - 1) fNode = 0;
                Vector3 heading = PathRoute[fNode] - PathRoute[node];
                float nodeHeading = Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, heading.X, heading.Y);

                //Future node angle
                int ffNode = fNode + 1;
                if (ffNode >= PathRoute.Count - 1) ffNode = 0;
                Vector3 fheading = PathRoute[ffNode] - PathRoute[fNode];
                float fCornerAngle = fheading.ToHeading() - heading.ToHeading(); //  Function.Call<float>(Hash.GET_ANGLE_BETWEEN_2D_VECTORS, fheading.X, fheading.Y, heading.X, heading.Y);


                int pastnode = node - 1;
                if (pastnode < 0) pastnode = PathRoute.Count - 1;
                Vector3 pastHeading = PathRoute[node] - PathRoute[pastnode];

                NodeCornerAngle = (nodeHeading - Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, pastHeading.X, pastHeading.Y));

                result.Add(nodeHeading);//2, corner heading

                result.Add(xOffset);//3, xoffset (deviation

                int reference = node;
                int fReference = node + 1;

                float fHeading = nodeHeading;
                if (NodeCornerAngle > 270) NodeCornerAngle -= 360;
                if (NodeCornerAngle < -270) NodeCornerAngle += 360;
                result.Add(NodeCornerAngle); //4,  corner angle


                heading.Normalize();
                pastHeading.Normalize();


                if (fCornerAngle > 270) fCornerAngle -= 360;
                if (fCornerAngle < -270) fCornerAngle += 360;

                result.Add(fCornerAngle);//5, future corner angle

                result.Add(oldnode); //6, old node for deviation
                                     /*
                                       //Worst corner angle (100m)
                                       float fCurveAngle = (heading.ToHeading() - pastHeading.ToHeading());
                                       if (fCurveAngle > 270) fCurveAngle -= 360;
                                       if (fCurveAngle < -270) fCurveAngle += 360;

                                       result.Add(fCurveAngle);
                                       */
            }

            return result;

        }
        public static Dictionary<int, float> SPDLimiter = new Dictionary<int, float>();
        public static void WorstCornerAhead(Racer r, List<Vector3> route, int cNode, float currentCorner, int maxdist)
        {

            if (route.Count < 5) return;


            r.WorstCorners.Clear();
            float current = r.Car.Velocity.Length()+30f; // r.Car.Velocity.Length() * 1.5f; //max_speed

            List<dynamic> worstInfo = new List<dynamic>();
            // int bNode = cNode;

            maxdist += cNode;

           // if (r.WorstCorners.Count > 0) maxdist = r.WorstCorners[0][3] + 100; //40
            Vector3 cDir = Vector3.Zero;
            Vector3 fDir = Vector3.Zero;
            float angle = 0f;

            r.localSPDLimiter = 0;

            string dd = "";
            int count = cNode+5;
            if (count < 15) count = 15;
            float oldworst = 0f;
            while (count <  maxdist)
            {
                count++;
                if (SPDLimiter.ContainsKey(count) && r.localSPDLimiter == 0) r.localSPDLimiter = count;

                if (Angles.ContainsKey(count))
                {
                    float avg = 0f;
                    int n = 0;
                    float realAvg = 0f;
                    int x = 0;
                    for (int i = count - 8; i < count+8; i++)
                    {
                        if (Angles.ContainsKey(i))
                        {
                            if (i>=count-4 && i<=count-4)
                            {
                                x++;
                                realAvg += Angles[i];

                            }
                            avg += Angles[i];
                            n++;
                        }
                    }
                    avg /= n;
                    realAvg /= x;
                    angle = Angles[count];// Vector3.SignedAngle(cDir, fDir, Vector3.WorldUp);
                    angle = realAvg;// Vector3.SignedAngle(cDir, fDir, Vector3.WorldUp);
                    //if (r.WorstCorners.Count>0 && Math.Abs(angle) < (r.WorstCorners[0][0] / 2)) break;

                    if (SPDLimiter.ContainsKey(count)) angle *= SPDLimiter[count];
                    if (Math.Abs(avg) > 0.15f)
                    {
                        angle -= 0.15f;
                        // if (r.WorstConers.Count > 0 && Math.Abs(angle) < r.WorstConers[r.WorstConers.Count - 1][0]) return;
                        float SurfaceGrip = 1f;
                        if (ARS.MultiplierInTerrain.ContainsKey(count))
                        {
                            SurfaceGrip = MultiplierInTerrain[count];

                        }
                        else
                        {
                            SurfaceGrip = r.SurfaceGrip;
                        }


                        float anglPenalization = 0f;
                        if (route.Count < count + 5 || count <= 15) return;
                        Vector3 downhill = (route[count] - route[count - 5]).Normalized - (route[count - 10] - route[count - 15]).Normalized;
                        float downhillangle = map(downhill.Z, -1.0f, 1.0f, -90.0f, 90.0f);

                        if (downhillangle > 0.00f)
                        {
                            //anglPenalization = 0f;
                            //penaliz = (Math.Abs(downhillratio)*0.25f);
                            // penaliz = Clamp(penaliz, 0.0f, 0.2f);
                            //  angle -= penaliz;
                            //anglPenalization = (Math.Abs(downhillangle) * 0.1f);
                            //if (anglPenalization > angle) angle = 0f; else anglPenalization = -anglPenalization;
                            
                        }
                        else
                        {
                            anglPenalization = (Math.Abs(downhillangle) * 0.2f);
                           // anglPenalization = Clamp(anglPenalization ,0.0f, 1.0f);
                        }
                        anglPenalization = (float)Math.Round(anglPenalization, 2);

                        //float downforce = GetDownforce(r.Car);
                        angle += anglPenalization;

                        angle += map((route[count +5] - route[count  -5]).Normalized.Z, -1.0f, 1.0f, -90.0f, 90.0f)*0.05f;
                        //angle -= map(r.Car.Velocity.Length(), 30, 100, 0, (2 * downforce));
                        //   if (angle < 0.0f) angle = 0.0f;
                        float worstcspeed = (float)Math.Round((ARS.GetSpeedForAngle(Math.Abs(angle), r.Confidence * SurfaceGrip)), 1);
                        worstcspeed = ARS.Clamp(worstcspeed, ARS.min_speed, ARS.max_speed);



                        if (worstcspeed < current && worstcspeed< oldworst+4f)//-10f
                        {
                            


                            //  if(!r.WorstConers.Contains(worstInfo))  
                            if (r.WorstCorners.Where(v => v[3] == count).Count() == 0)
                            {
                              //  UI.ShowSubtitle(downhillratio.ToString());

                                dd += count + " ";
                                worstInfo = new List<dynamic>();


                                //if (angle < 0) penaliz = -penaliz;
                                worstInfo.Add((float)Math.Round( Math.Abs(angle),1));
                                worstInfo.Add(route[count]);
                                worstInfo.Add(fDir);
                                worstInfo.Add(count);
                                worstInfo.Add((float)Math.Round(anglPenalization, 1));
                                worstInfo.Add((float)Math.Round(worstcspeed, 1));
                                r.WorstCorners.Add(worstInfo);
                                
                            //   if (r.WorstCorners.Count > 50) return;
                            }
                        }
                       // if (oldworst!=0f && oldworst > worstcspeed) return;
                        oldworst = worstcspeed;

                    }
                }
            }
            //     if (count < 2 || count > route.Count - 2) return;



            // UI.ShowSubtitle(r.Car.FriendlyName+" "+r.WorstConers.Count);
            //   ScriptTest.DisplayHelpText(dd);

            // 
            //  return worstInfo;
        }
        public static List<dynamic> __GetFutureWorstCorner(Vehicle v, List<Vector3> PathRoute, int node, float currentDiff, float maxDist)
        {
            List<dynamic> info = new List<dynamic>();

            float fHeading = 0f;
            //  if (fHeading >= 180) fHeading -= 180;

            int reference = node;
            if (reference < 0) reference = 0;
            int fReference = reference + 1;


            float WorstAngle = 0;
            Vector3 WorstAnglePos = Vector3.Zero;
            Vector3 WorstAngleDir = Vector3.Zero;
            for (int i = 0; i < 50; i++)
            {
                reference++;
                if (reference >= PathRoute.Count - 1) reference = 0;
                fReference = reference + 1;
                if (fReference >= PathRoute.Count - 1) fReference = 0;

                if (PathRoute[reference].DistanceTo(v.Position) < maxDist)
                {
                    Vector3 newH = PathRoute[fReference] - PathRoute[reference];
                    float dd = (float)Math.Round(Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, newH.X, newH.Y), 1);
                    //  if (dd >= 180) dd -= 180;
                    if (fHeading == 0)
                    {
                        fHeading = dd;
                        continue;
                    }



                    //   if (dd > 180 && fHeading < 90) dd = -(360 - dd);
                    //  if (fHeading > 180 && dd < 90) fHeading = -(360 - fHeading);

                    //if (dd - fHeading >= 90) dd -= 180;


                    //         if (dd >= 180) dd -= 180;
                    //           if (dd - fHeading >= 90) dd -= 180;

                    float futureDiff = (dd - fHeading);
                    if (futureDiff < -270) futureDiff += 360;
                    if (futureDiff > 270) futureDiff -= 360;

                    //       if (diff >=90 ) diff -= 180;
                    //     if (diff <= -90) diff += 180;
                    if (1 == 1 || Math.Abs(futureDiff) > Math.Abs(currentDiff))
                    {
                        if (Math.Abs(futureDiff) > 270)
                        {

                            info.Add(WorstAngle);
                            info.Add(WorstAnglePos);
                            //   //UI.Notify("~r~Heading Error");
                            return info;// Math.Abs(currentDiff);

                            fHeading = 0;
                            break;
                        }
                        else
                        {
                            if (Math.Abs(futureDiff) > Math.Abs(WorstAngle))
                            {
                                WorstAngle = futureDiff;
                                WorstAnglePos = PathRoute[reference];
                                WorstAngleDir = (WorstAnglePos - PathRoute[reference + 1]).Normalized;
                            }
                            //fHeading = dd; // Function.Call<float>(Hash.GET_HEADING_FROM_VECTOR_2D, newH.X, newH.Y);
                            // break;
                        }
                    }
                    fHeading = dd;
                }
            }

            info.Add(WorstAngle);
            info.Add(WorstAnglePos);
            info.Add(WorstAngleDir);
            return info;

        }
        public static Vector3 LerpByDistance(Vector3 A, Vector3 B, float x)
        {
            Vector3 P = x * Vector3.Normalize(B - A) + A;
            return P;
        }
        static Vector3 GetXfromPosInDirection(Vector3 mypos, Vector3 dir, Vector3 pos)
        {

            Vector3 newDir = mypos - pos;
            Vector3 offset = Vector3.Cross(dir, newDir);


            return offset;
        }
        public static bool IsRoadBusy(Vector3 pos, int carNum)
        {
            OutputArgument outArgA = new OutputArgument();
            OutputArgument outArgB = new OutputArgument();
            if (Function.Call<bool>(Hash.GET_VEHICLE_NODE_PROPERTIES, pos.X, pos.Y, pos.Z, outArgA, outArgB))
            {
                int busy = outArgA.GetResult<int>();
                int flags = outArgB.GetResult<int>();

                //DisplayHelpTextThisFrame("Busy:" + busy + "~n~Flags:" + flags);
                if (busy >= carNum) return true;

                //BOOL GET_VEHICLE_NODE_PROPERTIES(float x, float y, float z, int *density, int* flags) // 0x0568566ACBB5DEDC 0xCC90110B
            }
            return false;
        }

        static Vector3 OffsetByAngle(Vehicle v, Vector3 refDir, Vector3 goal, float angle)
        {
            Vector3 outVec = Vector3.Zero;


            float speed = v.Position.DistanceTo(goal);
            Vector3 Position = v.Position;

            Vector3 Goaltemp = goal; //Position + (v.ForwardVector * speed);
            Vector3 Direction = (Goaltemp - Position).Normalized;
            Vector3 Goal = Position + Direction * speed;

            float Angle = angle;// Vector3.Angle(v.Velocity.Normalized, Direction);
            if (Vector3.SignedAngle(Direction, refDir, Vector3.WorldUp) < 0) Angle = -Angle;

            Vector3 offsetDirection = Quaternion.RotationAxis(Vector3.WorldUp, (float)(System.Math.PI / 180f) * Angle) * Direction; // Quaternion.RotationAxis takes radian angles

            Vector3 physGoal = Position + offsetDirection * speed;

            outVec = Vector3.Cross(Direction, (new Vector3(0, 0, (Goal.DistanceTo(physGoal)))));
            if (Vector3.SignedAngle(Direction, offsetDirection, Vector3.WorldUp) > 0) outVec = -outVec;



            DrawLine(Position, goal, Color.White);
            DrawLine(Position, goal + outVec, Color.White);
            return outVec;
        }

        public static bool IsStable(Vehicle v, float maxSlide, float maxSpin)
        {
            if (maxSpin > 0f && Math.Abs(rad2deg(Function.Call<Vector3>(Hash.GET_ENTITY_ROTATION_VELOCITY, v, true).Z)) >= maxSpin) return false;
            if (maxSlide > 0f && Math.Abs(Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, v, true).Normalized.X) >= maxSlide) return false;
            return true;
        }

        public static bool IsSliding(Vehicle v, float maxSlide)
        {
            if (Math.Abs(Function.Call<Vector3>(Hash.GET_ENTITY_SPEED_VECTOR, v, true).Normalized.X) * 100 >= maxSlide) return true;
            return false;
        }
        static float SpeedBonusTraction(float traction)
        {
            if (traction > 2f) return traction;
            else return Math.Abs(traction - 2) * 3;
        }
        static float SpeedCurve(float angle, Vehicle v)
        {
            float mult = 1f;

            if (angle > 10) mult = 1.4f;

            if (angle > 40) mult = 1.6f;

            float value = (100 - (angle * mult)); //1.5f
            if (value < 10) value = 10;
            return value;
        }

        static Random rnd = new Random();
        public static int GetRandomInt(int min, int max)
        {

            return rnd.Next(min, max);
        }
        


        void OnKeyDown(object sender, KeyEventArgs e)
        {

        }
        void OnKeyUp(object sender, KeyEventArgs e)
        {

        }

        public static void DrawLine(Vector3 from, Vector3 to, Color color)
        {
            Function.Call(Hash.DRAW_LINE, from.X, from.Y, from.Z, to.X, to.Y, to.Z, color.R, color.G, color.B, color.A);
        }

        protected override void Dispose(bool dispose)
        {
            Function.Call(Hash._STOP_ALL_SCREEN_EFFECTS);
            if (InFreeCam)
            {
                ToggleFreeCam();

            }
            Function.Call(Hash.DO_SCREEN_FADE_IN, 500);


            foreach (int fx in FlareFX) Function.Call(Hash.STOP_PARTICLE_FX_LOOPED, fx);
            if (CanWeUse(FreecCamRide)) FreecCamRide.Delete();

            foreach (Prop p in CustomProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in AutoGeneratedProps) if (CanWeUse(p)) p.Delete();
            foreach (Prop p in TrackLimits) if (CanWeUse(p)) p.Delete();
            foreach (Racer racer in Racers)
            {
                racer.Delete();
            }

            Racers.Clear();
            if (racertext != null && racertext.IsLoaded) racertext.Unload();
            if (SCCountdown != null)
            {
                SCCountdown.Dispose();

            }
            scaleform.Unload();
            scaleform.Dispose();
            Function.Call(Hash._0x10D373323E5B9C0D);
            Game.Player.Character.HasGravity = true;

            base.Dispose(dispose);
        }

        public bool IsAhead(Vehicle v, Vector3 pos)
        {
            return Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, v, pos.X, pos.Y, pos.Z).Y < 0;
        }

        public bool HasArrived(Vehicle v, Vector3 pos, float range)
        {
            return v.IsInRangeOf(pos, range) || (Function.Call<Vector3>(Hash.GET_OFFSET_FROM_ENTITY_GIVEN_WORLD_COORDS, v, pos.X, pos.Y, pos.Z).Y < range && v.IsInRangeOf(pos, range * 2));
        }
        public static bool WasCheatStringJustEntered(string cheat)
        {
            return Function.Call<bool>(Hash._0x557E43C447E700A8, Game.GenerateHash(cheat));
        }

        int intendedOpponents = 5;

        /// TOOLS ///
        void LoadSettings()
        {
            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");

            Log(LogImportance.Info, "Loading Options.ini ...");
            if (File.Exists(@"scripts\ARS\Options.ini"))
            {
                
                SettingsFile = ScriptSettings.Load(@"scripts\ARS\Options.ini");


                intendedOpponents = SettingsFile.GetValue<int>("GENERAL_SETTINGS", "GridSize", 5);
                TrackFilter = SettingsFile.GetValue<string>("GENERAL_SETTINGS", "TrackFilter", "city");
                DisciplineFilter = SettingsFile.GetValue<string>("GENERAL_SETTINGS", "Disciplines", "muscle");
                Log(LogImportance.Info, "Loaded Options.");
            }
            else
            {
                Log(LogImportance.Error, " 'Scripts/ARS/Options.ini' does not exist. All config values will be default.");
                UI.Notify("~o~Failed to load the Options file.~w~ Check you've installed ARS properly.");
            }

            Log(LogImportance.Info, "Loading Developer Settings.ini ...");
            if (File.Exists(@"scripts\ARS\Developer Settings.ini"))
            {

                DevSettingsFile = ScriptSettings.Load(@"scripts\ARS\Developer Settings.ini");

                MaxIdealSpeed = MPHtoMS( DevSettingsFile.GetValue<float>("AI_CORNERING", "TopSpeed", 400f));
                SpeedToInput = MPHtoMS(DevSettingsFile.GetValue<float>("AI_BEHAVIOR", "speed_to_input", 12.0f));

                max_angle = DevSettingsFile.GetValue<float>("AI_CORNERING", "max_angle", 6f);            
                max_speed = MPHtoMS(DevSettingsFile.GetValue<float>("AI_CORNERING", "max_speed", 560.0f));
                min_speed = MPHtoMS(DevSettingsFile.GetValue<float>("AI_CORNERING", "min_speed", 13.5f));
                delta = DevSettingsFile.GetValue<float>("AI_CORNERING", "delta", 0.06f);

                AIRacerAutofix = DevSettingsFile.GetValue<int>("RACERS", "AIRacerAutofix", 1);
                TuningLevel = DevSettingsFile.GetValue<int>("RACERS", "AITuningLevel", 2);
                TCSLevel = DevSettingsFile.GetValue<int>("AI_BEHAVIOR", "TCSLevel", 2);

                Log(LogImportance.Info, "Loaded Developer settings.");
            }
            else
            {
                Log(LogImportance.Error, " 'Scripts/ARS/Settings.ini' does not exist. All config values will be default.");
                UI.Notify("~o~Failed to load the Settings file.~w~ Check you've installed ARS properly.");
            }

            if(File.Exists(@"scripts\ARS\MemoryOffsets.ini"))
            {
                ScriptSettings menOffexts  = ScriptSettings.Load(@"scripts\ARS\MemoryOffsets.ini");
                throttleOffset= menOffexts.GetValue<ulong>("MEMORY_OFFSETS", "Throttle", 0x0);
                steeroffset= menOffexts.GetValue<ulong>("MEMORY_OFFSETS", "Steer", 0x0);
                brakeOffset = menOffexts.GetValue<ulong>("MEMORY_OFFSETS", "Brake", 0x0);
                Log(LogImportance.Info, "Loaded Memory Offsets.");
            }
            else
            {
                Log(LogImportance.Error, " 'Scripts/ARS/MemoryOffsets.ini' does not exist. ARS will try to learn the memory offsets from the game.");
                UI.Notify("~o~Failed to load the MemoryOffsets file.~w~ Check you've installed ARS properly.");
            }
        }

        public enum LogImportance { Info, Error, Fatal }
        public static void Log(LogImportance i, string text)
        {
            if (DevSettingsFile!=null && DevSettingsFile.GetValue<LogImportance>("GENERAL", "LogLevel", LogImportance.Info) > i) return;



            string log = "\n[" + DateTime.Now + "](" + i.ToString() + "): " + text;
            File.AppendAllText(@"scripts\ARS\Log.log", log);
        }

        void WarnPlayer(string script_name, string title, string message)
        {
            Function.Call(Hash._SET_NOTIFICATION_TEXT_ENTRY, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, message);
            Function.Call(Hash._SET_NOTIFICATION_MESSAGE, "CHAR_SOCIAL_CLUB", "CHAR_SOCIAL_CLUB", true, 0, title, "~b~" + script_name);
        }

        public static bool CanWeUse(Entity entity)
        {
            return entity != null && entity.Exists();
        }


        void DisplayHelpTextThisFrame(string text)
        {
            if (HelpMessages.Count > 0) return;
            Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, text);
            Function.Call(Hash._DISPLAY_HELP_TEXT_FROM_STRING_LABEL, 0, false, false, -1);
        }


        static Vector2 World3DToScreen2d(Vector3 pos)
        {
            var x2dp = new OutputArgument();
            var y2dp = new OutputArgument();

            Function.Call<bool>(Hash._WORLD3D_TO_SCREEN2D, pos.X, pos.Y, pos.Z, x2dp, y2dp);
            return new Vector2(x2dp.GetResult<float>(), y2dp.GetResult<float>());
        }

        public enum DrawTextAlign { Center, Left, Right }
        public enum DrawTextFont { Default, Italics, Squared }
        public static void DrawText(Vector3 pos, string t, Color c, float scale)
        {
            Vector2 screeninfo = World3DToScreen2d(pos);
            Function.Call(Hash._SET_TEXT_ENTRY, "STRING");
            Function.Call(Hash.SET_TEXT_CENTRE, true);
            Function.Call(Hash.SET_TEXT_COLOUR, c.R, c.G, c.B, c.A);
            Function.Call(Hash.SET_TEXT_SCALE, 1f, scale);
            Function.Call(Hash.SET_TEXT_DROP_SHADOW, true);
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);
            Function.Call(Hash._DRAW_TEXT, screeninfo.X, screeninfo.Y);
        }


        public static float DrawText(Vector2 pos, string t, Color c, DrawTextFont font, DrawTextAlign align, float scale)
        {
            Function.Call(Hash._SET_TEXT_ENTRY, "STRING");
            Function.Call(Hash.SET_TEXT_COLOUR, c.R, c.G, c.B, c.A);
            Function.Call(Hash.SET_TEXT_SCALE, 1f, scale);
            Function.Call(Hash.SET_TEXT_RIGHT_JUSTIFY, true);
            Function.Call(Hash.SET_TEXT_DROP_SHADOW, true);
            Function.Call(Hash.SET_TEXT_JUSTIFICATION, (int)align);
            Function.Call(Hash.SET_TEXT_FONT, (int)font);
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);
            Function.Call(Hash._DRAW_TEXT, pos.X, pos.Y);
            Function.Call(Hash._0x54CE8AC98E120CAB, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, t);

            float size = Function.Call<float>(Hash._0x85F061DA64ED2F67, 1);

            return size;
        }
        public static unsafe ulong GetHandlingPtr(Vehicle v)
        {
            if (!CanWeUse(v)) return (ulong)0;

            var address = (ulong)v.MemoryAddress;
            ulong offset = 0x918;
            return *((ulong*)(address + offset));
        }

        public static unsafe float GetTRCurveLat(Vehicle v)
        {

            if (!CanWeUse(v)) return 0f;
            ulong handlingAddress = GetHandlingPtr(v);
            ulong tractionCurveMaxOffset = 0x0098;
            if (handlingAddress < 1) return 0f;
            float result = *(float*)(handlingAddress + tractionCurveMaxOffset);
            return result;
        }
        public static unsafe float GetTRCurveMax(Vehicle v)
        {

            if (!CanWeUse(v)) return 0f;
            ulong handlingAddress = GetHandlingPtr(v);
            ulong tractionCurveMaxOffset = 0x088;
            if (handlingAddress < 1) return 0f;
            float result = *(float*)(handlingAddress + tractionCurveMaxOffset);
            return result;
        }
          public static unsafe float GetDownforce(Vehicle v)
        {

            if (!CanWeUse(v)) return 0f;
            ulong handlingAddress = GetHandlingPtr(v);
            ulong downfOffset = 0x0014;
            if (handlingAddress < 1) return 0f;
            float result = *(float*)(handlingAddress + downfOffset);
            return result;
        }


        public static unsafe int GetModelFlags(Vehicle v)
        {

            if (!CanWeUse(v)) return 0;
            ulong handlingAddress = GetHandlingPtr(v);
            ulong modelflags = 0x124;
            if (handlingAddress < 1) return 0;
            int result = *(int*)(handlingAddress + modelflags);
            return result;
        }
        public static unsafe int GetHandlingFlags(Vehicle v)
        {

            if (!CanWeUse(v)) return 0;
            ulong handlingAddress = GetHandlingPtr(v);
            ulong modelflags = 0x128;
            if (handlingAddress < 1) return 0;
            int result = *(int*)(handlingAddress + modelflags);
            return result;
        }
        public static unsafe void SetDefMultiplier(Vehicle v, float mult)
        {
            if (!CanWeUse(v)) return;

            ulong handlingAddress = GetHandlingPtr(v);
            ulong tractionCurveMaxOffset = 0x00D0;
            *(float*)(handlingAddress + tractionCurveMaxOffset) = mult;
        }
        unsafe private void SetGearRatio(Vehicle v, uint gear, float ratio)
        {
            if (!CanWeUse(v)) return;

            if (gear > 7) return;

            if (!v.Exists()) return;

            *(float*)(v.MemoryAddress + 0x838 + gear * sizeof(float)) = ratio;
        }
        static T RandomEnumValue<T>()
        {
            var v = Enum.GetValues(typeof(T));
            return (T)v.GetValue(new Random().Next(v.Length));
        }

        public static void RandomTuning(Vehicle veh, bool color, bool livery, bool parts, bool performance, bool horn)
        {
            
            veh.InstallModKit();

            Script.Wait(100);
            if (livery && veh.LiveryCount > 0) veh.Livery = GetRandomInt(0, veh.LiveryCount);
            if (veh.GetModCount(VehicleMod.Livery) > 0) veh.SetMod(VehicleMod.Livery, GetRandomInt(0, veh.GetModCount(VehicleMod.Livery)), false);

            
            if (color)
            {
                int c = GetRandomInt(1, Function.Call<int>(Hash.GET_NUMBER_OF_VEHICLE_COLOURS, veh));
                Function.Call(Hash.SET_VEHICLE_COLOUR_COMBINATION, veh, c);
                //UI.Notify(color.ToString() + "/" + Function.Call<int>(Hash.GET_NUMBER_OF_VEHICLE_COLOURS, veh));
            }


            //Change tuning parts
            foreach (int mod in Enum.GetValues(typeof(VehicleMod)).Cast<VehicleMod>())
            {
                if (mod == (int)VehicleMod.Horns) continue;
                if (veh.GetModCount((VehicleMod)mod) > 0)
                {

                    if (new List<VehicleMod> { VehicleMod.Engine, VehicleMod.Transmission, VehicleMod.Brakes, VehicleMod.Suspension }.Contains((VehicleMod)mod))
                    {
                        if (!performance) continue;
                    }
                    else if (!parts) continue;
                    if (mod == (int)VehicleMod.FrontWheels) continue;
                    if (mod == (int)VehicleMod.Suspension) continue;
                    if (mod == (int)VehicleMod.Livery && !livery) continue;
                    if (mod == (int)VehicleMod.Horns && !horn) continue;
                    int d = veh.GetModCount((VehicleMod)mod);

                    if (d > 0)
                    {
                        Script.Wait(30);
                        veh.SetMod((VehicleMod)mod, GetRandomInt(0, d), false);

                    }
                }
            }

            //Change neons if at night
            if (World.CurrentDayTime.Hours > 20 || World.CurrentDayTime.Hours < 7)
            {

                //Color neoncolor = Color.FromArgb(0, Util.GetRandomInt(0, 255), Util.GetRandomInt(0, 255), Util.GetRandomInt(0, 255));
                Script.Wait(30);
                Color neoncolor = Color.Red;// veh.CustomPrimaryColor;// Color.FromKnownColor((KnownColor)GetRandomInt(0, Enum.GetValues(typeof(KnownColor)).Cast<KnownColor>().Count()));
                veh.NeonLightsColor = neoncolor;
                /*
                veh.SetNeonLightsOn(VehicleNeonLight.Front, true);
                veh.SetNeonLightsOn(VehicleNeonLight.Back, true);
                veh.SetNeonLightsOn(VehicleNeonLight.Left, true);
                veh.SetNeonLightsOn(VehicleNeonLight.Right, true);
                */
            }






        }


        static public void DisplayHelpTextTimed(string text, int time)
        {
            
            Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, text);
            Function.Call(Hash._DISPLAY_HELP_TEXT_FROM_STRING_LABEL, 0, false, false, time);
        }

        static public void DisplayHelpText(string text)
        {
            if (HelpMessages.Count > 0) return;
            Function.Call(Hash._SET_TEXT_COMPONENT_FORMAT, "STRING");
            Function.Call(Hash._ADD_TEXT_COMPONENT_STRING, text);
            Function.Call(Hash._DISPLAY_HELP_TEXT_FROM_STRING_LABEL, 0, false, false, -1f);
        }


        public XmlDocument LoadDriver(string DriverName)
        {
            List<dynamic> info = new List<dynamic>();

            string filePath = @"Scripts\ARS\Drivers\" + DriverName + ".xml";



            // File.Create(filePath);
            //            if (File.Exists(@"scripts\\NewRacingSystem.ini"))

            Script.Wait(200);

            XmlDocument XMLFile = new XmlDocument();
            XMLFile.Load(filePath);

            if (XMLFile == null)
            {
                UI.Notify("~r~cannot find file");
                return XMLFile;
            }


            info.Add(XMLFile);
            return XMLFile;
        }
        public static string CreateDriver( Ped ped)
        {
            string name = Game.GetUserInput(32);

            string filePath = @"Scripts\ARS\Drivers\" + name + ".xml";

            File.AppendAllText(filePath, "");

            // File.Create(filePath);
            //            if (File.Exists(@"scripts\\NewRacingSystem.ini"))

            Script.Wait(200);

            XmlDocument XMLFile = new XmlDocument();
            //    XMLFile.Load(filePath);

            if (XMLFile == null)
            {
                UI.Notify("~r~cannot find file");
            }

            XmlNode Data = XMLFile.CreateNode(XmlNodeType.Element, "Data", null);
            XMLFile.AppendChild(Data);

            XmlNode Driver = XMLFile.CreateNode(XmlNodeType.Element, "Driver", null);

            //Name and model
            XmlNode temp = XMLFile.CreateElement("Name");
            temp.InnerText = name;
            Driver.AppendChild(temp);

            temp = XMLFile.CreateElement("Model");
            temp.InnerText = ped.Model.Hash.ToString();
            Driver.AppendChild(temp);
            temp = XMLFile.CreateElement("Clothes");
            for (int i = -1; i < 20; i++)
            {

                int Component = Function.Call<int>(Hash.GET_PED_DRAWABLE_VARIATION, ped, i);
                int Drawable = Function.Call<int>(Hash.GET_PED_TEXTURE_VARIATION, ped, i);

                if (Component > -1 && Drawable > -1)
                {
                    XmlElement cloth = XMLFile.CreateElement("Cloth");
                    cloth.InnerText = i.ToString();
                    XmlAttribute id = XMLFile.CreateAttribute("DrawableID");
                    id.InnerText = Drawable.ToString();
                    XmlAttribute component = XMLFile.CreateAttribute("ComponentID");
                    component.InnerText = Component.ToString();

                    cloth.Attributes.Append(component);

                    cloth.Attributes.Append(id);
                    // id = XMLFile.CreateAttribute(i.ToString());
                    temp.AppendChild(cloth);
                }

                //Function.Call<bool>(Hash.IS_VEHICLE_EXTRA_TURNED_ON, veh, i)
            }
            for (int i = -1; i < 20; i++)
            {

                int Component = Function.Call<int>(Hash.GET_PED_PROP_INDEX, ped, i);
                int Drawable = Function.Call<int>(Hash.GET_PED_PROP_TEXTURE_INDEX, ped, i);

                if (Component > -1 && Drawable > -1)
                {
                    XmlElement prop = XMLFile.CreateElement("Prop");
                    prop.InnerText = i.ToString();
                    XmlAttribute id = XMLFile.CreateAttribute("PropID");
                    id.InnerText = Component.ToString();
                    XmlAttribute component = XMLFile.CreateAttribute("TextureID");
                    component.InnerText = Drawable.ToString();

                    prop.Attributes.Append(component);

                    prop.Attributes.Append(id);
                    // id = XMLFile.CreateAttribute(i.ToString());
                    temp.AppendChild(prop);
                }

                //Function.Call<bool>(Hash.IS_VEHICLE_EXTRA_TURNED_ON, veh, i)
            }
            Driver.AppendChild(temp);

            //Skills
            XmlNode DriverSkills = XMLFile.CreateElement("Skills");


            XmlNode Skill = XMLFile.CreateElement("Skill");
            Skill.InnerText = "ExampleSkill";
            XmlAttribute att = XMLFile.CreateAttribute("value");
            att.InnerText = "25";
            Skill.Attributes.Append(att);
            DriverSkills.AppendChild(Skill);

            Skill = XMLFile.CreateElement("Skill");
            Skill.InnerText = "ExampleSkill2";
            att = XMLFile.CreateAttribute("value2");
            att.InnerText = "50";
            Skill.Attributes.Append(att);
            DriverSkills.AppendChild(Skill);



            Driver.AppendChild(DriverSkills);


            Data.AppendChild(Driver);

            XMLFile.AppendChild(Data);

            XMLFile.Save(@"scripts\\ARS\Drivers\" + name + ".xml");
            UI.Notify("Saved");
            return "Finished";

        }
        List<dynamic> LoadVehicle(string name, Vector3 place)
        {
            Vehicle car = null;
            XmlDocument XMLFile = new XmlDocument();

            List<dynamic> result = new List<dynamic>();
            List<XmlDocument> files = new List<XmlDocument>();

            foreach (string filename in Directory.GetFiles(@"Scripts\ARS\Vehicles\"))
            {
                XMLFile.Load(filename);
                UI.Notify("Loading");
                string vehiclename = XMLFile.SelectSingleNode("//Name").InnerText;

                if (vehiclename == name)
                {
                    UI.Notify("Found");
                    break;
                }
                //UI.Notify("~g~"+XMLFile.SelectSingleNode("//Name").InnerText);


            }
            UI.Notify("Creating");

            car = World.CreateVehicle(int.Parse(XMLFile.SelectSingleNode("//Model").InnerText), place);
            car.PrimaryColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Primary").InnerText);
            car.SecondaryColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Secondary").InnerText);
            car.PearlescentColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Pearl").InnerText);
            car.RimColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Wheel").InnerText);
            car.DashboardColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Dash").InnerText);
            car.TrimColor = (VehicleColor)int.Parse(XMLFile.SelectSingleNode("//Trim").InnerText);

            foreach (XmlElement modelement in XMLFile.SelectNodes("//Mods/Mod")) car.SetMod((VehicleMod)int.Parse(modelement.GetAttribute("ModID")), int.Parse(modelement.InnerText), false);



            foreach (XmlElement modelement in XMLFile.SelectNodes("//Mods/ToggleMod")) car.ToggleMod((VehicleToggleMod)int.Parse(modelement.GetAttribute("ModID")), bool.Parse(modelement.InnerText));


            foreach (XmlElement modelement in XMLFile.SelectNodes("//Extras/Extra")) car.ToggleExtra(int.Parse(modelement.InnerText), true);




            float acc = float.Parse(XMLFile.SelectSingleNode("//Acceleration").InnerText);

            if (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc)
            {
                float mul = 10f;
                while (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc)
                {
                    mul += 10;
                    car.EnginePowerMultiplier = mul;
                    Script.Wait(0);
                }
            }




            car.IsPersistent = false;

            result.Add(car);
            result.Add(XMLFile);

            UI.Notify("Finished");

            return result;
        }
        VehicleColor[] randomcolors = { VehicleColor.MetallicRed, VehicleColor.MetallicRaceYellow, VehicleColor.MetallicBlue, VehicleColor.MetallicOrange, VehicleColor.MetallicSteelGray };



        void LoadGrid(string dlist, int maxcars)
        {

            
            if (maxcars > GridPositions.Count) maxcars = GridPositions.Count;
            List<string> disciplinesArray = dlist.Split(' ').ToList();
            List<string> optionals = new List<string>();
            List<string> required = new List<string>();
            List<string> banned = new List<string>();
            List<string> priority = new List<string>();


                for (int i = 0; i < disciplinesArray.Count; i++)
                {                    
                    if (disciplinesArray[i].Contains("+"))
                    {
                        disciplinesArray[i]= disciplinesArray[i].Replace("+", "");
                        required.Add(disciplinesArray[i].ToLowerInvariant());
                    }
                    else if (disciplinesArray[i].Contains("-"))
                    {
                        disciplinesArray[i] = disciplinesArray[i].Replace("-", "");
                         banned.Add(disciplinesArray[i].ToLowerInvariant());                        
                    }
                    else if (disciplinesArray[i].Contains("*"))
                    {
                          //Log(LogImportance.Info, "has priority tag");
                        disciplinesArray[i] = disciplinesArray[i].Replace("*", "");
                        priority.Add(disciplinesArray[i].ToLowerInvariant());
                     }
                    else
                    {
                        optionals.Add(disciplinesArray[i].ToLowerInvariant());
                    }
                }

            Vehicle car = null;
            XmlDocument XMLFile = new XmlDocument();
            List<dynamic> result = new List<dynamic>();
            List<XmlDocument> files = new List<XmlDocument>();
            List<XmlDocument> candidates = new List<XmlDocument>();

            List<string> approved = new List<string>();
            List<string> haspriority = new List<string>();

            if (dlist.Length > 0)
            {
                Log(LogImportance.Info, "Looking up racers that fit the " + dlist + " criteria...");

                foreach (string racerfile in RacerTags.Keys)
                {

                    bool fitsOptionals = optionals.Count == 0;
                    bool fitsBanned = false;
                    bool fitsRequired = required.Count == 0;
                    bool fitspriority = false;
                    int reqscore = 0;
                    foreach (string racerTag in RacerTags[racerfile].Split(' '))
                    {



                        foreach (string partial in optionals) if (racerTag.Contains(partial)) fitsOptionals = true;
                        foreach (string req in required) if (racerTag.Contains(req)) reqscore++;
                        foreach (string pri in priority) if (pri.Contains(racerTag) || racerTag.Contains(pri)) { fitspriority = true; }


                        if (banned.Contains(racerTag))
                        {
                            fitsBanned = true;
                            break;
                        }


                    }
                    if (reqscore == required.Count) fitsRequired = true;

                    if (!fitsBanned && (fitspriority || (fitsOptionals && fitsRequired)))
                    {
                        // XMLFile.Load(racerfile);
                        Log(LogImportance.Info, System.IO.Path.GetFileName(racerfile) + " fits the criteria.");
                        approved.Add(racerfile);
                        if (fitspriority) haspriority.Add(racerfile);
                    }
                    ///else Log(LogImportance.Info, System.IO.Path.GetFileName(racerfile) + " would NOT be loaded");

                }


                foreach (string filename in approved)
                {
                    bool isMenyoo = false;
                    XMLFile.Load(filename);


                    if (1 == 1)
                    {

                        string m = "";
                        if (GetChild(XMLFile, "//Model") != null) m = GetChild(XMLFile, "//Model").InnerText;
                        if (new Model(m).IsValid)
                        {

                            if (haspriority.Contains(filename))
                            {
                                Log(LogImportance.Info, "added priority reminder");

                                XmlNode donot = XMLFile.CreateElement("priority");
                                if (GetChild(XMLFile, "Vehicle") != null) GetChild(XMLFile, "Vehicle").AppendChild(donot);

                            }
                            candidates.Add(XMLFile);

                        }
                        else
                        {

                            int n = 0;
                            int.TryParse(m, out n);
                            if (new Model(n).IsValid)
                            {
                                if (haspriority.Contains(filename))
                                {
                                    Log(LogImportance.Info, "added priority reminder");

                                    XmlNode donot = XMLFile.CreateElement("priority");
                                    if (GetChild(XMLFile, "Vehicle") != null) GetChild(XMLFile, "Vehicle").AppendChild(donot);
                                }
                                candidates.Add(XMLFile);
                            }
                            else
                            {

                                Log(LogImportance.Error, n + " in " + filename + " is not a valid model. Its probably just not installed in this machine.");

                            }
                        }

                    }

                    XMLFile = new XmlDocument();
                }
                Log(LogImportance.Info, "Vehicles found: " + candidates.Count);
            }
            else
            {
                Log(LogImportance.Info, "The discipline criteria is empty. Skipping the vehicle lookup.");

            }




            if (maxcars > -1)
            {
                if (candidates.Count > 0)
                {
                    if (candidates.Count < maxcars)
                    {
                        Log(LogImportance.Info, "There are not enough candidates to fill the grid. Duplicating some vehicles...");

                        List<XmlDocument> dupes = new List<XmlDocument>();
                        foreach (XmlDocument d in candidates)
                        {
                            XmlDocument n = new XmlDocument();
                            n= (XmlDocument)d.Clone();
                            //Log(LogImportance.Info, "Adding a random vehicle");
                            if (n.SelectSingleNode("//Colors") != null)
                            {
                                n.SelectSingleNode("//Colors").RemoveAll();
                                //Log(LogImportance.Info, "Removed color");
                            }

                            
                            if (n.SelectNodes("//Mods/Mod").Count>0)
                            {

                                n.SelectSingleNode("//Vehicle").RemoveChild(n.SelectSingleNode("//Mods"));
                                //Log(LogImportance.Info, "Removed mods");
                            }

                            dupes.Add(n);
                        }
                        
                        while (candidates.Count < maxcars)
                        {
                            Script.Wait(0);
                            candidates.AddRange(dupes);
                        }

                    }


                }
                if (candidates.Count > maxcars && candidates.Count > 1)
                {

                    Log(LogImportance.Info, "There are too many candidates for the selected grid size. Shuffling vehicles around to randomize the final list.");
                    for (int i = 0; i < 10; i++)
                    {
                        //Log(LogImportance.Info, "Removing a random vehicle");
                        int r = GetRandomInt(0, candidates.Count - 1);
                        XmlDocument taken = candidates[r];
                        
                        candidates.RemoveAt(r);
                        candidates.Insert(GetRandomInt(0, candidates.Count - 1), taken);
                        Script.Wait(20);
                    }
                    int patience = 0;

                    Log(LogImportance.Info, "Removing random vehicles until we are within the grid size (" +maxcars+").");

                    while (candidates.Count > maxcars)
                    {

                        //Log(LogImportance.Info, "Checking if its priority");

                        int r = GetRandomInt(0, candidates.Count - 1);
                        if (NodeExists(GetChild(candidates[r], "//Vehicle"), "priority"))
                        {
                            //Log(LogImportance.Info, "this guy is priority");

                            patience++;
                            if (patience > 10) break; else continue;
                        }

                        Script.Wait(20);
                        candidates.RemoveAt(r);
                    }
                }

            }

            foreach (XmlDocument File in candidates)
            {

                string modelname = File.SelectSingleNode("//Model").InnerText;
                int model = 0;
                int.TryParse(modelname, out model);
                if (model == 0) Log(LogImportance.Info, "Loading Racer: " + modelname); else Log(LogImportance.Info, "Loading Racer: " + Function.Call<string>(Hash.GET_DISPLAY_NAME_FROM_VEHICLE_MODEL, model));

                Model vmodel = new Model(modelname);
                Script.Wait(10);
                if (vmodel.IsValid)
                {
                    vmodel = new Model(modelname);
                }
                else
                {
                    int hashvModel = 0;
                    int.TryParse(modelname, out hashvModel);
                    vmodel = hashvModel;
                }
                Model racermodel =  new Model("mp_m_freemode_01");
                racermodel.Request();

                while (!vmodel.IsLoaded)
                {
                    vmodel.Request();
                    Script.Wait(10);
                }

                //Log(LogImportance.Info, "Spawning "+vmodel);

                car = World.CreateVehicle(vmodel, Path[(Racers.Count+1) * 10]);
                //Log(LogImportance.Info, "Spawned " + vmodel);
                car.Heading = (Path[2] - Path[0]).ToHeading();

                car.InstallModKit();



                XmlNodeList disciplines = File.SelectNodes("//Disciplines/Discipline");
                List<string> tags = new List<string>();
                foreach (XmlElement t in disciplines)
                {
                    tags.Add(t.InnerText.ToLowerInvariant());
                }

                if (tags.Contains("tuner"))
                {
                    RandomTuning(car, true, true, true, true, false);

                }
                else
                {

                    if (File.SelectSingleNode("//WheelType") != null) car.WheelType = (VehicleWheelType)int.Parse(File.SelectSingleNode("//WheelType").InnerText);
                    if (File.SelectSingleNode("//Livery") != null) car.Livery = int.Parse(File.SelectSingleNode("//Livery").InnerText);

                    if (File.SelectSingleNode("//Primary") != null) car.PrimaryColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Primary").InnerText);
                    else
                    {
                        if (car.ColorCombinationCount > 2) car.ColorCombination = GetRandomInt(0, car.ColorCombinationCount);
                        else
                        {
                            car.PrimaryColor = randomcolors[GetRandomInt(0, randomcolors.Length - 1)];
                            car.SecondaryColor = randomcolors[GetRandomInt(0, randomcolors.Length - 1)];
                        }
                    }
                    if (File.SelectSingleNode("//Secondary") != null) car.SecondaryColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Secondary").InnerText);
                    if (File.SelectSingleNode("//Pearl") != null) car.PearlescentColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Pearl").InnerText);
                    if (File.SelectSingleNode("//Wheel") != null) car.RimColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Wheel").InnerText);
                    if (File.SelectSingleNode("//Dash") != null) car.DashboardColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Dash").InnerText);
                    if (File.SelectSingleNode("//Trim") != null) car.TrimColor = (VehicleColor)int.Parse(File.SelectSingleNode("//Trim").InnerText);

  
                    if (NodeExists(File, "//Mods"))
                    {
                       
                        if(File.SelectNodes("//Mods/Mod").Count > 0)
                        {                            
                            foreach (XmlElement modelement in File.SelectNodes("//Mods/Mod"))
                            {
                                if (int.Parse(modelement.GetAttribute("ModIndex")) == 48)
                                {
                                    if (int.Parse(modelement.InnerText) == -1) car.SetMod(VehicleMod.Livery, GetRandomInt(0, car.GetModCount(VehicleMod.Livery)), false);
                                }
                                else car.SetMod((VehicleMod)int.Parse(modelement.GetAttribute("ModIndex")), int.Parse(modelement.InnerText), modelement.HasAttribute("IsCustom") && modelement.GetAttribute("IsCustom").ToLowerInvariant() == "true");
                            }
                        }
                    }
                    else
                    {
                        //RandomTuning(car, false, true, true, true, false);
                    }
                    
                    foreach (XmlElement modelement in File.SelectNodes("//Mods/ToggleMod")) car.ToggleMod((VehicleToggleMod)int.Parse(modelement.GetAttribute("ModIndex")), int.Parse(modelement.InnerText) == 1 ? true : false);

                    if (File.SelectNodes("//Extras/Extra").Count > 0) for (int i = 0; i < 15; i++) if (car.ExtraExists(i)) car.ToggleExtra(i, false);
                    foreach (XmlElement modelement in File.SelectNodes("//Extras/Extra")) car.ToggleExtra(int.Parse(modelement.InnerText), true);

                }
                if (File.SelectSingleNode("//Acceleration") != null)
                {
                    float acc = float.Parse(File.SelectSingleNode("//Acceleration").InnerText);

                    if (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc)
                    {
                        float mul = 10f;
                        while (Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car) < acc && mul < 500)
                        {
                            mul += 10;
                            car.EnginePowerMultiplier = mul;
                            Script.Wait(0);
                        }
                    }
                }


                string DriverChosen = "default";
                if (File.SelectSingleNode("DriverName") != null) DriverChosen = File.SelectSingleNode("DriverName").InnerText;

                XmlDocument DriverXML = new XmlDocument();
                DriverXML = LoadDriver(DriverChosen);
                Model drivermodel = int.Parse(DriverXML.SelectSingleNode("//Model").InnerText);
                if (tags.Contains("street"))
                {
                    drivermodel = streetModels[GetRandomInt(0, streetModels.Length - 1)];
                }
                Ped DriverPed = World.CreatePed(drivermodel, car.Position.Around(5));
                int p = 0;
                while (!CanWeUse(DriverPed) && p < 3000)
                {
                    Log(LogImportance.Fatal, "Driver ped is not spawning, requesting again.");
                    Script.Wait(10);
                    DriverPed = World.CreatePed(drivermodel, car.Position.Around(5));
                    p++;
                    }
                DriverPed.CanWearHelmet = true;
                DriverPed.GiveHelmet(false, HelmetType.RegularMotorcycleHelmet, 0);
                DriverPed.SetIntoVehicle(car, VehicleSeat.Driver);
                DriverPed.RemoveHelmet(true);
                if (!tags.Contains("street"))
                {
                    foreach (XmlElement e in DriverXML.SelectNodes("//Cloth"))
                    {
                        int component = int.Parse(e.GetAttribute("ComponentID"));
                        int drawable = int.Parse(e.GetAttribute("DrawableID"));
                        Function.Call(Hash.SET_PED_COMPONENT_VARIATION, DriverPed, int.Parse(e.InnerText), component, drawable, 2);

                    }

                    foreach (XmlElement e in DriverXML.SelectNodes("//Clothes/Prop"))
                    {
                        // UI.Notify(e.GetAttribute("DrawableID"));
                        int prop = int.Parse(e.GetAttribute("PropID"));
                        int texture = int.Parse(e.GetAttribute("TextureID"));

                        Function.Call(Hash.SET_PED_PROP_INDEX, DriverPed, int.Parse(e.InnerText), prop, texture, true);

                    }


                }

                if (CanWeUse(car))
                    {
                    Racer r = new Racer(car, DriverPed);

                    if (File.SelectSingleNode("//Name") != null) r.Name = File.SelectSingleNode("//Name").InnerText;
                    if (File.SelectSingleNode("//Nickname") != null) r.Name = File.SelectSingleNode("//Nickname").InnerText;
                    if (r.Name == "NULL" || r.Name == null) r.Name = r.Car.DisplayName.ToString()[0].ToString().ToUpper() + r.Car.DisplayName.ToString().Substring(1).ToLowerInvariant();
                    if (car == Game.Player.Character.CurrentVehicle) r.Name = Game.Player.Name;


                    /*
                    string livery = car.GetModName(VehicleMod.Livery, car.GetMod(VehicleMod.Livery));
                    livery = Function.Call<string>(Hash._GET_LABEL_TEXT, livery);
                    livery = livery.Replace("Livery", "");
                    livery = livery.Replace("livery", "");
                    if (livery.Length > 0 && livery != "NULL") r.Name+= "("+livery+")";
                    */
                    Racers.Add(r);

                }





            }





            // car.IsPersistent = false;

            result.Add(car);
            result.Add(XMLFile);

            RaceStatus = RaceState.NotInitiated;
        }
        void CreateVehicle( Vehicle car, bool auto=false)
        {
            
            if (!CanWeUse(car))
            {
                UI.Notify("~o~Weird error.~w~Car doesn't seem to exist, try reentering.");
                return;
            }
            string name = "";
            if (auto) name = car.FriendlyName; else
            {
                UI.ShowSubtitle("~b~Enter your car's name, or leave empty to auto-generate one. ~w~~n~This will be the filename name.");
                name = Game.GetUserInput(32);
            }
            if (name == null || name == "") name = car.FriendlyName;
            if (name == null || name == "") name = car.DisplayName.ToString()[0].ToString().ToUpper() + car.DisplayName.ToString().Substring(1).ToLowerInvariant();

            string filePath = @"Scripts\ARS\Vehicles\" + name + ".xml";


            if(File.Exists(filePath))
            {
                DateTime today = DateTime.Now;
                name += " (" + today.Year + today.Month + today.Day + today.Hour + today.Minute + today.Second + ")";

                //name += " (" + DateTime.Now.GetHashCode() + ")";
            }





            File.AppendAllText(filePath, "");

            Script.Wait(200);

            XmlDocument XMLFile = new XmlDocument();


            XmlNode Data = XMLFile.CreateNode(XmlNodeType.Element, "Data", null);
            XMLFile.AppendChild(Data);

            XmlNode Vehicle = XMLFile.CreateNode(XmlNodeType.Element, "Vehicle", null);
            

            XmlNode temp = XMLFile.CreateElement("Name");
            temp.InnerText = car.FriendlyName;
            Vehicle.AppendChild(temp);

            XmlNode Class = XMLFile.CreateElement("Class");
            Class.InnerText = car.ClassType.ToString();
            Vehicle.AppendChild(Class);

            List<string> keywords = new List<string>();
            string nameAutotag = car.FriendlyName;

            nameAutotag = nameAutotag.Replace(@"-", "");
            nameAutotag = nameAutotag.Replace(@"/", "");
            nameAutotag = nameAutotag.Replace(@" ", "");


            keywords.Add(car.ClassType.ToString()); 
            keywords.Add(car.DisplayName);
            //keywords.AddRange(nameAutotag.Split(' '));
            keywords.Add(nameAutotag);
            UI.ShowSubtitle("~b~Enter the vehicle's Class set.~w~~n~Write as much as you need, separate with spaces.");
            if (!auto)
            {

                string userTags = Game.GetUserInput(32);
                if (userTags != "") keywords.AddRange(userTags.Split(' '));

            }
            XmlNode keyw = XMLFile.CreateElement("Disciplines");
            foreach (string keyword in keywords)
            {
                XmlNode ktoadd = XMLFile.CreateElement("Discipline");
                ktoadd.InnerText = keyword.ToLowerInvariant();
                keyw.AppendChild(ktoadd);
            }

            Vehicle.AppendChild(keyw);
            temp = XMLFile.CreateElement("Model");
            temp.InnerText = car.Model.Hash.ToString();
            Vehicle.AppendChild(temp);

            temp = XMLFile.CreateElement("Livery");
            temp.InnerText = car.Livery.ToString();
            Vehicle.AppendChild(temp);

            //Absolute acceleration, it iss affected by the engine power multiplier and its used to simulate further engine performance mods.
            //On load, the vehicle will be boosted until its acceleration equals this one.
            temp = XMLFile.CreateElement("Acceleration");
            temp.InnerText = Math.Round(Function.Call<float>(Hash.GET_VEHICLE_ACCELERATION, car), 3).ToString();
            temp.InnerText = temp.InnerText.Replace(",", ".");

            Vehicle.AppendChild(temp);


            XmlAttribute vname = XMLFile.CreateAttribute("ModelName");
            vname.InnerText = car.FriendlyName;
            if (vname.InnerText == "NULL") vname.InnerText = car.DisplayName;
            temp.Attributes.Append(vname);

            XmlElement Colors = XMLFile.CreateElement("Colors");

            XmlElement c = XMLFile.CreateElement("Primary");
            c.InnerText = ((int)car.PrimaryColor).ToString();
            Colors.AppendChild(c);

            c = XMLFile.CreateElement("Secondary");
            c.InnerText = ((int)car.SecondaryColor).ToString();
            Colors.AppendChild(c);

            c = XMLFile.CreateElement("Pearl");
            c.InnerText = ((int)car.PearlescentColor).ToString();
            Colors.AppendChild(c);

            c = XMLFile.CreateElement("Wheel");
            c.InnerText = ((int)car.RimColor).ToString();
            Colors.AppendChild(c);

            c = XMLFile.CreateElement("Dash");
            c.InnerText = ((int)car.DashboardColor).ToString();
            Colors.AppendChild(c);

            c = XMLFile.CreateElement("Trim");
            c.InnerText = ((int)car.TrimColor).ToString();
            Colors.AppendChild(c);

            Vehicle.AppendChild(Colors);
            XmlElement Mods = XMLFile.CreateElement("Mods");
            for (int i = 0; i <= 100; i++)
            {
                XmlElement Component = XMLFile.CreateElement("Mod");

                XmlAttribute Attribute = XMLFile.CreateAttribute("ModIndex");
                Attribute.InnerText = i.ToString();
                Component.Attributes.Append(Attribute);

                if (Function.Call<int>(Hash.GET_VEHICLE_MOD, car, i) != -1)
                {
                    Component.InnerText = Function.Call<int>(Hash.GET_VEHICLE_MOD, car, i).ToString();
                    bool iscustom = Function.Call<bool>(Hash.GET_VEHICLE_MOD_VARIATION, car, i);

                    if (iscustom)
                    {
                        XmlAttribute CustomMod = XMLFile.CreateAttribute("IsCustom");
                        CustomMod.InnerText = iscustom.ToString();
                        Component.Attributes.Append(CustomMod);

                    }
                    Mods.AppendChild(Component);

                }
            }
            XmlElement wheelkind = XMLFile.CreateElement("WheelType");
            wheelkind.InnerText = ((int)car.WheelType).ToString();
            Vehicle.AppendChild(wheelkind);

            for (int i = 0; i <= 100; i++)
            {
                XmlElement Mod = XMLFile.CreateElement("ToggleMod");

                XmlAttribute Attribute = XMLFile.CreateAttribute("ModIndex");
                Attribute.InnerText = i.ToString();
                Mod.Attributes.Append(Attribute);

                if (Function.Call<int>(Hash.IS_TOGGLE_MOD_ON, car, i) != 0)
                {
                    Mod.InnerText = Function.Call<int>(Hash.IS_TOGGLE_MOD_ON, car, i).ToString();
                    Mods.AppendChild(Mod);
                }
            }
            Vehicle.AppendChild(Mods);



            XmlElement Components = XMLFile.CreateElement("Extras");

            for (int i = 0; i <= 15; i++)
            {
                if (Function.Call<bool>(Hash.IS_VEHICLE_EXTRA_TURNED_ON, car, i))
                {
                    XmlElement Component = XMLFile.CreateElement("Extra");
                    Component.InnerText = i.ToString();
                    Components.AppendChild(Component);
                }
            }
            Vehicle.AppendChild(Components);


            Data.AppendChild(Vehicle);
            

            XMLFile.AppendChild(Data);

            XMLFile.Save(@"scripts\\ARS\Vehicles\" + name + ".xml");
            UI.ShowSubtitle("~b~Vehicle saved succesfully.~w~~n~Filename: ~g~"+name+".xml");
        }

        void CreateVehicleFromHash(VehicleHash h)
        {


            Log(LogImportance.Info, "Creating item from hash: " + h.ToString());

            if (Function.Call<int>(Hash._0x2AD93716F184EDA4, (int)h) == 0)
            {
                Log(LogImportance.Info,  h.ToString() +" has no seats. Aborting this one.");
                return;
            }


            if (Function.Call<int>(Hash.GET_VEHICLE_MODEL_ACCELERATION, (int)h) <= 0.01f)
            {
                Log(LogImportance.Info, h.ToString() + " has no engine. Aborting this one.");
                return;
            }
            string name = "text";
            name = h.ToString(); // Function.Call<string>(Hash.GET_DISPLAY_NAME_FROM_VEHICLE_MODEL, (int)h);

            string filePath = @"Scripts\ARS\Vehicles\" + name + ".xml";


            if (File.Exists(filePath))
            {
                name += " (" + DateTime.Now.GetHashCode() + ")";
            }


            File.AppendAllText(filePath, "");


            XmlDocument XMLFile = new XmlDocument();


            XmlNode Data = XMLFile.CreateNode(XmlNodeType.Element, "Data", null);
            XMLFile.AppendChild(Data);

            XmlNode Vehicle = XMLFile.CreateNode(XmlNodeType.Element, "Vehicle", null);


            XmlNode temp = XMLFile.CreateElement("Name");
            temp.InnerText = name;
            Vehicle.AppendChild(temp);

            XmlNode Class = XMLFile.CreateElement("Class");
            Class.InnerText = ((VehicleClass)Function.Call<int>(Hash.GET_VEHICLE_CLASS_FROM_NAME, (int)h)).ToString();
            Vehicle.AppendChild(Class);

            List<string> keywords = new List<string>();
            string nameAutotag = name;

            nameAutotag = nameAutotag.Replace(@"-", "");
            nameAutotag = nameAutotag.Replace(@"/", "");
            nameAutotag = nameAutotag.Replace(@" ", "");
            nameAutotag = nameAutotag.Replace(@"+", "");


            keywords.Add(Class.InnerText);
            keywords.Add(name);
            keywords.Add(nameAutotag);

            XmlNode keyw = XMLFile.CreateElement("Disciplines");
            foreach (string keyword in keywords)
            {
                XmlNode ktoadd = XMLFile.CreateElement("Discipline");
                ktoadd.InnerText = keyword.ToLowerInvariant();
                keyw.AppendChild(ktoadd);
            }

            Vehicle.AppendChild(keyw);
            temp = XMLFile.CreateElement("Model");
            temp.InnerText = ((int)h).ToString();
            Vehicle.AppendChild(temp);



            XmlAttribute vname = XMLFile.CreateAttribute("ModelName");
            vname.InnerText = h.ToString();
            temp.Attributes.Append(vname);


            Data.AppendChild(Vehicle);




            XMLFile.AppendChild(Data);

            XMLFile.Save(@"scripts\\ARS\Vehicles\" + name + ".xml");
            UI.ShowSubtitle("~b~Vehicle saved succesfully.~w~~n~Filename: ~g~" + name + ".xml");
        }
    }

}